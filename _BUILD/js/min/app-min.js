/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function (global, factory) {
  "use strict";

  if (typeof module === "object" && typeof module.exports === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var getProto = Object.getPrototypeOf;
  var slice = arr.slice;
  var flat = arr.flat ? function (array) {
    return arr.flat.call(array);
  } : function (array) {
    return arr.concat.apply([], array);
  };
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var document = window.document;
  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval(code, node, doc) {
    doc = doc || document;
    var i,
        val,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[i] || node.getAttribute && node.getAttribute(i);

        if (val) {
          script.setAttribute(i, val);
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.6.0",
      // Define a local copy of jQuery
  jQuery = function (selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function () {
      return slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function (num) {
      // Return all the elements in a clean array
      if (num == null) {
        return slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function (callback) {
      return jQuery.each(this, callback);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    even: function () {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return (i + 1) % 2;
      }));
    },
    odd: function () {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return i % 2;
      }));
    },
    eq: function (i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          copy = options[name]; // Prevent Object.prototype pollution
          // Prevent never-ending loop

          if (name === "__proto__" || target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            src = target[name]; // Ensure proper type for the source value

            if (copyIsArray && !Array.isArray(src)) {
              clone = [];
            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
              clone = {};
            } else {
              clone = src;
            }

            copyIsArray = false; // Never move original objects, clone them

            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function (msg) {
      throw new Error(msg);
    },
    noop: function () {},
    isPlainObject: function (obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function (obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function (code, options, doc) {
      DOMEval(code, {
        nonce: options && options.nonce
      }, doc);
    },
    each: function (obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // results is for internal usage only
    makeArray: function (arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function (first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function (elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function (elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return flat(ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.6
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2021-02-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function (a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function (list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function (escape, nonHex) {
      var high = "0x" + escape.slice(1) - 0x10000;
      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function (ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function () {
      setDocument();
    },
        inDisabledFieldset = addCombinator(function (elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        setDocument(context);
        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
            newSelector = selector;
            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.

            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.

              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(",");
            }

            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833

      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.


      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement("div"));
        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          var input; // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359

          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.


          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);

          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          } // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.


          el.querySelectorAll("\\\f");
          rbuggyQSA.push("[\\r\\n\\f]");
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq


        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          } // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.

        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);

      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function (match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function (match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function (match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function (className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            /* eslint-disable max-len */

            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            /* eslint-enable max-len */
          };
        },
        "CHILD": function (type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function (elem) {
          return elem === docElem;
        },
        "focus": function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function (elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function (elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function (elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function (seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0; // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq

            if (!context && elem.ownerDocument != document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function (elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var siblings = function (n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function (selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function (target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function (selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function (elem, _i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function (elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function (elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function (elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function (elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function (elem, _i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function (elem, _i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function (elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return siblings(elem.firstChild);
    },
    contents: function (elem) {
      if (elem.contentDocument != null && // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto(elem.contentDocument)) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    fired,
        // Flag to prevent firing
    locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function () {
      // Enforce single-firing
      locked = locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function () {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function () {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function (fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function () {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function () {
        locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function () {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function () {
        locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function () {
        return !!locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function (context, args) {
        if (!locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function () {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function () {
        return !!fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function (func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
        state: function () {
          return state;
        },
        always: function () {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function (fn) {
          return promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function () {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (_i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function (onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function () {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function (obj) {
          return obj != null ? jQuery.extend(obj, promise) : promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      promise.promise(deferred); // Call given func if any

      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function (singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          // the primary Deferred
      primary = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function (i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

          if (! --remaining) {
            primary.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return primary.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), primary.reject);
      }

      return primary.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function (elem, _key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(_all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function (owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function (owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function (owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function (owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function (owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function (owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function (elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function (elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function (elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function (elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (typeof key === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function () {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function (elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function (type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function () {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var documentElement = document.documentElement;

  var isAttached = function (elem) {
    return jQuery.contains(elem.ownerDocument, elem);
  },
      composed = {
    composed: true
  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.


  if (documentElement.getRootNode) {
    isAttached = function (elem) {
      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
  }

  var isHiddenWithinTree = function (elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    isAttached(elem) && jQuery.css(elem, "display") === "none";
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.

    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  })(); // We have to close these tags to support XHTML (#13200)


  var wrapMap = {
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // Support: IE <=9 only

  if (!support.option) {
    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
  }

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        attached,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      attached = isAttached(elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (attached) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).


  function expectSync(elem, type) {
    return elem === safeActiveElement() === (type === "focus");
  } // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (typeof types === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function (event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

      if (!acceptData(elem)) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = Object.create(null);
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function (nativeEvent) {
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(nativeEvent),
          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function (event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function (name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function (value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function (originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
        // Utilize native event to ensure correct state for checkable inputs
        setup: function (data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Claim the first handler

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            // dataPriv.set( el, "click", ... )
            leverageNative(el, "click", returnTrue);
          } // Return false to allow normal processing in the caller


          return false;
        },
        trigger: function (data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Force setup before triggering a click

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            leverageNative(el, "click");
          } // Return non-false to allow normal event-path propagation


          return true;
        },
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function (event) {
          var target = event.target;
          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  }; // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.

  function leverageNative(el, type, expectSync) {
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if (!expectSync) {
      if (dataPriv.get(el, type) === undefined) {
        jQuery.event.add(el, type, returnTrue);
      }

      return;
    } // Register the controller as a special universal handler for all event namespaces


    dataPriv.set(el, type, false);
    jQuery.event.add(el, type, {
      namespace: false,
      handler: function (event) {
        var notAsync,
            result,
            saved = dataPriv.get(this, type);

        if (event.isTrigger & 1 && this[type]) {
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if (!saved.length) {
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = slice.call(arguments);
            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous

            notAsync = expectSync(this, type);
            this[type]();
            result = dataPriv.get(this, type);

            if (saved !== result || notAsync) {
              dataPriv.set(this, type, false);
            } else {
              result = {};
            }

            if (saved !== result) {
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault(); // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.

              return result && result.value;
            } // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.

          } else if ((jQuery.event.special[type] || {}).delegateType) {
            event.stopPropagation();
          } // If this is a native event triggered above, everything is now in order
          // Fire an inner synthetic event with the original arguments

        } else if (saved.length) {
          // ...and capture the result
          dataPriv.set(this, type, {
            value: jQuery.event.trigger( // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
          }); // Abort handling of the native event

          event.stopImmediatePropagation();
        }
      }
    });
  }

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp);
  jQuery.each({
    focus: "focusin",
    blur: "focusout"
  }, function (type, delegateType) {
    jQuery.event.special[type] = {
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function () {
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

        return false;
      },
      trigger: function () {
        // Force setup before trigger
        leverageNative(this, type); // Return non-false to allow normal event-path propagation

        return true;
      },
      // Suppress native focus or blur as it's already being fired
      // in leverageNative.
      _default: function () {
        return true;
      },
      delegateType: delegateType
    };
  }); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (typeof types === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.get(src);
      events = pdataOld.events;

      if (events) {
        dataPriv.remove(dest, "handle events");

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = flat(args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl && !node.noModule) {
                  jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                  }, doc);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && isAttached(node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function (html) {
      return html;
    },
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function (elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function (selector) {
      return remove(this, selector, true);
    },
    remove: function (selector) {
      return remove(this, selector);
    },
    text: function (value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function () {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function () {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function (elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var swap = function (elem, options, callback) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.call(elem); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)

      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableTrDimensionsVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function () {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function () {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function () {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function () {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function () {
        computeStyleTests();
        return scrollboxSizeVal;
      },
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function () {
        var table, tr, trChild, trStyle;

        if (reliableTrDimensionsVal == null) {
          table = document.createElement("table");
          tr = document.createElement("tr");
          trChild = document.createElement("div");
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.

          tr.style.height = "1px";
          trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.

          trChild.style.display = "block";
          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
          trStyle = window.getComputedStyle(tr);
          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
          documentElement.removeChild(table);
        }

        return reliableTrDimensionsVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !isAttached(elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function () {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {}; // Return a vendor-prefixed property or undefined

  function vendorPropName(name) {
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


  function finalPropName(name) {
    var final = jQuery.cssProps[name] || vendorProps[name];

    if (final) {
      return final;
    }

    if (name in emptyStyle) {
      return name;
    }

    return vendorProps[name] = vendorPropName(name) || name;
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function setPositiveNumber(_elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0;
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,
        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.


    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" || // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
    elem.getClientRects().length) {
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.

      valueIsBorderBox = offsetProp in elem;

      if (valueIsBorderBox) {
        val = elem[offsetProp];
      }
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.


        if (type === "number" && !isCustomProp) {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (_i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function (elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && scrollboxSizeBuggy) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function (name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function (tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function () {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function (prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function (gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function (props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function (callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function () {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function (elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function (elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function (elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function (elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function (value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function (value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value,
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function (selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function (value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function (elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function (elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function (e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function (event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function (type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function () {
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = {
    guid: Date.now()
  };
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml, parserErrorElem;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {}

    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

    if (!xml || parserErrorElem) {
      jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
        return el.textContent;
      }).join("\n") : data));
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function (key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    };

    if (a == null) {
      return "";
    } // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (_i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function (target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};
      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function (key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
              }
            }

            match = responseHeaders[key.toLowerCase() + " "];
          }

          return match == null ? null : match.join(", ");
        },
        // Raw string
        getAllResponseHeaders: function () {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function (name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function (type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function (map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                statusCode[code] = [statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function (statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds

      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Use a noop converter for missing script but not if jsonp


        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
          s.converters["text script"] = function () {};
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (_i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery.ajaxPrefilter(function (s) {
    var i;

    for (i in s.headers) {
      if (i.toLowerCase() === "content-type") {
        s.contentType = s.headers[i] || "";
      }
    }
  });

  jQuery._evalUrl = function (url, options, doc) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function () {}
      },
      dataFilter: function (response) {
        jQuery.globalEval(response, options, doc);
      }
    });
  };

  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function (html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function (selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          callback = function (type) {
            return function () {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = callback();
          errorCallback = xhr.onerror = xhr.ontimeout = callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          callback = callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (callback) {
              throw e;
            }
          }
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain or forced-by-attrs requests
    if (s.crossDomain || s.scriptAttrs) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function (evt) {
            script.remove();
            callback = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && typeof params === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function (options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function () {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (_i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.fn.extend({
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  }); // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP

  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = slice.call(arguments, 2);

    proxy = function () {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };

  jQuery.trim = function (text) {
    return text == null ? "" : (text + "").replace(rtrim, "");
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return jQuery;
    });
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});
!function (t, e) {
  if ("object" == typeof exports && "object" == typeof module) module.exports = e(require("jquery"));else if ("function" == typeof define && define.amd) define(["jquery"], e);else {
    var n,
        i = "object" == typeof exports ? e(require("jquery")) : e(t.jQuery);

    for (n in i) ("object" == typeof exports ? exports : t)[n] = i[n];
  }
}(window, function (n) {
  return i = {
    "./js/entries/foundation.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var i = n("jquery"),
          i = n.n(i),
          o = n("./js/foundation.core.js");
      n.d(e, "Foundation", function () {
        return o.Foundation;
      });
      var s = n("./js/foundation.core.utils.js");
      n.d(e, "CoreUtils", function () {
        return s;
      });
      var r = n("./js/foundation.util.box.js");
      n.d(e, "Box", function () {
        return r.Box;
      });
      var a = n("./js/foundation.util.imageLoader.js");
      n.d(e, "onImagesLoaded", function () {
        return a.onImagesLoaded;
      });
      var l = n("./js/foundation.util.keyboard.js");
      n.d(e, "Keyboard", function () {
        return l.Keyboard;
      });
      var u = n("./js/foundation.util.mediaQuery.js");
      n.d(e, "MediaQuery", function () {
        return u.MediaQuery;
      });
      var c = n("./js/foundation.util.motion.js");
      n.d(e, "Motion", function () {
        return c.Motion;
      });
      var f = n("./js/foundation.util.nest.js");
      n.d(e, "Nest", function () {
        return f.Nest;
      });
      var d = n("./js/foundation.util.timer.js");
      n.d(e, "Timer", function () {
        return d.Timer;
      });
      var h = n("./js/foundation.util.touch.js");
      n.d(e, "Touch", function () {
        return h.Touch;
      });
      var p = n("./js/foundation.util.triggers.js");
      n.d(e, "Triggers", function () {
        return p.Triggers;
      });
      var m = n("./js/foundation.abide.js");
      n.d(e, "Abide", function () {
        return m.Abide;
      });
      var v = n("./js/foundation.accordion.js");
      n.d(e, "Accordion", function () {
        return v.Accordion;
      });
      var g = n("./js/foundation.accordionMenu.js");
      n.d(e, "AccordionMenu", function () {
        return g.AccordionMenu;
      });
      var y = n("./js/foundation.drilldown.js");
      n.d(e, "Drilldown", function () {
        return y.Drilldown;
      });
      var b = n("./js/foundation.dropdown.js");
      n.d(e, "Dropdown", function () {
        return b.Dropdown;
      });
      var w = n("./js/foundation.dropdownMenu.js");
      n.d(e, "DropdownMenu", function () {
        return w.DropdownMenu;
      });

      var _ = n("./js/foundation.equalizer.js");

      n.d(e, "Equalizer", function () {
        return _.Equalizer;
      });
      var $ = n("./js/foundation.interchange.js");
      n.d(e, "Interchange", function () {
        return $.Interchange;
      });
      var k = n("./js/foundation.magellan.js");
      n.d(e, "Magellan", function () {
        return k.Magellan;
      });
      var j = n("./js/foundation.offcanvas.js");
      n.d(e, "OffCanvas", function () {
        return j.OffCanvas;
      });
      var O = n("./js/foundation.orbit.js");
      n.d(e, "Orbit", function () {
        return O.Orbit;
      });
      var C = n("./js/foundation.responsiveMenu.js");
      n.d(e, "ResponsiveMenu", function () {
        return C.ResponsiveMenu;
      });
      var z = n("./js/foundation.responsiveToggle.js");
      n.d(e, "ResponsiveToggle", function () {
        return z.ResponsiveToggle;
      });
      var T = n("./js/foundation.reveal.js");
      n.d(e, "Reveal", function () {
        return T.Reveal;
      });
      var S = n("./js/foundation.slider.js");
      n.d(e, "Slider", function () {
        return S.Slider;
      });
      var R = n("./js/foundation.smoothScroll.js");
      n.d(e, "SmoothScroll", function () {
        return R.SmoothScroll;
      });
      var E = n("./js/foundation.sticky.js");
      n.d(e, "Sticky", function () {
        return E.Sticky;
      });
      var x = n("./js/foundation.tabs.js");
      n.d(e, "Tabs", function () {
        return x.Tabs;
      });
      var P = n("./js/foundation.toggler.js");
      n.d(e, "Toggler", function () {
        return P.Toggler;
      });
      var A = n("./js/foundation.tooltip.js");
      n.d(e, "Tooltip", function () {
        return A.Tooltip;
      });
      var L = n("./js/foundation.responsiveAccordionTabs.js");
      n.d(e, "ResponsiveAccordionTabs", function () {
        return L.ResponsiveAccordionTabs;
      }), o.Foundation.addToJquery(i.a), o.Foundation.rtl = s.rtl, o.Foundation.GetYoDigits = s.GetYoDigits, o.Foundation.transitionend = s.transitionend, o.Foundation.RegExpEscape = s.RegExpEscape, o.Foundation.onLoad = s.onLoad, o.Foundation.Box = r.Box, o.Foundation.onImagesLoaded = a.onImagesLoaded, o.Foundation.Keyboard = l.Keyboard, o.Foundation.MediaQuery = u.MediaQuery, o.Foundation.Motion = c.Motion, o.Foundation.Move = c.Move, o.Foundation.Nest = f.Nest, o.Foundation.Timer = d.Timer, h.Touch.init(i.a), p.Triggers.init(i.a, o.Foundation), u.MediaQuery._init(), o.Foundation.plugin(m.Abide, "Abide"), o.Foundation.plugin(v.Accordion, "Accordion"), o.Foundation.plugin(g.AccordionMenu, "AccordionMenu"), o.Foundation.plugin(y.Drilldown, "Drilldown"), o.Foundation.plugin(b.Dropdown, "Dropdown"), o.Foundation.plugin(w.DropdownMenu, "DropdownMenu"), o.Foundation.plugin(_.Equalizer, "Equalizer"), o.Foundation.plugin($.Interchange, "Interchange"), o.Foundation.plugin(k.Magellan, "Magellan"), o.Foundation.plugin(j.OffCanvas, "OffCanvas"), o.Foundation.plugin(O.Orbit, "Orbit"), o.Foundation.plugin(C.ResponsiveMenu, "ResponsiveMenu"), o.Foundation.plugin(z.ResponsiveToggle, "ResponsiveToggle"), o.Foundation.plugin(T.Reveal, "Reveal"), o.Foundation.plugin(S.Slider, "Slider"), o.Foundation.plugin(R.SmoothScroll, "SmoothScroll"), o.Foundation.plugin(E.Sticky, "Sticky"), o.Foundation.plugin(x.Tabs, "Tabs"), o.Foundation.plugin(P.Toggler, "Toggler"), o.Foundation.plugin(A.Tooltip, "Tooltip"), o.Foundation.plugin(L.ResponsiveAccordionTabs, "ResponsiveAccordionTabs"), e.default = o.Foundation;
    },
    "./js/foundation.abide.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Abide", function () {
        return i;
      });
      var e = n("jquery"),
          c = n.n(e),
          s = n("./js/foundation.core.plugin.js"),
          r = n("./js/foundation.core.utils.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function l(t, e) {
        return (l = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function u(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = f(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = f(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function f(t) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && l(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = u(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            this.$element = t, this.options = c.a.extend(!0, {}, o.defaults, this.$element.data(), e), this.isEnabled = !0, this.formnovalidate = null, this.className = "Abide", this._init();
          }
        }, {
          key: "_init",
          value: function () {
            var n = this;
            this.$inputs = c.a.merge(this.$element.find("input").not('[type="submit"]'), this.$element.find("textarea, select")), this.$submits = this.$element.find('[type="submit"]');
            var t = this.$element.find("[data-abide-error]");
            this.options.a11yAttributes && (this.$inputs.each(function (t, e) {
              return n.addA11yAttributes(c()(e));
            }), t.each(function (t, e) {
              return n.addGlobalErrorA11yAttributes(c()(e));
            })), this._events();
          }
        }, {
          key: "_events",
          value: function () {
            var e = this;
            this.$element.off(".abide").on("reset.zf.abide", function () {
              e.resetForm();
            }).on("submit.zf.abide", function () {
              return e.validateForm();
            }), this.$submits.off("click.zf.abide keydown.zf.abide").on("click.zf.abide keydown.zf.abide", function (t) {
              t.key && " " !== t.key && "Enter" !== t.key || (t.preventDefault(), e.formnovalidate = null !== t.target.getAttribute("formnovalidate"), e.$element.submit());
            }), "fieldChange" === this.options.validateOn && this.$inputs.off("change.zf.abide").on("change.zf.abide", function (t) {
              e.validateInput(c()(t.target));
            }), this.options.liveValidate && this.$inputs.off("input.zf.abide").on("input.zf.abide", function (t) {
              e.validateInput(c()(t.target));
            }), this.options.validateOnBlur && this.$inputs.off("blur.zf.abide").on("blur.zf.abide", function (t) {
              e.validateInput(c()(t.target));
            });
          }
        }, {
          key: "_reflow",
          value: function () {
            this._init();
          }
        }, {
          key: "_validationIsDisabled",
          value: function () {
            return !1 === this.isEnabled || ("boolean" == typeof this.formnovalidate ? this.formnovalidate : !!this.$submits.length && null !== this.$submits[0].getAttribute("formnovalidate"));
          }
        }, {
          key: "enableValidation",
          value: function () {
            this.isEnabled = !0;
          }
        }, {
          key: "disableValidation",
          value: function () {
            this.isEnabled = !1;
          }
        }, {
          key: "requiredCheck",
          value: function (t) {
            if (!t.attr("required")) return !0;
            var e = !0;

            switch (t[0].type) {
              case "checkbox":
                e = t[0].checked;
                break;

              case "select":
              case "select-one":
              case "select-multiple":
                var n = t.find("option:selected");
                n.length && n.val() || (e = !1);
                break;

              default:
                t.val() && t.val().length || (e = !1);
            }

            return e;
          }
        }, {
          key: "findFormError",
          value: function (e, t) {
            var n = this,
                i = e.length ? e[0].id : "",
                o = e.siblings(this.options.formErrorSelector);
            return o.length || (o = e.parent().find(this.options.formErrorSelector)), i && (o = o.add(this.$element.find('[data-form-error-for="'.concat(i, '"]')))), t && (o = o.not("[data-form-error-on]"), t.forEach(function (t) {
              o = (o = o.add(e.siblings('[data-form-error-on="'.concat(t, '"]')))).add(n.$element.find('[data-form-error-for="'.concat(i, '"][data-form-error-on="').concat(t, '"]')));
            })), o;
          }
        }, {
          key: "findLabel",
          value: function (t) {
            var e = t[0].id,
                e = this.$element.find('label[for="'.concat(e, '"]'));
            return e.length ? e : t.closest("label");
          }
        }, {
          key: "findRadioLabels",
          value: function (t) {
            var i = this,
                t = t.map(function (t, e) {
              var n = e.id,
                  n = i.$element.find('label[for="'.concat(n, '"]'));
              return (n = !n.length ? c()(e).closest("label") : n)[0];
            });
            return c()(t);
          }
        }, {
          key: "findCheckboxLabels",
          value: function (t) {
            var i = this,
                t = t.map(function (t, e) {
              var n = e.id,
                  n = i.$element.find('label[for="'.concat(n, '"]'));
              return (n = !n.length ? c()(e).closest("label") : n)[0];
            });
            return c()(t);
          }
        }, {
          key: "addErrorClasses",
          value: function (t, e) {
            var n = this.findLabel(t),
                e = this.findFormError(t, e);
            n.length && n.addClass(this.options.labelErrorClass), e.length && e.addClass(this.options.formErrorClass), t.addClass(this.options.inputErrorClass).attr({
              "data-invalid": "",
              "aria-invalid": !0
            });
          }
        }, {
          key: "addA11yAttributes",
          value: function (t) {
            var e,
                n,
                i = this.findFormError(t),
                o = i.filter("label"),
                s = i.first();
            i.length && (void 0 === t.attr("aria-describedby") && (void 0 === (e = s.attr("id")) && (e = Object(r.GetYoDigits)(6, "abide-error"), s.attr("id", e)), t.attr("aria-describedby", e)), o.filter("[for]").length < o.length && (void 0 === (n = t.attr("id")) && (n = Object(r.GetYoDigits)(6, "abide-input"), t.attr("id", n)), o.each(function (t, e) {
              e = c()(e);
              void 0 === e.attr("for") && e.attr("for", n);
            })), i.each(function (t, e) {
              e = c()(e);
              void 0 === e.attr("role") && e.attr("role", "alert");
            }).end());
          }
        }, {
          key: "addGlobalErrorA11yAttributes",
          value: function (t) {
            void 0 === t.attr("aria-live") && t.attr("aria-live", this.options.a11yErrorLevel);
          }
        }, {
          key: "removeRadioErrorClasses",
          value: function (t) {
            var e = this.$element.find(':radio[name="'.concat(t, '"]')),
                n = this.findRadioLabels(e),
                t = this.findFormError(e);
            n.length && n.removeClass(this.options.labelErrorClass), t.length && t.removeClass(this.options.formErrorClass), e.removeClass(this.options.inputErrorClass).attr({
              "data-invalid": null,
              "aria-invalid": null
            });
          }
        }, {
          key: "removeCheckboxErrorClasses",
          value: function (t) {
            var e = this.$element.find(':checkbox[name="'.concat(t, '"]')),
                n = this.findCheckboxLabels(e),
                t = this.findFormError(e);
            n.length && n.removeClass(this.options.labelErrorClass), t.length && t.removeClass(this.options.formErrorClass), e.removeClass(this.options.inputErrorClass).attr({
              "data-invalid": null,
              "aria-invalid": null
            });
          }
        }, {
          key: "removeErrorClasses",
          value: function (t) {
            if ("radio" == t[0].type) return this.removeRadioErrorClasses(t.attr("name"));
            if ("checkbox" == t[0].type) return this.removeCheckboxErrorClasses(t.attr("name"));
            var e = this.findLabel(t),
                n = this.findFormError(t);
            e.length && e.removeClass(this.options.labelErrorClass), n.length && n.removeClass(this.options.formErrorClass), t.removeClass(this.options.inputErrorClass).attr({
              "data-invalid": null,
              "aria-invalid": null
            });
          }
        }, {
          key: "validateInput",
          value: function (e) {
            var n,
                i = this,
                t = this.requiredCheck(e),
                o = e.attr("data-validator"),
                s = [],
                r = !0;
            if (this._validationIsDisabled()) return !0;
            if (e.is("[data-abide-ignore]") || e.is('[type="hidden"]') || e.is("[disabled]")) return !0;

            switch (e[0].type) {
              case "radio":
                this.validateRadio(e.attr("name")) || s.push("required");
                break;

              case "checkbox":
                this.validateCheckbox(e.attr("name")) || s.push("required"), r = !1;
                break;

              case "select":
              case "select-one":
              case "select-multiple":
                t || s.push("required");
                break;

              default:
                t || s.push("required"), this.validateText(e) || s.push("pattern");
            }

            o && (n = !!e.attr("required"), o.split(" ").forEach(function (t) {
              i.options.validators[t](e, n, e.parent()) || s.push(t);
            })), e.attr("data-equalto") && (this.options.validators.equalTo(e) || s.push("equalTo"));
            var a,
                l = 0 === s.length,
                u = (l ? "valid" : "invalid") + ".zf.abide";
            return !l || (o = this.$element.find('[data-equalto="'.concat(e.attr("id"), '"]'))).length && (a = this, o.each(function () {
              c()(this).val() && a.validateInput(c()(this));
            })), r && (l ? this.removeErrorClasses(e) : this.addErrorClasses(e, s)), e.trigger(u, [e]), l;
          }
        }, {
          key: "validateForm",
          value: function () {
            var t,
                n = this,
                e = [],
                i = this;
            if (this.initialized || (this.initialized = !0), this._validationIsDisabled()) return !(this.formnovalidate = null);
            this.$inputs.each(function () {
              if ("checkbox" === c()(this)[0].type) {
                if (c()(this).attr("name") === t) return !0;
                t = c()(this).attr("name");
              }

              e.push(i.validateInput(c()(this)));
            });
            var o = -1 === e.indexOf(!1);
            return this.$element.find("[data-abide-error]").each(function (t, e) {
              e = c()(e);
              n.options.a11yAttributes && n.addGlobalErrorA11yAttributes(e), e.css("display", o ? "none" : "block");
            }), this.$element.trigger((o ? "formvalid" : "forminvalid") + ".zf.abide", [this.$element]), o;
          }
        }, {
          key: "validateText",
          value: function (t, e) {
            e = e || t.attr("data-pattern") || t.attr("pattern") || t.attr("type");
            var n = t.val(),
                i = !0;
            return n.length && (this.options.patterns.hasOwnProperty(e) ? i = this.options.patterns[e].test(n) : e !== t.attr("type") && (i = new RegExp(e).test(n))), i;
          }
        }, {
          key: "validateRadio",
          value: function (t) {
            var t = this.$element.find(':radio[name="'.concat(t, '"]')),
                n = !1,
                i = !1;
            return t.each(function (t, e) {
              c()(e).attr("required") && (i = !0);
            }), (n = !i ? !0 : n) || t.each(function (t, e) {
              c()(e).prop("checked") && (n = !0);
            }), n;
          }
        }, {
          key: "validateCheckbox",
          value: function (t) {
            var n = this,
                t = this.$element.find(':checkbox[name="'.concat(t, '"]')),
                i = !1,
                o = !1,
                s = 1,
                r = 0;
            return t.each(function (t, e) {
              c()(e).attr("required") && (o = !0);
            }), (i = !o ? !0 : i) || (t.each(function (t, e) {
              c()(e).prop("checked") && r++, void 0 !== c()(e).attr("data-min-required") && (s = parseInt(c()(e).attr("data-min-required")));
            }), s <= r && (i = !0)), !0 !== this.initialized && 1 < s || (t.each(function (t, e) {
              i ? n.removeErrorClasses(c()(e)) : n.addErrorClasses(c()(e), ["required"]);
            }), i);
          }
        }, {
          key: "matchValidation",
          value: function (e, t, n) {
            var i = this;
            return n = !!n, -1 === t.split(" ").map(function (t) {
              return i.options.validators[t](e, n, e.parent());
            }).indexOf(!1);
          }
        }, {
          key: "resetForm",
          value: function () {
            var t = this.$element,
                e = this.options;
            c()(".".concat(e.labelErrorClass), t).not("small").removeClass(e.labelErrorClass), c()(".".concat(e.inputErrorClass), t).not("small").removeClass(e.inputErrorClass), c()("".concat(e.formErrorSelector, ".").concat(e.formErrorClass)).removeClass(e.formErrorClass), t.find("[data-abide-error]").css("display", "none"), c()(":input", t).not(":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]").val("").attr({
              "data-invalid": null,
              "aria-invalid": null
            }), c()(":input:radio", t).not("[data-abide-ignore]").prop("checked", !1).attr({
              "data-invalid": null,
              "aria-invalid": null
            }), c()(":input:checkbox", t).not("[data-abide-ignore]").prop("checked", !1).attr({
              "data-invalid": null,
              "aria-invalid": null
            }), t.trigger("formreset.zf.abide", [t]);
          }
        }, {
          key: "_destroy",
          value: function () {
            var t = this;
            this.$element.off(".abide").find("[data-abide-error]").css("display", "none"), this.$inputs.off(".abide").each(function () {
              t.removeErrorClasses(c()(this));
            }), this.$submits.off(".abide");
          }
        }]) && a(t.prototype, e), n && a(t, n), o;
      }();

      i.defaults = {
        validateOn: "fieldChange",
        labelErrorClass: "is-invalid-label",
        inputErrorClass: "is-invalid-input",
        formErrorSelector: ".form-error",
        formErrorClass: "is-visible",
        a11yAttributes: !0,
        a11yErrorLevel: "assertive",
        liveValidate: !1,
        validateOnBlur: !1,
        patterns: {
          alpha: /^[a-zA-Z]+$/,
          alpha_numeric: /^[a-zA-Z0-9]+$/,
          integer: /^[-+]?\d+$/,
          number: /^[-+]?\d*(?:[\.\,]\d+)?$/,
          card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
          cvv: /^([0-9]){3,4}$/,
          email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,
          url: /^((?:(https?|ftps?|file|ssh|sftp):\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\))+(?:\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?\xab\xbb\u201c\u201d\u2018\u2019]))$/,
          domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,
          datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
          date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
          time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
          dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
          month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
          day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,
          color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,
          website: {
            test: function (t) {
              return i.defaults.patterns.domain.test(t) || i.defaults.patterns.url.test(t);
            }
          }
        },
        validators: {
          equalTo: function (t, e, n) {
            return c()("#".concat(t.attr("data-equalto"))).val() === t.val();
          }
        }
      };
    },
    "./js/foundation.accordion.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Accordion", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.core.plugin.js"),
          a = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.util.keyboard.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function c(t, e) {
        return (c = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = d(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = d(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && c(t, e);
        }(o, r["Plugin"]);
        var t,
            e,
            n,
            i = f(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Accordion", this._init(), l.Keyboard.register("Accordion", {
              ENTER: "toggle",
              SPACE: "toggle",
              ARROW_DOWN: "next",
              ARROW_UP: "previous",
              HOME: "first",
              END: "last"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var n = this;
            this._isInitializing = !0, this.$tabs = this.$element.children("[data-accordion-item]"), this.$tabs.each(function (t, e) {
              var n = s()(e),
                  i = n.children("[data-tab-content]"),
                  o = i[0].id || Object(a.GetYoDigits)(6, "accordion"),
                  e = e.id ? "".concat(e.id, "-label") : "".concat(o, "-label");
              n.find("a:first").attr({
                "aria-controls": o,
                id: e,
                "aria-expanded": !1
              }), i.attr({
                role: "region",
                "aria-labelledby": e,
                "aria-hidden": !0,
                id: o
              });
            });
            var t = this.$element.find(".is-active").children("[data-tab-content]");
            t.length && (this._initialAnchor = t.prev("a").attr("href"), this._openSingleTab(t)), this._checkDeepLink = function () {
              var t = window.location.hash;

              if (!t.length) {
                if (n._isInitializing) return;
                n._initialAnchor && (t = n._initialAnchor);
              }

              var e = t && s()(t),
                  t = t && n.$element.find('[href$="'.concat(t, '"]'));
              !e.length || !t.length || (e && t && t.length ? t.parent("[data-accordion-item]").hasClass("is-active") || n._openSingleTab(e) : n._closeAllTabs(), n.options.deepLinkSmudge && Object(a.onLoad)(s()(window), function () {
                var t = n.$element.offset();
                s()("html, body").animate({
                  scrollTop: t.top - n.options.deepLinkSmudgeOffset
                }, n.options.deepLinkSmudgeDelay);
              }), n.$element.trigger("deeplink.zf.accordion", [t, e]));
            }, this.options.deepLink && this._checkDeepLink(), this._events(), this._isInitializing = !1;
          }
        }, {
          key: "_events",
          value: function () {
            var i = this;
            this.$tabs.each(function () {
              var e = s()(this),
                  n = e.children("[data-tab-content]");
              n.length && e.children("a").off("click.zf.accordion keydown.zf.accordion").on("click.zf.accordion", function (t) {
                t.preventDefault(), i.toggle(n);
              }).on("keydown.zf.accordion", function (t) {
                l.Keyboard.handleKey(t, "Accordion", {
                  toggle: function () {
                    i.toggle(n);
                  },
                  next: function () {
                    var t = e.next().find("a").focus();
                    i.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  previous: function () {
                    var t = e.prev().find("a").focus();
                    i.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  first: function () {
                    var t = i.$tabs.first().find(".accordion-title").focus();
                    i.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  last: function () {
                    var t = i.$tabs.last().find(".accordion-title").focus();
                    i.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  handled: function () {
                    t.preventDefault();
                  }
                });
              });
            }), this.options.deepLink && s()(window).on("hashchange", this._checkDeepLink);
          }
        }, {
          key: "toggle",
          value: function (t) {
            t.closest("[data-accordion]").is("[disabled]") ? console.info("Cannot toggle an accordion that is disabled.") : (t.parent().hasClass("is-active") ? this.up(t) : this.down(t), this.options.deepLink && (t = t.prev("a").attr("href"), this.options.updateHistory ? history.pushState({}, "", t) : history.replaceState({}, "", t)));
          }
        }, {
          key: "down",
          value: function (t) {
            t.closest("[data-accordion]").is("[disabled]") ? console.info("Cannot call down on an accordion that is disabled.") : this.options.multiExpand ? this._openTab(t) : this._openSingleTab(t);
          }
        }, {
          key: "up",
          value: function (t) {
            var e;
            this.$element.is("[disabled]") ? console.info("Cannot call up on an accordion that is disabled.") : (e = t.parent()).hasClass("is-active") && (e = e.siblings(), (this.options.allowAllClosed || e.hasClass("is-active")) && this._closeTab(t));
          }
        }, {
          key: "_openSingleTab",
          value: function (t) {
            var e = this.$element.children(".is-active").children("[data-tab-content]");
            e.length && this._closeTab(e.not(t)), this._openTab(t);
          }
        }, {
          key: "_openTab",
          value: function (t) {
            var e = this,
                n = t.parent(),
                i = t.attr("aria-labelledby");
            t.attr("aria-hidden", !1), n.addClass("is-active"), s()("#".concat(i)).attr({
              "aria-expanded": !0
            }), t.finish().slideDown(this.options.slideSpeed, function () {
              e.$element.trigger("down.zf.accordion", [t]);
            });
          }
        }, {
          key: "_closeTab",
          value: function (t) {
            var e = this,
                n = t.parent(),
                i = t.attr("aria-labelledby");
            t.attr("aria-hidden", !0), n.removeClass("is-active"), s()("#".concat(i)).attr({
              "aria-expanded": !1
            }), t.finish().slideUp(this.options.slideSpeed, function () {
              e.$element.trigger("up.zf.accordion", [t]);
            });
          }
        }, {
          key: "_closeAllTabs",
          value: function () {
            var t = this.$element.children(".is-active").children("[data-tab-content]");
            t.length && this._closeTab(t);
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.find("[data-tab-content]").stop(!0).slideUp(0).css("display", ""), this.$element.find("a").off(".zf.accordion"), this.options.deepLink && s()(window).off("hashchange", this._checkDeepLink);
          }
        }]) && u(t.prototype, e), n && u(t, n), o;
      }();

      i.defaults = {
        slideSpeed: 250,
        multiExpand: !1,
        allowAllClosed: !1,
        deepLink: !1,
        deepLinkSmudge: !1,
        deepLinkSmudgeDelay: 300,
        deepLinkSmudgeOffset: 0,
        updateHistory: !1
      };
    },
    "./js/foundation.accordionMenu.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "AccordionMenu", function () {
        return i;
      });
      var e = n("jquery"),
          a = n.n(e),
          l = n("./js/foundation.util.keyboard.js"),
          r = n("./js/foundation.util.nest.js"),
          u = n("./js/foundation.core.utils.js"),
          s = n("./js/foundation.core.plugin.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = d(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = a.a.extend({}, o.defaults, this.$element.data(), e), this.className = "AccordionMenu", this._init(), l.Keyboard.register("AccordionMenu", {
              ENTER: "toggle",
              SPACE: "toggle",
              ARROW_RIGHT: "open",
              ARROW_UP: "up",
              ARROW_DOWN: "down",
              ARROW_LEFT: "close",
              ESCAPE: "closeAll"
            });
          }
        }, {
          key: "_init",
          value: function () {
            r.Nest.Feather(this.$element, "accordion");
            var s = this;
            this.$element.find("[data-submenu]").not(".is-active").slideUp(0), this.$element.attr({
              "aria-multiselectable": this.options.multiOpen
            }), this.$menuLinks = this.$element.find(".is-accordion-submenu-parent"), this.$menuLinks.each(function () {
              var t = this.id || Object(u.GetYoDigits)(6, "acc-menu-link"),
                  e = a()(this),
                  n = e.children("[data-submenu]"),
                  i = n[0].id || Object(u.GetYoDigits)(6, "acc-menu"),
                  o = n.hasClass("is-active");
              s.options.parentLink && e.children("a").clone().prependTo(n).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-accordion-submenu-item"></li>'), s.options.submenuToggle ? (e.addClass("has-submenu-toggle"), e.children("a").after('<button id="' + t + '" class="submenu-toggle" aria-controls="' + i + '" aria-expanded="' + o + '" title="' + s.options.submenuToggleText + '"><span class="submenu-toggle-text">' + s.options.submenuToggleText + "</span></button>")) : e.attr({
                "aria-controls": i,
                "aria-expanded": o,
                id: t
              }), n.attr({
                "aria-labelledby": t,
                "aria-hidden": !o,
                role: "group",
                id: i
              });
            });
            var t = this.$element.find(".is-active");
            t.length && t.each(function () {
              s.down(a()(this));
            }), this._events();
          }
        }, {
          key: "_events",
          value: function () {
            var r = this;
            this.$element.find("li").each(function () {
              var e = a()(this).children("[data-submenu]");
              e.length && (r.options.submenuToggle ? a()(this).children(".submenu-toggle").off("click.zf.accordionMenu").on("click.zf.accordionMenu", function (t) {
                r.toggle(e);
              }) : a()(this).children("a").off("click.zf.accordionMenu").on("click.zf.accordionMenu", function (t) {
                t.preventDefault(), r.toggle(e);
              }));
            }).on("keydown.zf.accordionMenu", function (e) {
              var n,
                  i,
                  o = a()(this),
                  s = o.parent("ul").children("li"),
                  t = o.children("[data-submenu]");
              s.each(function (t) {
                a()(this).is(o) && (n = s.eq(Math.max(0, t - 1)).find("a").first(), i = s.eq(Math.min(t + 1, s.length - 1)).find("a").first(), a()(this).children("[data-submenu]:visible").length && (i = o.find("li:first-child").find("a").first()), a()(this).is(":first-child") ? n = o.parents("li").first().find("a").first() : n.parents("li").first().children("[data-submenu]:visible").length && (n = n.parents("li").find("li:last-child").find("a").first()), a()(this).is(":last-child") && (i = o.parents("li").first().next("li").find("a").first()));
              }), l.Keyboard.handleKey(e, "AccordionMenu", {
                open: function () {
                  t.is(":hidden") && (r.down(t), t.find("li").first().find("a").first().focus());
                },
                close: function () {
                  t.length && !t.is(":hidden") ? r.up(t) : o.parent("[data-submenu]").length && (r.up(o.parent("[data-submenu]")), o.parents("li").first().find("a").first().focus());
                },
                up: function () {
                  return n.focus(), !0;
                },
                down: function () {
                  return i.focus(), !0;
                },
                toggle: function () {
                  return !r.options.submenuToggle && (o.children("[data-submenu]").length ? (r.toggle(o.children("[data-submenu]")), !0) : void 0);
                },
                closeAll: function () {
                  r.hideAll();
                },
                handled: function (t) {
                  t && e.preventDefault();
                }
              });
            });
          }
        }, {
          key: "hideAll",
          value: function () {
            this.up(this.$element.find("[data-submenu]"));
          }
        }, {
          key: "showAll",
          value: function () {
            this.down(this.$element.find("[data-submenu]"));
          }
        }, {
          key: "toggle",
          value: function (t) {
            t.is(":animated") || (t.is(":hidden") ? this.down(t) : this.up(t));
          }
        }, {
          key: "down",
          value: function (t) {
            var e,
                n = this;
            this.options.multiOpen || (e = t.parentsUntil(this.$element).add(t).add(t.find(".is-active")), e = this.$element.find(".is-active").not(e), this.up(e)), t.addClass("is-active").attr({
              "aria-hidden": !1
            }), (this.options.submenuToggle ? t.prev(".submenu-toggle") : t.parent(".is-accordion-submenu-parent")).attr({
              "aria-expanded": !0
            }), t.slideDown(this.options.slideSpeed, function () {
              n.$element.trigger("down.zf.accordionMenu", [t]);
            });
          }
        }, {
          key: "up",
          value: function (t) {
            var e = this,
                n = t.find("[data-submenu]"),
                i = t.add(n);
            n.slideUp(0), i.removeClass("is-active").attr("aria-hidden", !0), (this.options.submenuToggle ? i.prev(".submenu-toggle") : i.parent(".is-accordion-submenu-parent")).attr("aria-expanded", !1), t.slideUp(this.options.slideSpeed, function () {
              e.$element.trigger("up.zf.accordionMenu", [t]);
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.find("[data-submenu]").slideDown(0).css("display", ""), this.$element.find("a").off("click.zf.accordionMenu"), this.$element.find("[data-is-parent-link]").detach(), this.options.submenuToggle && (this.$element.find(".has-submenu-toggle").removeClass("has-submenu-toggle"), this.$element.find(".submenu-toggle").remove()), r.Nest.Burn(this.$element, "accordion");
          }
        }]) && c(t.prototype, e), n && c(t, n), o;
      }();

      i.defaults = {
        parentLink: !1,
        slideSpeed: 250,
        submenuToggle: !1,
        submenuToggleText: "Toggle menu",
        multiOpen: !0
      };
    },
    "./js/foundation.core.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Foundation", function () {
        return l;
      });
      var e = n("jquery"),
          s = n.n(e),
          i = n("./js/foundation.core.utils.js"),
          r = n("./js/foundation.util.mediaQuery.js");

      function a(t) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      var l = {
        version: "6.7.3",
        _plugins: {},
        _uuids: [],
        plugin: function (t, e) {
          var n = e || u(t),
              e = o(n);
          this._plugins[e] = this[n] = t;
        },
        registerPlugin: function (t, e) {
          e = e ? o(e) : u(t.constructor).toLowerCase();
          t.uuid = Object(i.GetYoDigits)(6, e), t.$element.attr("data-".concat(e)) || t.$element.attr("data-".concat(e), t.uuid), t.$element.data("zfPlugin") || t.$element.data("zfPlugin", t), t.$element.trigger("init.zf.".concat(e)), this._uuids.push(t.uuid);
        },
        unregisterPlugin: function (t) {
          var e,
              n = o(u(t.$element.data("zfPlugin").constructor));

          for (e in this._uuids.splice(this._uuids.indexOf(t.uuid), 1), t.$element.removeAttr("data-".concat(n)).removeData("zfPlugin").trigger("destroyed.zf.".concat(n)), t) t[e] = null;
        },
        reInit: function (t) {
          var e,
              n,
              i = t instanceof s.a;

          try {
            i ? t.each(function () {
              s()(this).data("zfPlugin")._init();
            }) : (e = a(t), n = this, {
              object: function (t) {
                t.forEach(function (t) {
                  t = o(t), s()("[data-" + t + "]").foundation("_init");
                });
              },
              string: function () {
                t = o(t), s()("[data-" + t + "]").foundation("_init");
              },
              undefined: function () {
                this.object(Object.keys(n._plugins));
              }
            }[e](t));
          } catch (t) {
            console.error(t);
          } finally {
            return t;
          }
        },
        reflow: function (n, t) {
          void 0 === t ? t = Object.keys(this._plugins) : "string" == typeof t && (t = [t]);
          var o = this;
          s.a.each(t, function (t, e) {
            var i = o._plugins[e];
            s()(n).find("[data-" + e + "]").addBack("[data-" + e + "]").filter(function () {
              return void 0 === s()(this).data("zfPlugin");
            }).each(function () {
              var t = s()(this),
                  n = {
                reflow: !0
              };
              t.attr("data-options") && t.attr("data-options").split(";").forEach(function (t, e) {
                t = t.split(":").map(function (t) {
                  return t.trim();
                });
                t[0] && (n[t[0]] = function (t) {
                  {
                    if ("true" === t) return !0;
                    if ("false" === t) return !1;
                    if (!isNaN(+t)) return parseFloat(t);
                  }
                  return t;
                }(t[1]));
              });

              try {
                t.data("zfPlugin", new i(s()(this), n));
              } catch (t) {
                console.error(t);
              } finally {
                return;
              }
            });
          });
        },
        getFnName: u,
        addToJquery: function (s) {
          return s.fn.foundation = function (n) {
            var t = a(n),
                e = s(".no-js");
            if (e.length && e.removeClass("no-js"), "undefined" === t) r.MediaQuery._init(), l.reflow(this);else {
              if ("string" !== t) throw new TypeError("We're sorry, ".concat(t, " is not a valid parameter. You must use a string representing the method you wish to invoke."));
              var i = Array.prototype.slice.call(arguments, 1),
                  o = this.data("zfPlugin");
              if (void 0 === o || void 0 === o[n]) throw new ReferenceError("We're sorry, '" + n + "' is not an available method for " + (o ? u(o) : "this element") + ".");
              1 === this.length ? o[n].apply(o, i) : this.each(function (t, e) {
                o[n].apply(s(e).data("zfPlugin"), i);
              });
            }
            return this;
          }, s;
        }
      };

      function u(t) {
        if (void 0 !== Function.prototype.name) return (void 0 === t.prototype ? t : t.prototype).constructor.name;
        t = /function\s([^(]{1,})\(/.exec(t.toString());
        return t && 1 < t.length ? t[1].trim() : "";
      }

      function o(t) {
        return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }

      l.util = {
        throttle: function (n, i) {
          var o = null;
          return function () {
            var t = this,
                e = arguments;
            null === o && (o = setTimeout(function () {
              n.apply(t, e), o = null;
            }, i));
          };
        }
      }, window.Foundation = l, function () {
        Date.now && window.Date.now || (window.Date.now = Date.now = function () {
          return new Date().getTime();
        });

        for (var i, t = ["webkit", "moz"], e = 0; e < t.length && !window.requestAnimationFrame; ++e) {
          var n = t[e];
          window.requestAnimationFrame = window[n + "RequestAnimationFrame"], window.cancelAnimationFrame = window[n + "CancelAnimationFrame"] || window[n + "CancelRequestAnimationFrame"];
        }

        !/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) && window.requestAnimationFrame && window.cancelAnimationFrame || (i = 0, window.requestAnimationFrame = function (t) {
          var e = Date.now(),
              n = Math.max(i + 16, e);
          return setTimeout(function () {
            t(i = n);
          }, n - e);
        }, window.cancelAnimationFrame = clearTimeout), window.performance && window.performance.now || (window.performance = {
          start: Date.now(),
          now: function () {
            return Date.now() - this.start;
          }
        });
      }(), Function.prototype.bind || (Function.prototype.bind = function (t) {
        if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");

        function e() {
          return i.apply(this instanceof o ? this : t, n.concat(Array.prototype.slice.call(arguments)));
        }

        var n = Array.prototype.slice.call(arguments, 1),
            i = this,
            o = function () {};

        return this.prototype && (o.prototype = this.prototype), e.prototype = new o(), e;
      });
    },
    "./js/foundation.core.plugin.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Plugin", function () {
        return i;
      });
      var e = n("jquery"),
          o = n("./js/foundation.core.utils.js");

      function s(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      var i = function () {
        function n(t, e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, n), this._setup(t, e);
          e = r(this);
          this.uuid = Object(o.GetYoDigits)(6, e), this.$element.attr("data-".concat(e)) || this.$element.attr("data-".concat(e), this.uuid), this.$element.data("zfPlugin") || this.$element.data("zfPlugin", this), this.$element.trigger("init.zf.".concat(e));
        }

        var t, e, i;
        return t = n, (e = [{
          key: "destroy",
          value: function () {
            this._destroy();

            var t,
                e = r(this);

            for (t in this.$element.removeAttr("data-".concat(e)).removeData("zfPlugin").trigger("destroyed.zf.".concat(e)), this) this[t] = null;
          }
        }]) && s(t.prototype, e), i && s(t, i), n;
      }();

      function r(t) {
        return t.className.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
    },
    "./js/foundation.core.utils.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "rtl", function () {
        return i;
      }), n.d(e, "GetYoDigits", function () {
        return o;
      }), n.d(e, "RegExpEscape", function () {
        return s;
      }), n.d(e, "transitionend", function () {
        return r;
      }), n.d(e, "onLoad", function () {
        return a;
      }), n.d(e, "ignoreMousedisappear", function () {
        return u;
      });
      var e = n("jquery"),
          l = n.n(e);

      function i() {
        return "rtl" === l()("html").attr("dir");
      }

      function o() {
        for (var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 6, e = 1 < arguments.length ? arguments[1] : void 0, n = "", i = "0123456789abcdefghijklmnopqrstuvwxyz", o = i.length, s = 0; s < t; s++) n += i[Math.floor(Math.random() * o)];

        return e ? "".concat(n, "-").concat(e) : n;
      }

      function s(t) {
        return t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      function r(t) {
        var e,
            n,
            i = {
          transition: "transitionend",
          WebkitTransition: "webkitTransitionEnd",
          MozTransition: "transitionend",
          OTransition: "otransitionend"
        },
            o = document.createElement("div");

        for (n in i) void 0 !== o.style[n] && (e = i[n]);

        return e || (setTimeout(function () {
          t.triggerHandler("transitionend", [t]);
        }, 1), "transitionend");
      }

      function a(t, e) {
        function n() {
          return t.triggerHandler(o);
        }

        var i = "complete" === document.readyState,
            o = (i ? "_didLoad" : "load") + ".zf.util.onLoad";
        return t && (e && t.one(o, e), i ? setTimeout(n) : l()(window).one("load", n)), o;
      }

      function u(s) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
            e = t.ignoreLeaveWindow,
            r = void 0 !== e && e,
            t = t.ignoreReappear,
            a = void 0 !== t && t;
        return function (e) {
          for (var t = arguments.length, n = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];

          var o = s.bind.apply(s, [this, e].concat(n));
          if (null !== e.relatedTarget) return o();
          setTimeout(function () {
            return r || !document.hasFocus || document.hasFocus() ? void (a || l()(document).one("mouseenter", function (t) {
              l()(e.currentTarget).has(t.target).length || (e.relatedTarget = t.target, o());
            })) : o();
          }, 0);
        };
      }
    },
    "./js/foundation.drilldown.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Drilldown", function () {
        return i;
      });
      var e = n("jquery"),
          r = n.n(e),
          a = n("./js/foundation.util.keyboard.js"),
          s = n("./js/foundation.util.nest.js"),
          l = n("./js/foundation.core.utils.js"),
          u = n("./js/foundation.util.box.js"),
          c = n("./js/foundation.core.plugin.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function f(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function d(t, e) {
        return (d = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function h(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = p(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = p(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function p(t) {
        return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && d(t, e);
        }(o, c["Plugin"]);
        var t,
            e,
            n,
            i = h(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = r.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Drilldown", this._init(), a.Keyboard.register("Drilldown", {
              ENTER: "open",
              SPACE: "open",
              ARROW_RIGHT: "next",
              ARROW_UP: "up",
              ARROW_DOWN: "down",
              ARROW_LEFT: "previous",
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            s.Nest.Feather(this.$element, "drilldown"), this.options.autoApplyClass && this.$element.addClass("drilldown"), this.$element.attr({
              "aria-multiselectable": !1
            }), this.$submenuAnchors = this.$element.find("li.is-drilldown-submenu-parent").children("a"), this.$submenus = this.$submenuAnchors.parent("li").children("[data-submenu]").attr("role", "group"), this.$menuItems = this.$element.find("li").not(".js-drilldown-back").find("a"), this.$currentMenu = this.$element, this.$element.attr("data-mutate", this.$element.attr("data-drilldown") || Object(l.GetYoDigits)(6, "drilldown")), this._prepareMenu(), this._registerEvents(), this._keyboardEvents();
          }
        }, {
          key: "_prepareMenu",
          value: function () {
            var n = this;
            this.$submenuAnchors.each(function () {
              var t = r()(this),
                  e = t.parent();
              n.options.parentLink && t.clone().prependTo(e.children("[data-submenu]")).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="none"></li>'), t.data("savedHref", t.attr("href")).removeAttr("href").attr("tabindex", 0), t.children("[data-submenu]").attr({
                "aria-hidden": !0,
                tabindex: 0,
                role: "group"
              }), n._events(t);
            }), this.$submenus.each(function () {
              var t = r()(this);
              if (!t.find(".js-drilldown-back").length) switch (n.options.backButtonPosition) {
                case "bottom":
                  t.append(n.options.backButton);
                  break;

                case "top":
                  t.prepend(n.options.backButton);
                  break;

                default:
                  console.error("Unsupported backButtonPosition value '" + n.options.backButtonPosition + "'");
              }

              n._back(t);
            }), this.$submenus.addClass("invisible"), this.options.autoHeight || this.$submenus.addClass("drilldown-submenu-cover-previous"), this.$element.parent().hasClass("is-drilldown") || (this.$wrapper = r()(this.options.wrapper).addClass("is-drilldown"), this.options.animateHeight && this.$wrapper.addClass("animate-height"), this.$element.wrap(this.$wrapper)), this.$wrapper = this.$element.parent(), this.$wrapper.css(this._getMaxDims());
          }
        }, {
          key: "_resize",
          value: function () {
            this.$wrapper.css({
              "max-width": "none",
              "min-height": "none"
            }), this.$wrapper.css(this._getMaxDims());
          }
        }, {
          key: "_events",
          value: function (n) {
            var i = this;
            n.off("click.zf.drilldown").on("click.zf.drilldown", function (t) {
              var e;
              r()(t.target).parentsUntil("ul", "li").hasClass("is-drilldown-submenu-parent") && t.preventDefault(), i._show(n.parent("li")), i.options.closeOnClick && (e = r()("body")).off(".zf.drilldown").on("click.zf.drilldown", function (t) {
                t.target === i.$element[0] || r.a.contains(i.$element[0], t.target) || (t.preventDefault(), i._hideAll(), e.off(".zf.drilldown"));
              });
            });
          }
        }, {
          key: "_registerEvents",
          value: function () {
            this.options.scrollTop && (this._bindHandler = this._scrollTop.bind(this), this.$element.on("open.zf.drilldown hide.zf.drilldown close.zf.drilldown closed.zf.drilldown", this._bindHandler)), this.$element.on("mutateme.zf.trigger", this._resize.bind(this));
          }
        }, {
          key: "_scrollTop",
          value: function () {
            var t = this,
                e = "" != t.options.scrollTopElement ? r()(t.options.scrollTopElement) : t.$element,
                e = parseInt(e.offset().top + t.options.scrollTopOffset, 10);
            r()("html, body").stop(!0).animate({
              scrollTop: e
            }, t.options.animationDuration, t.options.animationEasing, function () {
              this === r()("html")[0] && t.$element.trigger("scrollme.zf.drilldown");
            });
          }
        }, {
          key: "_keyboardEvents",
          value: function () {
            var t = this;
            this.$menuItems.add(this.$element.find(".js-drilldown-back > a, .is-submenu-parent-item > a")).on("keydown.zf.drilldown", function (e) {
              var n,
                  i,
                  o = r()(this),
                  s = o.parent("li").parent("ul").children("li").children("a");
              s.each(function (t) {
                r()(this).is(o) && (n = s.eq(Math.max(0, t - 1)), i = s.eq(Math.min(t + 1, s.length - 1)));
              }), a.Keyboard.handleKey(e, "Drilldown", {
                next: function () {
                  if (o.is(t.$submenuAnchors)) return t._show(o.parent("li")), o.parent("li").one(Object(l.transitionend)(o), function () {
                    o.parent("li").find("ul li a").not(".js-drilldown-back a").first().focus();
                  }), !0;
                },
                previous: function () {
                  return t._hide(o.parent("li").parent("ul")), o.parent("li").parent("ul").one(Object(l.transitionend)(o), function () {
                    setTimeout(function () {
                      o.parent("li").parent("ul").parent("li").children("a").first().focus();
                    }, 1);
                  }), !0;
                },
                up: function () {
                  return n.focus(), !o.is(t.$element.find("> li:first-child > a"));
                },
                down: function () {
                  return i.focus(), !o.is(t.$element.find("> li:last-child > a"));
                },
                close: function () {
                  o.is(t.$element.find("> li > a")) || (t._hide(o.parent().parent()), o.parent().parent().siblings("a").focus());
                },
                open: function () {
                  return (!t.options.parentLink || !o.attr("href")) && (o.is(t.$menuItems) ? o.is(t.$submenuAnchors) ? (t._show(o.parent("li")), o.parent("li").one(Object(l.transitionend)(o), function () {
                    o.parent("li").find("ul li a").not(".js-drilldown-back a").first().focus();
                  }), !0) : void 0 : (t._hide(o.parent("li").parent("ul")), o.parent("li").parent("ul").one(Object(l.transitionend)(o), function () {
                    setTimeout(function () {
                      o.parent("li").parent("ul").parent("li").children("a").first().focus();
                    }, 1);
                  }), !0));
                },
                handled: function (t) {
                  t && e.preventDefault();
                }
              });
            });
          }
        }, {
          key: "_hideAll",
          value: function () {
            var t,
                e = this,
                n = this.$element.find(".is-drilldown-submenu.is-active");
            n.addClass("is-closing"), this.options.autoHeight && (t = n.parent().closest("ul").data("calcHeight"), this.$wrapper.css({
              height: t
            })), this.$element.trigger("close.zf.drilldown"), n.one(Object(l.transitionend)(n), function () {
              n.removeClass("is-active is-closing"), e.$element.trigger("closed.zf.drilldown");
            });
          }
        }, {
          key: "_back",
          value: function (n) {
            var i = this;
            n.off("click.zf.drilldown"), n.children(".js-drilldown-back").on("click.zf.drilldown", function (t) {
              i._hide(n);

              var e = n.parent("li").parent("ul").parent("li");
              e.length ? i._show(e) : i.$currentMenu = i.$element;
            });
          }
        }, {
          key: "_menuLinkEvents",
          value: function () {
            var e = this;
            this.$menuItems.not(".is-drilldown-submenu-parent").off("click.zf.drilldown").on("click.zf.drilldown", function (t) {
              setTimeout(function () {
                e._hideAll();
              }, 0);
            });
          }
        }, {
          key: "_setShowSubMenuClasses",
          value: function (t, e) {
            t.addClass("is-active").removeClass("invisible").attr("aria-hidden", !1), t.parent("li").attr("aria-expanded", !0), !0 === e && this.$element.trigger("open.zf.drilldown", [t]);
          }
        }, {
          key: "_setHideSubMenuClasses",
          value: function (t, e) {
            t.removeClass("is-active").addClass("invisible").attr("aria-hidden", !0), t.parent("li").attr("aria-expanded", !1), !0 === e && t.trigger("hide.zf.drilldown", [t]);
          }
        }, {
          key: "_showMenu",
          value: function (e, n) {
            var i = this;
            if (this.$element.find('li[aria-expanded="true"] > ul[data-submenu]').each(function (t) {
              i._setHideSubMenuClasses(r()(this));
            }), (this.$currentMenu = e).is("[data-drilldown]")) return !0 === n && e.find("li > a").first().focus(), void (this.options.autoHeight && this.$wrapper.css("height", e.data("calcHeight")));
            var o = e.children().first().parentsUntil("[data-drilldown]", "[data-submenu]");
            o.each(function (t) {
              0 === t && i.options.autoHeight && i.$wrapper.css("height", r()(this).data("calcHeight"));
              t = t == o.length - 1;
              !0 == t && r()(this).one(Object(l.transitionend)(r()(this)), function () {
                !0 === n && e.find("li > a").first().focus();
              }), i._setShowSubMenuClasses(r()(this), t);
            });
          }
        }, {
          key: "_show",
          value: function (t) {
            var e = t.children("[data-submenu]");
            t.attr("aria-expanded", !0), this.$currentMenu = e, t.parent().closest("ul").addClass("invisible"), e.addClass("is-active visible").removeClass("invisible").attr("aria-hidden", !1), this.options.autoHeight && this.$wrapper.css({
              height: e.data("calcHeight")
            }), this.$element.trigger("open.zf.drilldown", [t]);
          }
        }, {
          key: "_hide",
          value: function (t) {
            this.options.autoHeight && this.$wrapper.css({
              height: t.parent().closest("ul").data("calcHeight")
            });
            t.parent().closest("ul").removeClass("invisible"), t.parent("li").attr("aria-expanded", !1), t.attr("aria-hidden", !0), t.addClass("is-closing").one(Object(l.transitionend)(t), function () {
              t.removeClass("is-active is-closing visible"), t.blur().addClass("invisible");
            }), t.trigger("hide.zf.drilldown", [t]);
          }
        }, {
          key: "_getMaxDims",
          value: function () {
            var e = 0,
                t = {},
                n = this;
            return this.$submenus.add(this.$element).each(function () {
              r()(this).children("li").length;
              var t = u.Box.GetDimensions(this).height;
              e = e < t ? t : e, n.options.autoHeight && r()(this).data("calcHeight", t);
            }), this.options.autoHeight ? t.height = this.$currentMenu.data("calcHeight") : t["min-height"] = "".concat(e, "px"), t["max-width"] = "".concat(this.$element[0].getBoundingClientRect().width, "px"), t;
          }
        }, {
          key: "_destroy",
          value: function () {
            r()("body").off(".zf.drilldown"), this.options.scrollTop && this.$element.off(".zf.drilldown", this._bindHandler), this._hideAll(), this.$element.off("mutateme.zf.trigger"), s.Nest.Burn(this.$element, "drilldown"), this.$element.unwrap().find(".js-drilldown-back, .is-submenu-parent-item").remove().end().find(".is-active, .is-closing, .is-drilldown-submenu").removeClass("is-active is-closing is-drilldown-submenu").off("transitionend otransitionend webkitTransitionEnd").end().find("[data-submenu]").removeAttr("aria-hidden tabindex role"), this.$submenuAnchors.each(function () {
              r()(this).off(".zf.drilldown");
            }), this.$element.find("[data-is-parent-link]").detach(), this.$submenus.removeClass("drilldown-submenu-cover-previous invisible"), this.$element.find("a").each(function () {
              var t = r()(this);
              t.removeAttr("tabindex"), t.data("savedHref") && t.attr("href", t.data("savedHref")).removeData("savedHref");
            });
          }
        }]) && f(t.prototype, e), n && f(t, n), o;
      }();

      i.defaults = {
        autoApplyClass: !0,
        backButton: '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',
        backButtonPosition: "top",
        wrapper: "<div></div>",
        parentLink: !1,
        closeOnClick: !1,
        autoHeight: !1,
        animateHeight: !1,
        scrollTop: !1,
        scrollTopElement: "",
        scrollTopOffset: 0,
        animationDuration: 500,
        animationEasing: "swing"
      };
    },
    "./js/foundation.dropdown.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Dropdown", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.util.keyboard.js"),
          a = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.positionable.js"),
          u = n("./js/foundation.util.triggers.js"),
          c = n("./js/foundation.util.touch.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function f(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function d(t, e, n) {
        return (d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
          t = function (t, e) {
            for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = m(t)););

            return t;
          }(t, e);

          if (t) {
            e = Object.getOwnPropertyDescriptor(t, e);
            return e.get ? e.get.call(n) : e.value;
          }
        })(t, e, n || t);
      }

      function h(t, e) {
        return (h = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function p(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = m(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = m(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function m(t) {
        return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && h(t, e);
        }(o, l["Positionable"]);
        var t,
            e,
            n,
            i = p(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Dropdown", c.Touch.init(s.a), u.Triggers.init(s.a), this._init(), r.Keyboard.register("Dropdown", {
              ENTER: "toggle",
              SPACE: "toggle",
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element.attr("id");
            this.$anchors = s()('[data-toggle="'.concat(t, '"]')).length ? s()('[data-toggle="'.concat(t, '"]')) : s()('[data-open="'.concat(t, '"]')), this.$anchors.attr({
              "aria-controls": t,
              "data-is-focus": !1,
              "data-yeti-box": t,
              "aria-haspopup": !0,
              "aria-expanded": !1
            }), this._setCurrentAnchor(this.$anchors.first()), this.options.parentClass ? this.$parent = this.$element.parents("." + this.options.parentClass) : this.$parent = null, void 0 === this.$element.attr("aria-labelledby") && (void 0 === this.$currentAnchor.attr("id") && this.$currentAnchor.attr("id", Object(a.GetYoDigits)(6, "dd-anchor")), this.$element.attr("aria-labelledby", this.$currentAnchor.attr("id"))), this.$element.attr({
              "aria-hidden": "true",
              "data-yeti-box": t,
              "data-resize": t
            }), d(m(o.prototype), "_init", this).call(this), this._events();
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            var t = this.$element[0].className.match(/(top|left|right|bottom)/g);
            return t ? t[0] : "bottom";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            var t = /float-(\S+)/.exec(this.$currentAnchor.attr("class"));
            return t ? t[1] : d(m(o.prototype), "_getDefaultAlignment", this).call(this);
          }
        }, {
          key: "_setPosition",
          value: function () {
            this.$element.removeClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment)), d(m(o.prototype), "_setPosition", this).call(this, this.$currentAnchor, this.$element, this.$parent), this.$element.addClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment));
          }
        }, {
          key: "_setCurrentAnchor",
          value: function (t) {
            this.$currentAnchor = s()(t);
          }
        }, {
          key: "_events",
          value: function () {
            var n = this,
                e = "ontouchstart" in window || void 0 !== window.ontouchstart;
            this.$element.on({
              "open.zf.trigger": this.open.bind(this),
              "close.zf.trigger": this.close.bind(this),
              "toggle.zf.trigger": this.toggle.bind(this),
              "resizeme.zf.trigger": this._setPosition.bind(this)
            }), this.$anchors.off("click.zf.trigger").on("click.zf.trigger", function (t) {
              n._setCurrentAnchor(this), (!1 === n.options.forceFollow || e && n.options.hover && !1 === n.$element.hasClass("is-open")) && t.preventDefault();
            }), this.options.hover && (this.$anchors.off("mouseenter.zf.dropdown mouseleave.zf.dropdown").on("mouseenter.zf.dropdown", function () {
              n._setCurrentAnchor(this);

              var t = s()("body").data();
              void 0 !== t.whatinput && "mouse" !== t.whatinput || (clearTimeout(n.timeout), n.timeout = setTimeout(function () {
                n.open(), n.$anchors.data("hover", !0);
              }, n.options.hoverDelay));
            }).on("mouseleave.zf.dropdown", Object(a.ignoreMousedisappear)(function () {
              clearTimeout(n.timeout), n.timeout = setTimeout(function () {
                n.close(), n.$anchors.data("hover", !1);
              }, n.options.hoverDelay);
            })), this.options.hoverPane && this.$element.off("mouseenter.zf.dropdown mouseleave.zf.dropdown").on("mouseenter.zf.dropdown", function () {
              clearTimeout(n.timeout);
            }).on("mouseleave.zf.dropdown", Object(a.ignoreMousedisappear)(function () {
              clearTimeout(n.timeout), n.timeout = setTimeout(function () {
                n.close(), n.$anchors.data("hover", !1);
              }, n.options.hoverDelay);
            }))), this.$anchors.add(this.$element).on("keydown.zf.dropdown", function (t) {
              var e = s()(this);
              r.Keyboard.findFocusable(n.$element);
              r.Keyboard.handleKey(t, "Dropdown", {
                open: function () {
                  e.is(n.$anchors) && !e.is("input, textarea") && (n.open(), n.$element.attr("tabindex", -1).focus(), t.preventDefault());
                },
                close: function () {
                  n.close(), n.$anchors.focus();
                }
              });
            });
          }
        }, {
          key: "_addBodyHandler",
          value: function () {
            var e = s()(document.body).not(this.$element),
                n = this;
            e.off("click.zf.dropdown tap.zf.dropdown").on("click.zf.dropdown tap.zf.dropdown", function (t) {
              n.$anchors.is(t.target) || n.$anchors.find(t.target).length || n.$element.is(t.target) || n.$element.find(t.target).length || (n.close(), e.off("click.zf.dropdown tap.zf.dropdown"));
            });
          }
        }, {
          key: "open",
          value: function () {
            var t;
            this.$element.trigger("closeme.zf.dropdown", this.$element.attr("id")), this.$anchors.addClass("hover").attr({
              "aria-expanded": !0
            }), this.$element.addClass("is-opening"), this._setPosition(), this.$element.removeClass("is-opening").addClass("is-open").attr({
              "aria-hidden": !1
            }), !this.options.autoFocus || (t = r.Keyboard.findFocusable(this.$element)).length && t.eq(0).focus(), this.options.closeOnClick && this._addBodyHandler(), this.options.trapFocus && r.Keyboard.trapFocus(this.$element), this.$element.trigger("show.zf.dropdown", [this.$element]);
          }
        }, {
          key: "close",
          value: function () {
            if (!this.$element.hasClass("is-open")) return !1;
            this.$element.removeClass("is-open").attr({
              "aria-hidden": !0
            }), this.$anchors.removeClass("hover").attr("aria-expanded", !1), this.$element.trigger("hide.zf.dropdown", [this.$element]), this.options.trapFocus && r.Keyboard.releaseFocus(this.$element);
          }
        }, {
          key: "toggle",
          value: function () {
            this.$element.hasClass("is-open") ? this.$anchors.data("hover") || this.close() : this.open();
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.trigger").hide(), this.$anchors.off(".zf.dropdown"), s()(document.body).off("click.zf.dropdown tap.zf.dropdown");
          }
        }]) && f(t.prototype, e), n && f(t, n), o;
      }();

      i.defaults = {
        parentClass: null,
        hoverDelay: 250,
        hover: !1,
        hoverPane: !1,
        vOffset: 0,
        hOffset: 0,
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !0,
        trapFocus: !1,
        autoFocus: !1,
        closeOnClick: !1,
        forceFollow: !0
      };
    },
    "./js/foundation.dropdownMenu.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "DropdownMenu", function () {
        return i;
      });
      var e = n("jquery"),
          d = n.n(e),
          s = n("./js/foundation.core.plugin.js"),
          a = n("./js/foundation.core.utils.js"),
          h = n("./js/foundation.util.keyboard.js"),
          r = n("./js/foundation.util.nest.js"),
          l = n("./js/foundation.util.box.js"),
          u = n("./js/foundation.util.touch.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function p(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = m(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = m(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function m(t) {
        return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = p(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = d.a.extend({}, o.defaults, this.$element.data(), e), this.className = "DropdownMenu", u.Touch.init(d.a), this._init(), h.Keyboard.register("DropdownMenu", {
              ENTER: "open",
              SPACE: "open",
              ARROW_RIGHT: "next",
              ARROW_UP: "up",
              ARROW_DOWN: "down",
              ARROW_LEFT: "previous",
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            r.Nest.Feather(this.$element, "dropdown");
            var t = this.$element.find("li.is-dropdown-submenu-parent");
            this.$element.children(".is-dropdown-submenu-parent").children(".is-dropdown-submenu").addClass("first-sub"), this.$menuItems = this.$element.find('li[role="none"]'), this.$tabs = this.$element.children('li[role="none"]'), this.$tabs.find("ul.is-dropdown-submenu").addClass(this.options.verticalClass), "auto" === this.options.alignment ? this.$element.hasClass(this.options.rightClass) || Object(a.rtl)() || this.$element.parents(".top-bar-right").is("*") ? (this.options.alignment = "right", t.addClass("opens-left")) : (this.options.alignment = "left", t.addClass("opens-right")) : "right" === this.options.alignment ? t.addClass("opens-left") : t.addClass("opens-right"), this.changed = !1, this._events();
          }
        }, {
          key: "_isVertical",
          value: function () {
            return "block" === this.$tabs.css("display") || "column" === this.$element.css("flex-direction");
          }
        }, {
          key: "_isRtl",
          value: function () {
            return this.$element.hasClass("align-right") || Object(a.rtl)() && !this.$element.hasClass("align-left");
          }
        }, {
          key: "_events",
          value: function () {
            var f = this,
                s = "ontouchstart" in window || void 0 !== window.ontouchstart,
                r = "is-dropdown-submenu-parent";
            (this.options.clickOpen || s) && this.$menuItems.on("click.zf.dropdownMenu touchstart.zf.dropdownMenu", function (t) {
              var e = d()(t.target).parentsUntil("ul", ".".concat(r)),
                  n = e.hasClass(r),
                  i = "true" === e.attr("data-is-click"),
                  o = e.children(".is-dropdown-submenu");
              n && (i ? !f.options.closeOnClick || !f.options.clickOpen && !s || f.options.forceFollow && s || (t.stopImmediatePropagation(), t.preventDefault(), f._hide(e)) : (t.stopImmediatePropagation(), t.preventDefault(), f._show(o), e.add(e.parentsUntil(f.$element, ".".concat(r))).attr("data-is-click", !0)));
            }), f.options.closeOnClickInside && this.$menuItems.on("click.zf.dropdownMenu", function (t) {
              d()(this).hasClass(r) || f._hide();
            }), s && this.options.disableHoverOnTouch && (this.options.disableHover = !0), this.options.disableHover || this.$menuItems.on("mouseenter.zf.dropdownMenu", function (t) {
              var e = d()(this);
              e.hasClass(r) && (clearTimeout(e.data("_delay")), e.data("_delay", setTimeout(function () {
                f._show(e.children(".is-dropdown-submenu"));
              }, f.options.hoverDelay)));
            }).on("mouseleave.zf.dropdownMenu", Object(a.ignoreMousedisappear)(function (t) {
              var e = d()(this);

              if (e.hasClass(r) && f.options.autoclose) {
                if ("true" === e.attr("data-is-click") && f.options.clickOpen) return !1;
                clearTimeout(e.data("_delay")), e.data("_delay", setTimeout(function () {
                  f._hide(e);
                }, f.options.closingTime));
              }
            })), this.$menuItems.on("keydown.zf.dropdownMenu", function (e) {
              var n,
                  i,
                  o = d()(e.target).parentsUntil("ul", '[role="none"]'),
                  t = -1 < f.$tabs.index(o),
                  s = t ? f.$tabs : o.siblings("li").add(o);
              s.each(function (t) {
                d()(this).is(o) && (n = s.eq(t - 1), i = s.eq(t + 1));
              });

              function r() {
                i.children("a:first").focus(), e.preventDefault();
              }

              function a() {
                n.children("a:first").focus(), e.preventDefault();
              }

              function l() {
                var t = o.children("ul.is-dropdown-submenu");
                t.length && (f._show(t), o.find("li > a:first").focus(), e.preventDefault());
              }

              function u() {
                var t = o.parent("ul").parent("li");
                t.children("a:first").focus(), f._hide(t), e.preventDefault();
              }

              var c = {
                open: l,
                close: function () {
                  f._hide(f.$element), f.$menuItems.eq(0).children("a").focus(), e.preventDefault();
                }
              };
              t ? f._isVertical() ? f._isRtl() ? d.a.extend(c, {
                down: r,
                up: a,
                next: u,
                previous: l
              }) : d.a.extend(c, {
                down: r,
                up: a,
                next: l,
                previous: u
              }) : f._isRtl() ? d.a.extend(c, {
                next: a,
                previous: r,
                down: l,
                up: u
              }) : d.a.extend(c, {
                next: r,
                previous: a,
                down: l,
                up: u
              }) : f._isRtl() ? d.a.extend(c, {
                next: u,
                previous: l,
                down: r,
                up: a
              }) : d.a.extend(c, {
                next: l,
                previous: u,
                down: r,
                up: a
              }), h.Keyboard.handleKey(e, "DropdownMenu", c);
            });
          }
        }, {
          key: "_addBodyHandler",
          value: function () {
            var e = this,
                t = d()(document.body);
            this._removeBodyHandler(), t.on("click.zf.dropdownMenu tap.zf.dropdownMenu", function (t) {
              !d()(t.target).closest(e.$element).length && (e._hide(), e._removeBodyHandler());
            });
          }
        }, {
          key: "_removeBodyHandler",
          value: function () {
            d()(document.body).off("click.zf.dropdownMenu tap.zf.dropdownMenu");
          }
        }, {
          key: "_show",
          value: function (n) {
            var t = this.$tabs.index(this.$tabs.filter(function (t, e) {
              return 0 < d()(e).find(n).length;
            })),
                e = n.parent("li.is-dropdown-submenu-parent").siblings("li.is-dropdown-submenu-parent");
            this._hide(e, t), n.css("visibility", "hidden").addClass("js-dropdown-active").parent("li.is-dropdown-submenu-parent").addClass("is-active"), l.Box.ImNotTouchingYou(n, null, !0) || (e = "left" === this.options.alignment ? "-right" : "-left", (t = n.parent(".is-dropdown-submenu-parent")).removeClass("opens".concat(e)).addClass("opens-".concat(this.options.alignment)), l.Box.ImNotTouchingYou(n, null, !0) || t.removeClass("opens-".concat(this.options.alignment)).addClass("opens-inner"), this.changed = !0), n.css("visibility", ""), this.options.closeOnClick && this._addBodyHandler(), this.$element.trigger("show.zf.dropdownMenu", [n]);
          }
        }, {
          key: "_hide",
          value: function (t, n) {
            var e,
                i = t && t.length ? t : void 0 !== n ? this.$tabs.not(function (t, e) {
              return t === n;
            }) : this.$element;
            (i.hasClass("is-active") || 0 < i.find(".is-active").length) && ((e = i.find("li.is-active")).add(i).attr({
              "data-is-click": !1
            }).removeClass("is-active"), i.find("ul.js-dropdown-active").removeClass("js-dropdown-active"), (this.changed || i.find("opens-inner").length) && (t = "left" === this.options.alignment ? "right" : "left", i.find("li.is-dropdown-submenu-parent").add(i).removeClass("opens-inner opens-".concat(this.options.alignment)).addClass("opens-".concat(t)), this.changed = !1), clearTimeout(e.data("_delay")), this._removeBodyHandler(), this.$element.trigger("hide.zf.dropdownMenu", [i]));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$menuItems.off(".zf.dropdownMenu").removeAttr("data-is-click").removeClass("is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner"), d()(document.body).off(".zf.dropdownMenu"), r.Nest.Burn(this.$element, "dropdown");
          }
        }]) && c(t.prototype, e), n && c(t, n), o;
      }();

      i.defaults = {
        disableHover: !1,
        disableHoverOnTouch: !0,
        autoclose: !0,
        hoverDelay: 50,
        clickOpen: !1,
        closingTime: 500,
        alignment: "auto",
        closeOnClick: !0,
        closeOnClickInside: !0,
        verticalClass: "vertical",
        rightClass: "align-right",
        forceFollow: !0
      };
    },
    "./js/foundation.equalizer.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Equalizer", function () {
        return i;
      });
      var e = n("jquery"),
          c = n.n(e),
          s = n("./js/foundation.util.mediaQuery.js"),
          r = n("./js/foundation.util.imageLoader.js"),
          a = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.core.plugin.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, l["Plugin"]);
        var t,
            e,
            n,
            i = d(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = c.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Equalizer", this._init();
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element.attr("data-equalizer") || "",
                e = this.$element.find('[data-equalizer-watch="'.concat(t, '"]'));
            s.MediaQuery._init(), this.$watched = e.length ? e : this.$element.find("[data-equalizer-watch]"), this.$element.attr("data-resize", t || Object(a.GetYoDigits)(6, "eq")), this.$element.attr("data-mutate", t || Object(a.GetYoDigits)(6, "eq")), this.hasNested = 0 < this.$element.find("[data-equalizer]").length, this.isNested = 0 < this.$element.parentsUntil(document.body, "[data-equalizer]").length, this.isOn = !1, this._bindHandler = {
              onResizeMeBound: this._onResizeMe.bind(this),
              onPostEqualizedBound: this._onPostEqualized.bind(this)
            };
            var n,
                t = this.$element.find("img");
            this.options.equalizeOn ? (n = this._checkMQ(), c()(window).on("changed.zf.mediaquery", this._checkMQ.bind(this))) : this._events(), (void 0 !== n && !1 === n || void 0 === n) && (t.length ? Object(r.onImagesLoaded)(t, this._reflow.bind(this)) : this._reflow());
          }
        }, {
          key: "_pauseEvents",
          value: function () {
            this.isOn = !1, this.$element.off({
              ".zf.equalizer": this._bindHandler.onPostEqualizedBound,
              "resizeme.zf.trigger": this._bindHandler.onResizeMeBound,
              "mutateme.zf.trigger": this._bindHandler.onResizeMeBound
            });
          }
        }, {
          key: "_onResizeMe",
          value: function (t) {
            this._reflow();
          }
        }, {
          key: "_onPostEqualized",
          value: function (t) {
            t.target !== this.$element[0] && this._reflow();
          }
        }, {
          key: "_events",
          value: function () {
            this._pauseEvents(), this.hasNested ? this.$element.on("postequalized.zf.equalizer", this._bindHandler.onPostEqualizedBound) : (this.$element.on("resizeme.zf.trigger", this._bindHandler.onResizeMeBound), this.$element.on("mutateme.zf.trigger", this._bindHandler.onResizeMeBound)), this.isOn = !0;
          }
        }, {
          key: "_checkMQ",
          value: function () {
            var t = !s.MediaQuery.is(this.options.equalizeOn);
            return t ? this.isOn && (this._pauseEvents(), this.$watched.css("height", "auto")) : this.isOn || this._events(), t;
          }
        }, {
          key: "_killswitch",
          value: function () {}
        }, {
          key: "_reflow",
          value: function () {
            if (!this.options.equalizeOnStack && this._isStacked()) return this.$watched.css("height", "auto"), !1;
            this.options.equalizeByRow ? this.getHeightsByRow(this.applyHeightByRow.bind(this)) : this.getHeights(this.applyHeight.bind(this));
          }
        }, {
          key: "_isStacked",
          value: function () {
            return !this.$watched[0] || !this.$watched[1] || this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;
          }
        }, {
          key: "getHeights",
          value: function (t) {
            for (var e = [], n = 0, i = this.$watched.length; n < i; n++) this.$watched[n].style.height = "auto", e.push(this.$watched[n].offsetHeight);

            t(e);
          }
        }, {
          key: "getHeightsByRow",
          value: function (t) {
            var e = this.$watched.length ? this.$watched.first().offset().top : 0,
                n = [],
                i = 0;
            n[i] = [];

            for (var o = 0, s = this.$watched.length; o < s; o++) {
              this.$watched[o].style.height = "auto";
              var r = c()(this.$watched[o]).offset().top;
              r != e && (n[++i] = [], e = r), n[i].push([this.$watched[o], this.$watched[o].offsetHeight]);
            }

            for (var a = 0, l = n.length; a < l; a++) {
              var u = c()(n[a]).map(function () {
                return this[1];
              }).get(),
                  u = Math.max.apply(null, u);
              n[a].push(u);
            }

            t(n);
          }
        }, {
          key: "applyHeight",
          value: function (t) {
            t = Math.max.apply(null, t);
            this.$element.trigger("preequalized.zf.equalizer"), this.$watched.css("height", t), this.$element.trigger("postequalized.zf.equalizer");
          }
        }, {
          key: "applyHeightByRow",
          value: function (t) {
            this.$element.trigger("preequalized.zf.equalizer");

            for (var e = 0, n = t.length; e < n; e++) {
              var i = t[e].length,
                  o = t[e][i - 1];
              if (i <= 2) c()(t[e][0][0]).css({
                height: "auto"
              });else {
                this.$element.trigger("preequalizedrow.zf.equalizer");

                for (var s = 0, r = i - 1; s < r; s++) c()(t[e][s][0]).css({
                  height: o
                });

                this.$element.trigger("postequalizedrow.zf.equalizer");
              }
            }

            this.$element.trigger("postequalized.zf.equalizer");
          }
        }, {
          key: "_destroy",
          value: function () {
            this._pauseEvents(), this.$watched.css("height", "auto");
          }
        }]) && u(t.prototype, e), n && u(t, n), o;
      }();

      i.defaults = {
        equalizeOnStack: !1,
        equalizeByRow: !1,
        equalizeOn: ""
      };
    },
    "./js/foundation.interchange.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Interchange", function () {
        return i;
      });
      var e = n("jquery"),
          o = n.n(e),
          s = n("./js/foundation.util.mediaQuery.js"),
          a = n("./js/foundation.core.plugin.js"),
          l = n("./js/foundation.core.utils.js"),
          u = n("./js/foundation.util.triggers.js");

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(n);
          return function (t, e) {
            {
              if (e && ("object" === r(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(r, a["Plugin"]);
        var t,
            e,
            n,
            i = d(r);

        function r() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, r), i.apply(this, arguments);
        }

        return t = r, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = o.a.extend({}, r.defaults, this.$element.data(), e), this.rules = [], this.currentPath = "", this.className = "Interchange", u.Triggers.init(o.a), this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            s.MediaQuery._init();

            var t = this.$element[0].id || Object(l.GetYoDigits)(6, "interchange");
            this.$element.attr({
              "data-resize": t,
              id: t
            }), this._parseOptions(), this._addBreakpoints(), this._generateRules(), this._reflow();
          }
        }, {
          key: "_events",
          value: function () {
            var t = this;
            this.$element.off("resizeme.zf.trigger").on("resizeme.zf.trigger", function () {
              return t._reflow();
            });
          }
        }, {
          key: "_reflow",
          value: function () {
            var t, e, n;

            for (e in this.rules) this.rules.hasOwnProperty(e) && (n = this.rules[e], window.matchMedia(n.query).matches && (t = n));

            t && this.replace(t.path);
          }
        }, {
          key: "_parseOptions",
          value: function () {
            void 0 === this.options.type ? this.options.type = "auto" : -1 === ["auto", "src", "background", "html"].indexOf(this.options.type) && (console.log('Warning: invalid value "'.concat(this.options.type, '" for Interchange option "type"')), this.options.type = "auto");
          }
        }, {
          key: "_addBreakpoints",
          value: function () {
            for (var t in s.MediaQuery.queries) s.MediaQuery.queries.hasOwnProperty(t) && (t = s.MediaQuery.queries[t], r.SPECIAL_QUERIES[t.name] = t.value);
          }
        }, {
          key: "_generateRules",
          value: function (t) {
            var e,
                n,
                i,
                o = [],
                s = this.options.rules || this.$element.data("interchange");

            for (e in s = "string" == typeof s ? s.match(/\[.*?, .*?\]/g) : s) s.hasOwnProperty(e) && (n = (i = s[e].slice(1, -1).split(", ")).slice(0, -1).join(""), i = i[i.length - 1], r.SPECIAL_QUERIES[i] && (i = r.SPECIAL_QUERIES[i]), o.push({
              path: n,
              query: i
            }));

            this.rules = o;
          }
        }, {
          key: "replace",
          value: function (e) {
            var n,
                t,
                i = this;
            this.currentPath !== e && (n = "replaced.zf.interchange", "src" === (t = "auto" === (t = this.options.type) ? "IMG" === this.$element[0].nodeName ? "src" : e.match(/\.(gif|jpe?g|png|svg|tiff)([?#].*)?/i) ? "background" : "html" : t) ? this.$element.attr("src", e).on("load", function () {
              i.currentPath = e;
            }).trigger(n) : "background" === t ? (e = e.replace(/\(/g, "%28").replace(/\)/g, "%29"), this.$element.css({
              "background-image": "url(" + e + ")"
            }).trigger(n)) : "html" === t && o.a.get(e, function (t) {
              i.$element.html(t).trigger(n), o()(t).foundation(), i.currentPath = e;
            }));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off("resizeme.zf.trigger");
          }
        }]) && c(t.prototype, e), n && c(t, n), r;
      }();

      i.defaults = {
        rules: null,
        type: "auto"
      }, i.SPECIAL_QUERIES = {
        landscape: "screen and (orientation: landscape)",
        portrait: "screen and (orientation: portrait)",
        retina: "only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)"
      };
    },
    "./js/foundation.magellan.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Magellan", function () {
        return i;
      });
      var e = n("jquery"),
          a = n.n(e),
          s = n("./js/foundation.core.plugin.js"),
          r = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.smoothScroll.js"),
          u = n("./js/foundation.util.triggers.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = d(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = a.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Magellan", u.Triggers.init(a.a), this._init(), this.calcPoints();
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element[0].id || Object(r.GetYoDigits)(6, "magellan");
            this.$targets = a()("[data-magellan-target]"), this.$links = this.$element.find("a"), this.$element.attr({
              "data-resize": t,
              "data-scroll": t,
              id: t
            }), this.$active = a()(), this.scrollPos = parseInt(window.pageYOffset, 10), this._events();
          }
        }, {
          key: "calcPoints",
          value: function () {
            var n = this,
                t = document.body,
                e = document.documentElement;
            this.points = [], this.winHeight = Math.round(Math.max(window.innerHeight, e.clientHeight)), this.docHeight = Math.round(Math.max(t.scrollHeight, t.offsetHeight, e.clientHeight, e.scrollHeight, e.offsetHeight)), this.$targets.each(function () {
              var t = a()(this),
                  e = Math.round(t.offset().top - n.options.threshold);
              t.targetPoint = e, n.points.push(e);
            });
          }
        }, {
          key: "_events",
          value: function () {
            var e = this;
            a()(window).one("load", function () {
              e.options.deepLinking && location.hash && e.scrollToLoc(location.hash), e.calcPoints(), e._updateActive();
            }), e.onLoadListener = Object(r.onLoad)(a()(window), function () {
              e.$element.on({
                "resizeme.zf.trigger": e.reflow.bind(e),
                "scrollme.zf.trigger": e._updateActive.bind(e)
              }).on("click.zf.magellan", 'a[href^="#"]', function (t) {
                t.preventDefault();
                t = this.getAttribute("href");
                e.scrollToLoc(t);
              });
            }), this._deepLinkScroll = function (t) {
              e.options.deepLinking && e.scrollToLoc(window.location.hash);
            }, a()(window).on("hashchange", this._deepLinkScroll);
          }
        }, {
          key: "scrollToLoc",
          value: function (t) {
            this._inTransition = !0;
            var e = this,
                n = {
              animationEasing: this.options.animationEasing,
              animationDuration: this.options.animationDuration,
              threshold: this.options.threshold,
              offset: this.options.offset
            };
            l.SmoothScroll.scrollToLoc(t, n, function () {
              e._inTransition = !1;
            });
          }
        }, {
          key: "reflow",
          value: function () {
            this.calcPoints(), this._updateActive();
          }
        }, {
          key: "_updateActive",
          value: function () {
            var n,
                i,
                t,
                e,
                o,
                s,
                r = this;
            this._inTransition || (n = parseInt(window.pageYOffset, 10), i = this.scrollPos > n, (this.scrollPos = n) < this.points[0] - this.options.offset - (i ? this.options.threshold : 0) || (s = n + this.winHeight === this.docHeight ? this.points.length - 1 : (o = this.points.filter(function (t, e) {
              return t - r.options.offset - (i ? r.options.threshold : 0) <= n;
            })).length ? o.length - 1 : 0), t = this.$active, e = "", void 0 !== s ? (this.$active = this.$links.filter('[href="#' + this.$targets.eq(s).data("magellan-target") + '"]'), this.$active.length && (e = this.$active[0].getAttribute("href"))) : this.$active = a()(), o = !(!this.$active.length && !t.length || this.$active.is(t)), s = e !== window.location.hash, o && (t.removeClass(this.options.activeClass), this.$active.addClass(this.options.activeClass)), this.options.deepLinking && s && (window.history.pushState ? (s = e || window.location.pathname + window.location.search, this.options.updateHistory ? window.history.pushState({}, "", s) : window.history.replaceState({}, "", s)) : window.location.hash = e), o && this.$element.trigger("update.zf.magellan", [this.$active]));
          }
        }, {
          key: "_destroy",
          value: function () {
            var t;
            this.$element.off(".zf.trigger .zf.magellan").find(".".concat(this.options.activeClass)).removeClass(this.options.activeClass), this.options.deepLinking && (t = this.$active[0].getAttribute("href"), window.location.hash.replace(t, "")), a()(window).off("hashchange", this._deepLinkScroll), this.onLoadListener && a()(window).off(this.onLoadListener);
          }
        }]) && c(t.prototype, e), n && c(t, n), o;
      }();

      i.defaults = {
        animationDuration: 500,
        animationEasing: "linear",
        threshold: 50,
        activeClass: "is-active",
        deepLinking: !1,
        updateHistory: !1,
        offset: 0
      };
    },
    "./js/foundation.offcanvas.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "OffCanvas", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.core.plugin.js"),
          a = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.util.keyboard.js"),
          u = n("./js/foundation.util.mediaQuery.js"),
          c = n("./js/foundation.util.triggers.js");

      function f(t) {
        return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function d(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function h(t, e) {
        return (h = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function p(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = o(n);
          return function (t, e) {
            {
              if (e && ("object" === f(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = o(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function o(t) {
        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && h(t, e);
        }(o, r["Plugin"]);
        var t,
            e,
            n,
            i = p(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            var n = this;
            this.className = "OffCanvas", this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.contentClasses = {
              base: [],
              reveal: []
            }, this.$lastTrigger = s()(), this.$triggers = s()(), this.position = "left", this.$content = s()(), this.nested = !!this.options.nested, this.$sticky = s()(), this.isInCanvas = !1, s()(["push", "overlap"]).each(function (t, e) {
              n.contentClasses.base.push("has-transition-" + e);
            }), s()(["left", "right", "top", "bottom"]).each(function (t, e) {
              n.contentClasses.base.push("has-position-" + e), n.contentClasses.reveal.push("has-reveal-" + e);
            }), c.Triggers.init(s.a), u.MediaQuery._init(), this._init(), this._events(), l.Keyboard.register("OffCanvas", {
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element.attr("id");
            this.$element.attr("aria-hidden", "true"), this.options.contentId ? this.$content = s()("#" + this.options.contentId) : this.$element.siblings("[data-off-canvas-content]").length ? this.$content = this.$element.siblings("[data-off-canvas-content]").first() : this.$content = this.$element.closest("[data-off-canvas-content]").first(), this.options.contentId ? this.options.contentId && null === this.options.nested && console.warn("Remember to use the nested option if using the content ID option!") : this.nested = 0 === this.$element.siblings("[data-off-canvas-content]").length, !0 === this.nested && (this.options.transition = "overlap", this.$element.removeClass("is-transition-push")), this.$element.addClass("is-transition-".concat(this.options.transition, " is-closed")), this.$triggers = s()(document).find('[data-open="' + t + '"], [data-close="' + t + '"], [data-toggle="' + t + '"]').attr("aria-expanded", "false").attr("aria-controls", t), this.position = this.$element.is(".position-left, .position-top, .position-right, .position-bottom") ? this.$element.attr("class").match(/position\-(left|top|right|bottom)/)[1] : this.position, !0 === this.options.contentOverlay && (t = document.createElement("div"), e = "fixed" === s()(this.$element).css("position") ? "is-overlay-fixed" : "is-overlay-absolute", t.setAttribute("class", "js-off-canvas-overlay " + e), this.$overlay = s()(t), "is-overlay-fixed" == e ? s()(this.$overlay).insertAfter(this.$element) : this.$content.append(this.$overlay));
            var e = new RegExp(Object(a.RegExpEscape)(this.options.revealClass) + "([^\\s]+)", "g").exec(this.$element[0].className);
            e && (this.options.isRevealed = !0, this.options.revealOn = this.options.revealOn || e[1]), !0 === this.options.isRevealed && this.options.revealOn && (this.$element.first().addClass("".concat(this.options.revealClass).concat(this.options.revealOn)), this._setMQChecker()), this.options.transitionTime && this.$element.css("transition-duration", this.options.transitionTime), this.$sticky = this.$content.find("[data-off-canvas-sticky]"), 0 < this.$sticky.length && "push" === this.options.transition && (this.options.contentScroll = !1);
            e = this.$element.attr("class").match(/\bin-canvas-for-(\w+)/);
            e && 2 === e.length ? this.options.inCanvasOn = e[1] : this.options.inCanvasOn && this.$element.addClass("in-canvas-for-".concat(this.options.inCanvasOn)), this.options.inCanvasOn && this._checkInCanvas(), this._removeContentClasses();
          }
        }, {
          key: "_events",
          value: function () {
            var t = this;
            this.$element.off(".zf.trigger .zf.offCanvas").on({
              "open.zf.trigger": this.open.bind(this),
              "close.zf.trigger": this.close.bind(this),
              "toggle.zf.trigger": this.toggle.bind(this),
              "keydown.zf.offCanvas": this._handleKeyboard.bind(this)
            }), !0 === this.options.closeOnClick && (this.options.contentOverlay ? this.$overlay : this.$content).on({
              "click.zf.offCanvas": this.close.bind(this)
            }), this.options.inCanvasOn && s()(window).on("changed.zf.mediaquery", function () {
              t._checkInCanvas();
            });
          }
        }, {
          key: "_setMQChecker",
          value: function () {
            var t = this;
            this.onLoadListener = Object(a.onLoad)(s()(window), function () {
              u.MediaQuery.atLeast(t.options.revealOn) && t.reveal(!0);
            }), s()(window).on("changed.zf.mediaquery", function () {
              u.MediaQuery.atLeast(t.options.revealOn) ? t.reveal(!0) : t.reveal(!1);
            });
          }
        }, {
          key: "_checkInCanvas",
          value: function () {
            this.isInCanvas = u.MediaQuery.atLeast(this.options.inCanvasOn), !0 === this.isInCanvas && this.close();
          }
        }, {
          key: "_removeContentClasses",
          value: function (t) {
            "boolean" != typeof t ? this.$content.removeClass(this.contentClasses.base.join(" ")) : !1 === t && this.$content.removeClass("has-reveal-".concat(this.position));
          }
        }, {
          key: "_addContentClasses",
          value: function (t) {
            this._removeContentClasses(t), "boolean" != typeof t ? this.$content.addClass("has-transition-".concat(this.options.transition, " has-position-").concat(this.position)) : !0 === t && this.$content.addClass("has-reveal-".concat(this.position));
          }
        }, {
          key: "_fixStickyElements",
          value: function () {
            this.$sticky.each(function (t, e) {
              var n = s()(e);
              "fixed" === n.css("position") && (e = parseInt(n.css("top"), 10), n.data("offCanvasSticky", {
                top: e
              }), e = s()(document).scrollTop() + e, n.css({
                top: "".concat(e, "px"),
                width: "100%",
                transition: "none"
              }));
            });
          }
        }, {
          key: "_unfixStickyElements",
          value: function () {
            this.$sticky.each(function (t, e) {
              var n = s()(e),
                  e = n.data("offCanvasSticky");
              "object" === f(e) && (n.css({
                top: "".concat(e.top, "px"),
                width: "",
                transition: ""
              }), n.data("offCanvasSticky", ""));
            });
          }
        }, {
          key: "reveal",
          value: function (t) {
            t ? (this.close(), this.isRevealed = !0, this.$element.attr("aria-hidden", "false"), this.$element.off("open.zf.trigger toggle.zf.trigger"), this.$element.removeClass("is-closed")) : (this.isRevealed = !1, this.$element.attr("aria-hidden", "true"), this.$element.off("open.zf.trigger toggle.zf.trigger").on({
              "open.zf.trigger": this.open.bind(this),
              "toggle.zf.trigger": this.toggle.bind(this)
            }), this.$element.addClass("is-closed")), this._addContentClasses(t);
          }
        }, {
          key: "_stopScrolling",
          value: function (t) {
            return !1;
          }
        }, {
          key: "_recordScrollable",
          value: function (t) {
            this.lastY = t.touches[0].pageY;
          }
        }, {
          key: "_preventDefaultAtEdges",
          value: function (t) {
            var e = t.data,
                n = this.lastY - t.touches[0].pageY;
            this.lastY = t.touches[0].pageY, e._canScroll(n, this) || t.preventDefault();
          }
        }, {
          key: "_scrollboxTouchMoved",
          value: function (t) {
            var e = t.data,
                n = this.closest("[data-off-canvas], [data-off-canvas-scrollbox-outer]"),
                i = this.lastY - t.touches[0].pageY;
            n.lastY = this.lastY = t.touches[0].pageY, t.stopPropagation(), e._canScroll(i, this) || (e._canScroll(i, n) ? n.scrollTop += i : t.preventDefault());
          }
        }, {
          key: "_canScroll",
          value: function (t, e) {
            var n = 0 < e.scrollTop,
                e = e.scrollTop < e.scrollHeight - e.clientHeight;
            return t < 0 && n || 0 < t && e;
          }
        }, {
          key: "open",
          value: function (t, e) {
            var n,
                i = this;
            this.$element.hasClass("is-open") || this.isRevealed || this.isInCanvas || (n = this, e && (this.$lastTrigger = e), "top" === this.options.forceTo ? window.scrollTo(0, 0) : "bottom" === this.options.forceTo && window.scrollTo(0, document.body.scrollHeight), this.options.transitionTime && "overlap" !== this.options.transition ? this.$element.siblings("[data-off-canvas-content]").css("transition-duration", this.options.transitionTime) : this.$element.siblings("[data-off-canvas-content]").css("transition-duration", ""), this.$element.addClass("is-open").removeClass("is-closed"), this.$triggers.attr("aria-expanded", "true"), this.$element.attr("aria-hidden", "false"), this.$content.addClass("is-open-" + this.position), !1 === this.options.contentScroll && (s()("body").addClass("is-off-canvas-open").on("touchmove", this._stopScrolling), this.$element.on("touchstart", this._recordScrollable), this.$element.on("touchmove", this, this._preventDefaultAtEdges), this.$element.on("touchstart", "[data-off-canvas-scrollbox]", this._recordScrollable), this.$element.on("touchmove", "[data-off-canvas-scrollbox]", this, this._scrollboxTouchMoved)), !0 === this.options.contentOverlay && this.$overlay.addClass("is-visible"), !0 === this.options.closeOnClick && !0 === this.options.contentOverlay && this.$overlay.addClass("is-closable"), !0 === this.options.autoFocus && this.$element.one(Object(a.transitionend)(this.$element), function () {
              var t;
              n.$element.hasClass("is-open") && ((t = n.$element.find("[data-autofocus]")).length ? t : n.$element.find("a, button")).eq(0).focus();
            }), !0 === this.options.trapFocus && (this.$content.attr("tabindex", "-1"), l.Keyboard.trapFocus(this.$element)), "push" === this.options.transition && this._fixStickyElements(), this._addContentClasses(), this.$element.trigger("opened.zf.offCanvas"), this.$element.one(Object(a.transitionend)(this.$element), function () {
              i.$element.trigger("openedEnd.zf.offCanvas");
            }));
          }
        }, {
          key: "close",
          value: function (t) {
            var e = this;
            this.$element.hasClass("is-open") && !this.isRevealed && (this.$element.trigger("close.zf.offCanvas"), this.$element.removeClass("is-open"), this.$element.attr("aria-hidden", "true"), this.$content.removeClass("is-open-left is-open-top is-open-right is-open-bottom"), !0 === this.options.contentOverlay && this.$overlay.removeClass("is-visible"), !0 === this.options.closeOnClick && !0 === this.options.contentOverlay && this.$overlay.removeClass("is-closable"), this.$triggers.attr("aria-expanded", "false"), this.$element.one(Object(a.transitionend)(this.$element), function (t) {
              e.$element.addClass("is-closed"), e._removeContentClasses(), "push" === e.options.transition && e._unfixStickyElements(), !1 === e.options.contentScroll && (s()("body").removeClass("is-off-canvas-open").off("touchmove", e._stopScrolling), e.$element.off("touchstart", e._recordScrollable), e.$element.off("touchmove", e._preventDefaultAtEdges), e.$element.off("touchstart", "[data-off-canvas-scrollbox]", e._recordScrollable), e.$element.off("touchmove", "[data-off-canvas-scrollbox]", e._scrollboxTouchMoved)), !0 === e.options.trapFocus && (e.$content.removeAttr("tabindex"), l.Keyboard.releaseFocus(e.$element)), e.$element.trigger("closed.zf.offCanvas");
            }));
          }
        }, {
          key: "toggle",
          value: function (t, e) {
            this.$element.hasClass("is-open") ? this.close(t, e) : this.open(t, e);
          }
        }, {
          key: "_handleKeyboard",
          value: function (t) {
            var e = this;
            l.Keyboard.handleKey(t, "OffCanvas", {
              close: function () {
                return e.close(), e.$lastTrigger.focus(), !0;
              },
              handled: function () {
                t.preventDefault();
              }
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.close(), this.$element.off(".zf.trigger .zf.offCanvas"), this.$overlay.off(".zf.offCanvas"), this.onLoadListener && s()(window).off(this.onLoadListener);
          }
        }]) && d(t.prototype, e), n && d(t, n), o;
      }();

      i.defaults = {
        closeOnClick: !0,
        contentOverlay: !0,
        contentId: null,
        nested: null,
        contentScroll: !0,
        transitionTime: null,
        transition: "push",
        forceTo: null,
        isRevealed: !1,
        revealOn: null,
        inCanvasOn: null,
        autoFocus: !0,
        revealClass: "reveal-for-",
        trapFocus: !1
      };
    },
    "./js/foundation.orbit.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Orbit", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.util.keyboard.js"),
          c = n("./js/foundation.util.motion.js"),
          a = n("./js/foundation.util.timer.js"),
          l = n("./js/foundation.util.imageLoader.js"),
          u = n("./js/foundation.core.utils.js"),
          f = n("./js/foundation.core.plugin.js"),
          d = n("./js/foundation.util.touch.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function h(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function p(t, e) {
        return (p = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function m(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = v(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = v(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function v(t) {
        return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && p(t, e);
        }(o, f["Plugin"]);
        var t,
            e,
            n,
            i = m(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Orbit", d.Touch.init(s.a), this._init(), r.Keyboard.register("Orbit", {
              ltr: {
                ARROW_RIGHT: "next",
                ARROW_LEFT: "previous"
              },
              rtl: {
                ARROW_LEFT: "next",
                ARROW_RIGHT: "previous"
              }
            });
          }
        }, {
          key: "_init",
          value: function () {
            this._reset(), this.$wrapper = this.$element.find(".".concat(this.options.containerClass)), this.$slides = this.$element.find(".".concat(this.options.slideClass));
            var t = this.$element.find("img"),
                e = this.$slides.filter(".is-active"),
                n = this.$element[0].id || Object(u.GetYoDigits)(6, "orbit");
            this.$element.attr({
              "data-resize": n,
              id: n
            }), e.length || this.$slides.eq(0).addClass("is-active"), this.options.useMUI || this.$slides.addClass("no-motionui"), t.length ? Object(l.onImagesLoaded)(t, this._prepareForOrbit.bind(this)) : this._prepareForOrbit(), this.options.bullets && this._loadBullets(), this._events(), this.options.autoPlay && 1 < this.$slides.length && this.geoSync(), this.options.accessible && this.$wrapper.attr("tabindex", 0);
          }
        }, {
          key: "_loadBullets",
          value: function () {
            this.$bullets = this.$element.find(".".concat(this.options.boxOfBullets)).find("button");
          }
        }, {
          key: "geoSync",
          value: function () {
            var t = this;
            this.timer = new a.Timer(this.$element, {
              duration: this.options.timerDelay,
              infinite: !1
            }, function () {
              t.changeSlide(!0);
            }), this.timer.start();
          }
        }, {
          key: "_prepareForOrbit",
          value: function () {
            this._setWrapperHeight();
          }
        }, {
          key: "_setWrapperHeight",
          value: function (t) {
            var e,
                n = 0,
                i = 0,
                o = this;
            this.$slides.each(function () {
              e = this.getBoundingClientRect().height, s()(this).attr("data-slide", i), /mui/g.test(s()(this)[0].className) || o.$slides.filter(".is-active")[0] === o.$slides.eq(i)[0] || s()(this).css({
                display: "none"
              }), n = n < e ? e : n, i++;
            }), i === this.$slides.length && (this.$wrapper.css({
              height: n
            }), t && t(n));
          }
        }, {
          key: "_setSlideHeight",
          value: function (t) {
            this.$slides.each(function () {
              s()(this).css("max-height", t);
            });
          }
        }, {
          key: "_events",
          value: function () {
            var i = this;
            this.$element.off(".resizeme.zf.trigger").on({
              "resizeme.zf.trigger": this._prepareForOrbit.bind(this)
            }), 1 < this.$slides.length && (this.options.swipe && this.$slides.off("swipeleft.zf.orbit swiperight.zf.orbit").on("swipeleft.zf.orbit", function (t) {
              t.preventDefault(), i.changeSlide(!0);
            }).on("swiperight.zf.orbit", function (t) {
              t.preventDefault(), i.changeSlide(!1);
            }), this.options.autoPlay && (this.$slides.on("click.zf.orbit", function () {
              i.$element.data("clickedOn", !i.$element.data("clickedOn")), i.timer[i.$element.data("clickedOn") ? "pause" : "start"]();
            }), this.options.pauseOnHover && this.$element.on("mouseenter.zf.orbit", function () {
              i.timer.pause();
            }).on("mouseleave.zf.orbit", function () {
              i.$element.data("clickedOn") || i.timer.start();
            })), this.options.navButtons && this.$element.find(".".concat(this.options.nextClass, ", .").concat(this.options.prevClass)).attr("tabindex", 0).on("click.zf.orbit touchend.zf.orbit", function (t) {
              t.preventDefault(), i.changeSlide(s()(this).hasClass(i.options.nextClass));
            }), this.options.bullets && this.$bullets.on("click.zf.orbit touchend.zf.orbit", function () {
              if (/is-active/g.test(this.className)) return !1;
              var t = s()(this).data("slide"),
                  e = t > i.$slides.filter(".is-active").data("slide"),
                  n = i.$slides.eq(t);
              i.changeSlide(e, n, t);
            }), this.options.accessible && this.$wrapper.add(this.$bullets).on("keydown.zf.orbit", function (t) {
              r.Keyboard.handleKey(t, "Orbit", {
                next: function () {
                  i.changeSlide(!0);
                },
                previous: function () {
                  i.changeSlide(!1);
                },
                handled: function () {
                  s()(t.target).is(i.$bullets) && i.$bullets.filter(".is-active").focus();
                }
              });
            }));
          }
        }, {
          key: "_reset",
          value: function () {
            void 0 !== this.$slides && 1 < this.$slides.length && (this.$element.off(".zf.orbit").find("*").off(".zf.orbit"), this.options.autoPlay && this.timer.restart(), this.$slides.each(function (t) {
              s()(t).removeClass("is-active is-active is-in").removeAttr("aria-live").hide();
            }), this.$slides.first().addClass("is-active").show(), this.$element.trigger("slidechange.zf.orbit", [this.$slides.first()]), this.options.bullets && this._updateBullets(0));
          }
        }, {
          key: "changeSlide",
          value: function (t, e, n) {
            if (this.$slides) {
              var i = this.$slides.filter(".is-active").eq(0);
              if (/mui/g.test(i[0].className)) return !1;
              var o = this.$slides.first(),
                  s = this.$slides.last(),
                  r = t ? "Right" : "Left",
                  a = t ? "Left" : "Right",
                  l = this,
                  u = e || (t ? !this.options.infiniteWrap || i.next(".".concat(this.options.slideClass)).length ? i.next(".".concat(this.options.slideClass)) : o : !this.options.infiniteWrap || i.prev(".".concat(this.options.slideClass)).length ? i.prev(".".concat(this.options.slideClass)) : s);
              u.length && (this.$element.trigger("beforeslidechange.zf.orbit", [i, u]), this.options.bullets && (n = n || this.$slides.index(u), this._updateBullets(n)), this.options.useMUI && !this.$element.is(":hidden") ? (c.Motion.animateIn(u.addClass("is-active"), this.options["animInFrom".concat(r)], function () {
                u.css({
                  display: "block"
                }).attr("aria-live", "polite");
              }), c.Motion.animateOut(i.removeClass("is-active"), this.options["animOutTo".concat(a)], function () {
                i.removeAttr("aria-live"), l.options.autoPlay && !l.timer.isPaused && l.timer.restart();
              })) : (i.removeClass("is-active is-in").removeAttr("aria-live").hide(), u.addClass("is-active is-in").attr("aria-live", "polite").show(), this.options.autoPlay && !this.timer.isPaused && this.timer.restart()), this.$element.trigger("slidechange.zf.orbit", [u]));
            }
          }
        }, {
          key: "_updateBullets",
          value: function (t) {
            var e = this.$bullets.filter(".is-active"),
                n = this.$bullets.not(".is-active"),
                i = this.$bullets.eq(t);
            e.removeClass("is-active").blur(), i.addClass("is-active");
            var o,
                t = e.children("[data-slide-active-label]").last();
            t.length || (o = e.children("span"), n.toArray().map(function (t) {
              return s()(t).children("span").length;
            }).every(function (t) {
              return t < o.length;
            }) && (t = o.last()).attr("data-slide-active-label", "")), t.length && (t.detach(), i.append(t));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.orbit").find("*").off(".zf.orbit").end().hide();
          }
        }]) && h(t.prototype, e), n && h(t, n), o;
      }();

      i.defaults = {
        bullets: !0,
        navButtons: !0,
        animInFromRight: "slide-in-right",
        animOutToRight: "slide-out-right",
        animInFromLeft: "slide-in-left",
        animOutToLeft: "slide-out-left",
        autoPlay: !0,
        timerDelay: 5e3,
        infiniteWrap: !0,
        swipe: !0,
        pauseOnHover: !0,
        accessible: !0,
        containerClass: "orbit-container",
        slideClass: "orbit-slide",
        boxOfBullets: "orbit-bullets",
        nextClass: "orbit-next",
        prevClass: "orbit-previous",
        useMUI: !0
      };
    },
    "./js/foundation.positionable.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Positionable", function () {
        return i;
      });
      var r = n("./js/foundation.util.box.js"),
          s = n("./js/foundation.core.plugin.js"),
          a = n("./js/foundation.core.utils.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function l(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function u(t, e) {
        return (u = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function c(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = f(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = f(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function f(t) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var d = ["left", "right", "top", "bottom"],
          e = ["top", "bottom", "center"],
          n = ["left", "right", "center"],
          h = {
        left: e,
        right: e,
        top: n,
        bottom: n
      };

      function p(t, e) {
        t = e.indexOf(t);
        return t === e.length - 1 ? e[0] : e[t + 1];
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && u(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = c(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_init",
          value: function () {
            this.triedPositions = {}, this.position = "auto" === this.options.position ? this._getDefaultPosition() : this.options.position, this.alignment = "auto" === this.options.alignment ? this._getDefaultAlignment() : this.options.alignment, this.originalPosition = this.position, this.originalAlignment = this.alignment;
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            return "bottom";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            switch (this.position) {
              case "bottom":
              case "top":
                return Object(a.rtl)() ? "right" : "left";

              case "left":
              case "right":
                return "bottom";
            }
          }
        }, {
          key: "_reposition",
          value: function () {
            this._alignmentsExhausted(this.position) ? (this.position = p(this.position, d), this.alignment = h[this.position][0]) : this._realign();
          }
        }, {
          key: "_realign",
          value: function () {
            this._addTriedPosition(this.position, this.alignment), this.alignment = p(this.alignment, h[this.position]);
          }
        }, {
          key: "_addTriedPosition",
          value: function (t, e) {
            this.triedPositions[t] = this.triedPositions[t] || [], this.triedPositions[t].push(e);
          }
        }, {
          key: "_positionsExhausted",
          value: function () {
            for (var t = !0, e = 0; e < d.length; e++) t = t && this._alignmentsExhausted(d[e]);

            return t;
          }
        }, {
          key: "_alignmentsExhausted",
          value: function (t) {
            return this.triedPositions[t] && this.triedPositions[t].length == h[t].length;
          }
        }, {
          key: "_getVOffset",
          value: function () {
            return this.options.vOffset;
          }
        }, {
          key: "_getHOffset",
          value: function () {
            return this.options.hOffset;
          }
        }, {
          key: "_setPosition",
          value: function (t, e, n) {
            if ("false" === t.attr("aria-expanded")) return !1;

            if (this.options.allowOverlap || (this.position = this.originalPosition, this.alignment = this.originalAlignment), e.offset(r.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset())), !this.options.allowOverlap) {
              for (var i = 1e8, o = {
                position: this.position,
                alignment: this.alignment
              }; !this._positionsExhausted();) {
                var s = r.Box.OverlapArea(e, n, !1, !1, this.options.allowBottomOverlap);
                if (0 === s) return;
                s < i && (i = s, o = {
                  position: this.position,
                  alignment: this.alignment
                }), this._reposition(), e.offset(r.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
              }

              this.position = o.position, this.alignment = o.alignment, e.offset(r.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
            }
          }
        }]) && l(t.prototype, e), n && l(t, n), o;
      }();

      i.defaults = {
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !0,
        vOffset: 0,
        hOffset: 0
      };
    },
    "./js/foundation.responsiveAccordionTabs.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "ResponsiveAccordionTabs", function () {
        return m;
      });
      var e = n("jquery"),
          u = n.n(e),
          s = n("./js/foundation.util.mediaQuery.js"),
          c = n("./js/foundation.core.utils.js"),
          r = n("./js/foundation.core.plugin.js"),
          e = n("./js/foundation.accordion.js");

      function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function l(t, e) {
        return (l = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = o(n);
          return d(this, i ? (t = o(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t, e) {
        if (e && ("object" === i(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return h(t);
      }

      function h(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t;
      }

      function o(t) {
        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var p = {
        tabs: {
          cssClass: "tabs",
          plugin: n("./js/foundation.tabs.js").Tabs,
          open: function (t, e) {
            return t.selectTab(e);
          },
          close: null,
          toggle: null
        },
        accordion: {
          cssClass: "accordion",
          plugin: e.Accordion,
          open: function (t, e) {
            return t.down(u()(e));
          },
          close: function (t, e) {
            return t.up(u()(e));
          },
          toggle: function (t, e) {
            return t.toggle(u()(e));
          }
        }
      },
          m = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && l(t, e);
        }(o, r["Plugin"]);
        var t,
            e,
            n,
            i = f(o);

        function o(t, e) {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), d(e = i.call(this, t, e), e.options.reflow && e.storezfData || h(e));
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = u()(t), this.$element.data("zfPluginBase", this), this.options = u.a.extend({}, o.defaults, this.$element.data(), e), this.rules = this.$element.data("responsive-accordion-tabs"), this.currentMq = null, this.currentRule = null, this.currentPlugin = null, this.className = "ResponsiveAccordionTabs", this.$element.attr("id") || this.$element.attr("id", Object(c.GetYoDigits)(6, "responsiveaccordiontabs")), this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            if (s.MediaQuery._init(), "string" == typeof this.rules) {
              for (var t = {}, e = this.rules.split(" "), n = 0; n < e.length; n++) {
                var i = e[n].split("-"),
                    o = 1 < i.length ? i[0] : "small",
                    i = 1 < i.length ? i[1] : i[0];
                null !== p[i] && (t[o] = p[i]);
              }

              this.rules = t;
            }

            this._getAllOptions(), u.a.isEmptyObject(this.rules) || this._checkMediaQueries();
          }
        }, {
          key: "_getAllOptions",
          value: function () {
            for (var t in this.allOptions = {}, p) if (p.hasOwnProperty(t)) {
              var e = p[t];

              try {
                var n,
                    i,
                    o = u()("<ul></ul>"),
                    s = new e.plugin(o, this.options);

                for (n in s.options) s.options.hasOwnProperty(n) && "zfPlugin" !== n && (i = s.options[n], this.allOptions[n] = i);

                s.destroy();
              } catch (t) {}
            }
          }
        }, {
          key: "_events",
          value: function () {
            this._changedZfMediaQueryHandler = this._checkMediaQueries.bind(this), u()(window).on("changed.zf.mediaquery", this._changedZfMediaQueryHandler);
          }
        }, {
          key: "_checkMediaQueries",
          value: function () {
            var e,
                n = this;
            u.a.each(this.rules, function (t) {
              s.MediaQuery.atLeast(t) && (e = t);
            }), e && (this.currentPlugin instanceof this.rules[e].plugin || (u.a.each(p, function (t, e) {
              n.$element.removeClass(e.cssClass);
            }), this.$element.addClass(this.rules[e].cssClass), this.currentPlugin && (!this.currentPlugin.$element.data("zfPlugin") && this.storezfData && this.currentPlugin.$element.data("zfPlugin", this.storezfData), this.currentPlugin.destroy()), this._handleMarkup(this.rules[e].cssClass), this.currentRule = this.rules[e], this.currentPlugin = new this.currentRule.plugin(this.$element, this.options), this.storezfData = this.currentPlugin.$element.data("zfPlugin")));
          }
        }, {
          key: "_handleMarkup",
          value: function (t) {
            var e,
                s,
                r,
                a,
                l,
                n = this,
                i = "accordion",
                o = u()("[data-tabs-content=" + this.$element.attr("id") + "]");
            (i = o.length ? "tabs" : i) !== t && (e = n.allOptions.linkClass || "tabs-title", s = n.allOptions.panelClass || "tabs-panel", this.$element.removeAttr("role"), r = this.$element.children("." + e + ",[data-accordion-item]").removeClass(e).removeClass("accordion-item").removeAttr("data-accordion-item"), a = r.children("a").removeClass("accordion-title"), "tabs" === i ? (o = o.children("." + s).removeClass(s).removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby")).children("a").removeAttr("role").removeAttr("aria-controls").removeAttr("aria-selected") : o = r.children("[data-tab-content]").removeClass("accordion-content"), o.css({
              display: "",
              visibility: ""
            }), r.css({
              display: "",
              visibility: ""
            }), "accordion" === t ? o.each(function (t, e) {
              u()(e).appendTo(r.get(t)).addClass("accordion-content").attr("data-tab-content", "").removeClass("is-active").css({
                height: ""
              }), u()("[data-tabs-content=" + n.$element.attr("id") + "]").after('<div id="tabs-placeholder-' + n.$element.attr("id") + '"></div>').detach(), r.addClass("accordion-item").attr("data-accordion-item", ""), a.addClass("accordion-title");
            }) : "tabs" === t && (l = u()("[data-tabs-content=" + n.$element.attr("id") + "]"), (t = u()("#tabs-placeholder-" + n.$element.attr("id"))).length ? (l = u()('<div class="tabs-content"></div>').insertAfter(t).attr("data-tabs-content", n.$element.attr("id")), t.remove()) : l = u()('<div class="tabs-content"></div>').insertAfter(n.$element).attr("data-tabs-content", n.$element.attr("id")), o.each(function (t, e) {
              var n = u()(e).appendTo(l).addClass(s),
                  i = a.get(t).hash.slice(1),
                  o = u()(e).attr("id") || Object(c.GetYoDigits)(6, "accordion");
              i !== o && ("" !== i ? u()(e).attr("id", i) : (i = o, u()(e).attr("id", i), u()(a.get(t)).attr("href", u()(a.get(t)).attr("href").replace("#", "") + "#" + i))), u()(r.get(t)).hasClass("is-active") && n.addClass("is-active");
            }), r.addClass(e)));
          }
        }, {
          key: "open",
          value: function (t) {
            var e;
            if (this.currentRule && "function" == typeof this.currentRule.open) return (e = this.currentRule).open.apply(e, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
          }
        }, {
          key: "close",
          value: function (t) {
            var e;
            if (this.currentRule && "function" == typeof this.currentRule.close) return (e = this.currentRule).close.apply(e, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
          }
        }, {
          key: "toggle",
          value: function (t) {
            var e;
            if (this.currentRule && "function" == typeof this.currentRule.toggle) return (e = this.currentRule).toggle.apply(e, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.currentPlugin && this.currentPlugin.destroy(), u()(window).off("changed.zf.mediaquery", this._changedZfMediaQueryHandler);
          }
        }]) && a(t.prototype, e), n && a(t, n), o;
      }();

      m.defaults = {};
    },
    "./js/foundation.responsiveMenu.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "ResponsiveMenu", function () {
        return p;
      });
      var i = n("jquery"),
          s = n.n(i),
          r = n("./js/foundation.util.mediaQuery.js"),
          a = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.core.plugin.js"),
          e = n("./js/foundation.dropdownMenu.js"),
          i = n("./js/foundation.drilldown.js"),
          n = n("./js/foundation.accordionMenu.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function c(t, e) {
        return (c = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = d(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = d(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var h = {
        dropdown: {
          cssClass: "dropdown",
          plugin: e.DropdownMenu
        },
        drilldown: {
          cssClass: "drilldown",
          plugin: i.Drilldown
        },
        accordion: {
          cssClass: "accordion-menu",
          plugin: n.AccordionMenu
        }
      },
          p = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && c(t, e);
        }(o, l["Plugin"]);
        var t,
            e,
            n,
            i = f(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = s()(t), this.rules = this.$element.data("responsive-menu"), this.currentMq = null, this.currentPlugin = null, this.className = "ResponsiveMenu", this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            if (r.MediaQuery._init(), "string" == typeof this.rules) {
              for (var t = {}, e = this.rules.split(" "), n = 0; n < e.length; n++) {
                var i = e[n].split("-"),
                    o = 1 < i.length ? i[0] : "small",
                    i = 1 < i.length ? i[1] : i[0];
                null !== h[i] && (t[o] = h[i]);
              }

              this.rules = t;
            }

            s.a.isEmptyObject(this.rules) || this._checkMediaQueries(), this.$element.attr("data-mutate", this.$element.attr("data-mutate") || Object(a.GetYoDigits)(6, "responsive-menu"));
          }
        }, {
          key: "_events",
          value: function () {
            var t = this;
            s()(window).on("changed.zf.mediaquery", function () {
              t._checkMediaQueries();
            });
          }
        }, {
          key: "_checkMediaQueries",
          value: function () {
            var e,
                n = this;
            s.a.each(this.rules, function (t) {
              r.MediaQuery.atLeast(t) && (e = t);
            }), e && (this.currentPlugin instanceof this.rules[e].plugin || (s.a.each(h, function (t, e) {
              n.$element.removeClass(e.cssClass);
            }), this.$element.addClass(this.rules[e].cssClass), this.currentPlugin && this.currentPlugin.destroy(), this.currentPlugin = new this.rules[e].plugin(this.$element, {})));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.currentPlugin.destroy(), s()(window).off(".zf.ResponsiveMenu");
          }
        }]) && u(t.prototype, e), n && u(t, n), o;
      }();

      p.defaults = {};
    },
    "./js/foundation.responsiveToggle.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "ResponsiveToggle", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.util.mediaQuery.js"),
          a = n("./js/foundation.util.motion.js"),
          l = n("./js/foundation.core.plugin.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function c(t, e) {
        return (c = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = d(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = d(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && c(t, e);
        }(o, l["Plugin"]);
        var t,
            e,
            n,
            i = f(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = s()(t), this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "ResponsiveToggle", this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            r.MediaQuery._init();

            var t,
                e = this.$element.data("responsive-toggle");
            e || console.error("Your tab bar needs an ID of a Menu as the value of data-tab-bar."), this.$targetMenu = s()("#".concat(e)), this.$toggler = this.$element.find("[data-toggle]").filter(function () {
              var t = s()(this).data("toggle");
              return t === e || "" === t;
            }), this.options = s.a.extend({}, this.options, this.$targetMenu.data()), this.options.animate && (t = this.options.animate.split(" "), this.animationIn = t[0], this.animationOut = t[1] || null), this._update();
          }
        }, {
          key: "_events",
          value: function () {
            this._updateMqHandler = this._update.bind(this), s()(window).on("changed.zf.mediaquery", this._updateMqHandler), this.$toggler.on("click.zf.responsiveToggle", this.toggleMenu.bind(this));
          }
        }, {
          key: "_update",
          value: function () {
            r.MediaQuery.atLeast(this.options.hideFor) ? (this.$element.hide(), this.$targetMenu.show()) : (this.$element.show(), this.$targetMenu.hide());
          }
        }, {
          key: "toggleMenu",
          value: function () {
            var t = this;
            r.MediaQuery.atLeast(this.options.hideFor) || (this.options.animate ? this.$targetMenu.is(":hidden") ? a.Motion.animateIn(this.$targetMenu, this.animationIn, function () {
              t.$element.trigger("toggled.zf.responsiveToggle"), t.$targetMenu.find("[data-mutate]").triggerHandler("mutateme.zf.trigger");
            }) : a.Motion.animateOut(this.$targetMenu, this.animationOut, function () {
              t.$element.trigger("toggled.zf.responsiveToggle");
            }) : (this.$targetMenu.toggle(0), this.$targetMenu.find("[data-mutate]").trigger("mutateme.zf.trigger"), this.$element.trigger("toggled.zf.responsiveToggle")));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.responsiveToggle"), this.$toggler.off(".zf.responsiveToggle"), s()(window).off("changed.zf.mediaquery", this._updateMqHandler);
          }
        }]) && u(t.prototype, e), n && u(t, n), o;
      }();

      i.defaults = {
        hideFor: "medium",
        animate: !1
      };
    },
    "./js/foundation.reveal.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Reveal", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.core.plugin.js"),
          a = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.util.keyboard.js"),
          u = n("./js/foundation.util.mediaQuery.js"),
          c = n("./js/foundation.util.motion.js"),
          f = n("./js/foundation.util.triggers.js"),
          d = n("./js/foundation.util.touch.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function h(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function p(t, e) {
        return (p = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function m(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = v(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = v(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function v(t) {
        return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && p(t, e);
        }(o, r["Plugin"]);
        var t,
            e,
            n,
            i = m(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Reveal", this._init(), d.Touch.init(s.a), f.Triggers.init(s.a), l.Keyboard.register("Reveal", {
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t = this;
            u.MediaQuery._init(), this.id = this.$element.attr("id"), this.isActive = !1, this.cached = {
              mq: u.MediaQuery.current
            }, this.$anchor = s()('[data-open="'.concat(this.id, '"]')).length ? s()('[data-open="'.concat(this.id, '"]')) : s()('[data-toggle="'.concat(this.id, '"]')), this.$anchor.attr({
              "aria-controls": this.id,
              "aria-haspopup": "dialog",
              tabindex: 0
            }), (this.options.fullScreen || this.$element.hasClass("full")) && (this.options.fullScreen = !0, this.options.overlay = !1), this.options.overlay && !this.$overlay && (this.$overlay = this._makeOverlay(this.id)), this.$element.attr({
              role: "dialog",
              "aria-hidden": !0,
              "data-yeti-box": this.id,
              "data-resize": this.id
            }), this.$overlay ? this.$element.detach().appendTo(this.$overlay) : (this.$element.detach().appendTo(s()(this.options.appendTo)), this.$element.addClass("without-overlay")), this._events(), this.options.deepLink && window.location.hash === "#".concat(this.id) && (this.onLoadListener = Object(a.onLoad)(s()(window), function () {
              return t.open();
            }));
          }
        }, {
          key: "_makeOverlay",
          value: function () {
            var t = "";
            return this.options.additionalOverlayClasses && (t = " " + this.options.additionalOverlayClasses), s()("<div></div>").addClass("reveal-overlay" + t).appendTo(this.options.appendTo);
          }
        }, {
          key: "_updatePosition",
          value: function () {
            var t = this.$element.outerWidth(),
                e = s()(window).width(),
                n = this.$element.outerHeight(),
                i = s()(window).height(),
                o = null,
                t = "auto" === this.options.hOffset ? parseInt((e - t) / 2, 10) : parseInt(this.options.hOffset, 10);
            "auto" === this.options.vOffset ? o = i < n ? parseInt(Math.min(100, i / 10), 10) : parseInt((i - n) / 4, 10) : null !== this.options.vOffset && (o = parseInt(this.options.vOffset, 10)), null !== o && this.$element.css({
              top: o + "px"
            }), this.$overlay && "auto" === this.options.hOffset || (this.$element.css({
              left: t + "px"
            }), this.$element.css({
              margin: "0px"
            }));
          }
        }, {
          key: "_events",
          value: function () {
            var n = this,
                i = this;
            this.$element.on({
              "open.zf.trigger": this.open.bind(this),
              "close.zf.trigger": function (t, e) {
                if (t.target === i.$element[0] || s()(t.target).parents("[data-closable]")[0] === e) return n.close.apply(n);
              },
              "toggle.zf.trigger": this.toggle.bind(this),
              "resizeme.zf.trigger": function () {
                i._updatePosition();
              }
            }), this.options.closeOnClick && this.options.overlay && this.$overlay.off(".zf.reveal").on("click.zf.dropdown tap.zf.dropdown", function (t) {
              t.target !== i.$element[0] && !s.a.contains(i.$element[0], t.target) && s.a.contains(document, t.target) && i.close();
            }), this.options.deepLink && s()(window).on("hashchange.zf.reveal:".concat(this.id), this._handleState.bind(this));
          }
        }, {
          key: "_handleState",
          value: function (t) {
            window.location.hash !== "#" + this.id || this.isActive ? this.close() : this.open();
          }
        }, {
          key: "_disableScroll",
          value: function (t) {
            t = t || s()(window).scrollTop(), s()(document).height() > s()(window).height() && s()("html").css("top", -t);
          }
        }, {
          key: "_enableScroll",
          value: function (t) {
            t = t || parseInt(s()("html").css("top")), s()(document).height() > s()(window).height() && (s()("html").css("top", ""), s()(window).scrollTop(-t));
          }
        }, {
          key: "open",
          value: function () {
            var t = this,
                e = "#".concat(this.id);
            this.options.deepLink && window.location.hash !== e && (window.history.pushState ? this.options.updateHistory ? window.history.pushState({}, "", e) : window.history.replaceState({}, "", e) : window.location.hash = e), this.$activeAnchor = s()(document.activeElement).is(this.$anchor) ? s()(document.activeElement) : this.$anchor, this.isActive = !0, this.$element.css({
              visibility: "hidden"
            }).show().scrollTop(0), this.options.overlay && this.$overlay.css({
              visibility: "hidden"
            }).show(), this._updatePosition(), this.$element.hide().css({
              visibility: ""
            }), this.$overlay && (this.$overlay.css({
              visibility: ""
            }).hide(), this.$element.hasClass("fast") ? this.$overlay.addClass("fast") : this.$element.hasClass("slow") && this.$overlay.addClass("slow")), this.options.multipleOpened || this.$element.trigger("closeme.zf.reveal", this.id), 0 === s()(".reveal:visible").length && this._disableScroll();
            var n = this;
            this.options.animationIn ? (this.options.overlay && c.Motion.animateIn(this.$overlay, "fade-in"), c.Motion.animateIn(this.$element, this.options.animationIn, function () {
              t.$element && (t.focusableElements = l.Keyboard.findFocusable(t.$element), n.$element.attr({
                "aria-hidden": !1,
                tabindex: -1
              }).focus(), n._addGlobalClasses(), l.Keyboard.trapFocus(n.$element));
            })) : (this.options.overlay && this.$overlay.show(0), this.$element.show(this.options.showDelay)), this.$element.attr({
              "aria-hidden": !1,
              tabindex: -1
            }).focus(), l.Keyboard.trapFocus(this.$element), this._addGlobalClasses(), this._addGlobalListeners(), this.$element.trigger("open.zf.reveal");
          }
        }, {
          key: "_addGlobalClasses",
          value: function () {
            function t() {
              s()("html").toggleClass("zf-has-scroll", !!(s()(document).height() > s()(window).height()));
            }

            this.$element.on("resizeme.zf.trigger.revealScrollbarListener", t), t(), s()("html").addClass("is-reveal-open");
          }
        }, {
          key: "_removeGlobalClasses",
          value: function () {
            this.$element.off("resizeme.zf.trigger.revealScrollbarListener"), s()("html").removeClass("is-reveal-open"), s()("html").removeClass("zf-has-scroll");
          }
        }, {
          key: "_addGlobalListeners",
          value: function () {
            var e = this;
            this.$element && (this.focusableElements = l.Keyboard.findFocusable(this.$element), this.options.overlay || !this.options.closeOnClick || this.options.fullScreen || s()("body").on("click.zf.dropdown tap.zf.dropdown", function (t) {
              t.target !== e.$element[0] && !s.a.contains(e.$element[0], t.target) && s.a.contains(document, t.target) && e.close();
            }), this.options.closeOnEsc && s()(window).on("keydown.zf.reveal", function (t) {
              l.Keyboard.handleKey(t, "Reveal", {
                close: function () {
                  e.options.closeOnEsc && e.close();
                }
              });
            }));
          }
        }, {
          key: "close",
          value: function () {
            if (!this.isActive || !this.$element.is(":visible")) return !1;
            var t,
                e = this;

            function n() {
              var t = parseInt(s()("html").css("top"));
              0 === s()(".reveal:visible").length && e._removeGlobalClasses(), l.Keyboard.releaseFocus(e.$element), e.$element.attr("aria-hidden", !0), 0 === s()(".reveal:visible").length && e._enableScroll(t), e.$element.trigger("closed.zf.reveal");
            }

            this.options.animationOut ? (this.options.overlay && c.Motion.animateOut(this.$overlay, "fade-out"), c.Motion.animateOut(this.$element, this.options.animationOut, n)) : (this.$element.hide(this.options.hideDelay), this.options.overlay ? this.$overlay.hide(0, n) : n()), this.options.closeOnEsc && s()(window).off("keydown.zf.reveal"), !this.options.overlay && this.options.closeOnClick && s()("body").off("click.zf.dropdown tap.zf.dropdown"), this.$element.off("keydown.zf.reveal"), this.options.resetOnClose && this.$element.html(this.$element.html()), this.isActive = !1, e.options.deepLink && window.location.hash === "#".concat(this.id) && (window.history.replaceState ? (t = window.location.pathname + window.location.search, this.options.updateHistory ? window.history.pushState({}, "", t) : window.history.replaceState("", document.title, t)) : window.location.hash = ""), this.$activeAnchor.focus();
          }
        }, {
          key: "toggle",
          value: function () {
            this.isActive ? this.close() : this.open();
          }
        }, {
          key: "_destroy",
          value: function () {
            this.options.overlay && (this.$element.appendTo(s()(this.options.appendTo)), this.$overlay.hide().off().remove()), this.$element.hide().off(), this.$anchor.off(".zf"), s()(window).off(".zf.reveal:".concat(this.id)), this.onLoadListener && s()(window).off(this.onLoadListener), 0 === s()(".reveal:visible").length && this._removeGlobalClasses();
          }
        }]) && h(t.prototype, e), n && h(t, n), o;
      }();

      i.defaults = {
        animationIn: "",
        animationOut: "",
        showDelay: 0,
        hideDelay: 0,
        closeOnClick: !0,
        closeOnEsc: !0,
        multipleOpened: !1,
        vOffset: "auto",
        hOffset: "auto",
        fullScreen: !1,
        overlay: !0,
        resetOnClose: !1,
        deepLink: !1,
        updateHistory: !1,
        appendTo: "body",
        additionalOverlayClasses: ""
      };
    },
    "./js/foundation.slider.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Slider", function () {
        return i;
      });
      var e = n("jquery"),
          u = n.n(e),
          r = n("./js/foundation.util.keyboard.js"),
          h = n("./js/foundation.util.motion.js"),
          c = n("./js/foundation.core.utils.js"),
          s = n("./js/foundation.core.plugin.js"),
          a = n("./js/foundation.util.touch.js"),
          l = n("./js/foundation.util.triggers.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function f(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function d(t, e) {
        return (d = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function p(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = m(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = m(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function m(t) {
        return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && d(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = p(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = u.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Slider", a.Touch.init(u.a), l.Triggers.init(u.a), this._init(), r.Keyboard.register("Slider", {
              ltr: {
                ARROW_RIGHT: "increase",
                ARROW_UP: "increase",
                ARROW_DOWN: "decrease",
                ARROW_LEFT: "decrease",
                SHIFT_ARROW_RIGHT: "increase_fast",
                SHIFT_ARROW_UP: "increase_fast",
                SHIFT_ARROW_DOWN: "decrease_fast",
                SHIFT_ARROW_LEFT: "decrease_fast",
                HOME: "min",
                END: "max"
              },
              rtl: {
                ARROW_LEFT: "increase",
                ARROW_RIGHT: "decrease",
                SHIFT_ARROW_LEFT: "increase_fast",
                SHIFT_ARROW_RIGHT: "decrease_fast"
              }
            });
          }
        }, {
          key: "_init",
          value: function () {
            this.inputs = this.$element.find("input"), this.handles = this.$element.find("[data-slider-handle]"), this.$handle = this.handles.eq(0), this.$input = this.inputs.length ? this.inputs.eq(0) : u()("#".concat(this.$handle.attr("aria-controls"))), this.$fill = this.$element.find("[data-slider-fill]").css(this.options.vertical ? "height" : "width", 0);
            (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) && (this.options.disabled = !0, this.$element.addClass(this.options.disabledClass)), this.inputs.length || (this.inputs = u()().add(this.$input), this.options.binding = !0), this._setInitAttr(0), this.handles[1] && (this.options.doubleSided = !0, this.$handle2 = this.handles.eq(1), this.$input2 = 1 < this.inputs.length ? this.inputs.eq(1) : u()("#".concat(this.$handle2.attr("aria-controls"))), this.inputs[1] || (this.inputs = this.inputs.add(this.$input2)), this._setInitAttr(1)), this.setHandles(), this._events();
          }
        }, {
          key: "setHandles",
          value: function () {
            var t = this;
            this.handles[1] ? this._setHandlePos(this.$handle, this.inputs.eq(0).val(), function () {
              t._setHandlePos(t.$handle2, t.inputs.eq(1).val());
            }) : this._setHandlePos(this.$handle, this.inputs.eq(0).val());
          }
        }, {
          key: "_reflow",
          value: function () {
            this.setHandles();
          }
        }, {
          key: "_pctOfBar",
          value: function (t) {
            var e = (t - this.options.start) / (this.options.end - this.options.start);

            switch (this.options.positionValueFunction) {
              case "pow":
                e = this._logTransform(e);
                break;

              case "log":
                e = this._powTransform(e);
            }

            return e.toFixed(2);
          }
        }, {
          key: "_value",
          value: function (t) {
            switch (this.options.positionValueFunction) {
              case "pow":
                t = this._powTransform(t);
                break;

              case "log":
                t = this._logTransform(t);
            }

            var e = this.options.vertical ? parseFloat(this.options.end) + t * (this.options.start - this.options.end) : (this.options.end - this.options.start) * t + parseFloat(this.options.start);
            return e;
          }
        }, {
          key: "_logTransform",
          value: function (t) {
            return e = this.options.nonLinearBase, t = t * (this.options.nonLinearBase - 1) + 1, Math.log(t) / Math.log(e);
            var e;
          }
        }, {
          key: "_powTransform",
          value: function (t) {
            return (Math.pow(this.options.nonLinearBase, t) - 1) / (this.options.nonLinearBase - 1);
          }
        }, {
          key: "_setHandlePos",
          value: function (t, e, n) {
            var i, o, s, r, a, l, u, c, f, d;
            this.$element.hasClass(this.options.disabledClass) || ((e = parseFloat(e)) < this.options.start ? e = this.options.start : e > this.options.end && (e = this.options.end), (i = this.options.doubleSided) && (e = 0 === this.handles.index(t) ? (f = parseFloat(this.$handle2.attr("aria-valuenow"))) <= e ? f - this.options.step : e : e <= (a = parseFloat(this.$handle.attr("aria-valuenow"))) ? a + this.options.step : e), f = (o = this).options.vertical, s = f ? "height" : "width", r = f ? "top" : "left", a = t[0].getBoundingClientRect()[s], f = this.$element[0].getBoundingClientRect()[s], l = this._pctOfBar(e), u = ((f - a) * l / f * 100).toFixed(this.options.decimal), e = parseFloat(e.toFixed(this.options.decimal)), c = {}, this._setValues(t, e), i && (f = ~~(a / f * 100), 0 === this.handles.index(t) ? (c[r] = "".concat(u, "%"), d = parseFloat(this.$handle2[0].style[r]) - u + f, n && "function" == typeof n && n()) : (n = parseFloat(this.$handle[0].style[r]), d = u - (isNaN(n) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : n) + f), c["min-".concat(s)] = "".concat(d, "%")), this.$element.one("finished.zf.animate", function () {
              o.$element.trigger("moved.zf.slider", [t]);
            }), d = this.$element.data("dragging") ? 1e3 / 60 : this.options.moveTime, Object(h.Move)(d, t, function () {
              isNaN(u) ? t.css(r, "".concat(100 * l, "%")) : t.css(r, "".concat(u, "%")), o.options.doubleSided ? o.$fill.css(c) : o.$fill.css(s, "".concat(100 * l, "%"));
            }), clearTimeout(o.timeout), o.timeout = setTimeout(function () {
              o.$element.trigger("changed.zf.slider", [t]);
            }, o.options.changedDelay));
          }
        }, {
          key: "_setInitAttr",
          value: function (t) {
            var e = 0 === t ? this.options.initialStart : this.options.initialEnd,
                n = this.inputs.eq(t).attr("id") || Object(c.GetYoDigits)(6, "slider");
            this.inputs.eq(t).attr({
              id: n,
              max: this.options.end,
              min: this.options.start,
              step: this.options.step
            }), this.inputs.eq(t).val(e), this.handles.eq(t).attr({
              role: "slider",
              "aria-controls": n,
              "aria-valuemax": this.options.end,
              "aria-valuemin": this.options.start,
              "aria-valuenow": e,
              "aria-orientation": this.options.vertical ? "vertical" : "horizontal",
              tabindex: 0
            });
          }
        }, {
          key: "_setValues",
          value: function (t, e) {
            var n = this.options.doubleSided ? this.handles.index(t) : 0;
            this.inputs.eq(n).val(e), t.attr("aria-valuenow", e);
          }
        }, {
          key: "_handleEvent",
          value: function (t, e, n) {
            var i, o, s, r, a, l;
            n ? l = this._adjustValue(null, n) : (t.preventDefault(), i = (a = this.options.vertical) ? "height" : "width", o = a ? "top" : "left", s = a ? t.pageY : t.pageX, r = this.$element[0].getBoundingClientRect()[i], n = a ? u()(window).scrollTop() : u()(window).scrollLeft(), a = this.$element.offset()[o], t.clientY === t.pageY && (s += n), l = this._value((a = (a = s - a) < 0 ? 0 : r < a ? r : a) / r), Object(c.rtl)() && !this.options.vertical && (l = this.options.end - l), l = this._adjustValue(null, l), e = e || (v(this.$handle, o, a, i) <= v(this.$handle2, o, a, i) ? this.$handle : this.$handle2)), this._setHandlePos(e, l);
          }
        }, {
          key: "_adjustValue",
          value: function (t, e) {
            var n = this.options.step,
                i = parseFloat(n / 2),
                o = t ? parseFloat(t.attr("aria-valuenow")) : e,
                t = 0 <= o ? o % n : n + o % n,
                e = o - t;
            return 0 === t ? o : o = e + i <= o ? e + n : e;
          }
        }, {
          key: "_events",
          value: function () {
            this._eventsForHandle(this.$handle), this.handles[1] && this._eventsForHandle(this.$handle2);
          }
        }, {
          key: "_eventsForHandle",
          value: function (e) {
            function n(t) {
              var e = s.inputs.index(u()(this));

              s._handleEvent(t, s.handles.eq(e), u()(this).val());
            }

            var i,
                o,
                s = this;
            this.inputs.off("keyup.zf.slider").on("keyup.zf.slider", function (t) {
              13 == t.keyCode && n.call(this, t);
            }), this.inputs.off("change.zf.slider").on("change.zf.slider", n), this.options.clickSelect && this.$element.off("click.zf.slider").on("click.zf.slider", function (t) {
              return !s.$element.data("dragging") && void (u()(t.target).is("[data-slider-handle]") || (s.options.doubleSided ? s._handleEvent(t) : s._handleEvent(t, s.$handle)));
            }), this.options.draggable && (this.handles.addTouch(), o = u()("body"), e.off("mousedown.zf.slider").on("mousedown.zf.slider", function (t) {
              e.addClass("is-dragging"), s.$fill.addClass("is-dragging"), s.$element.data("dragging", !0), i = u()(t.currentTarget), o.on("mousemove.zf.slider", function (t) {
                t.preventDefault(), s._handleEvent(t, i);
              }).on("mouseup.zf.slider", function (t) {
                s._handleEvent(t, i), e.removeClass("is-dragging"), s.$fill.removeClass("is-dragging"), s.$element.data("dragging", !1), o.off("mousemove.zf.slider mouseup.zf.slider");
              });
            }).on("selectstart.zf.slider touchmove.zf.slider", function (t) {
              t.preventDefault();
            })), e.off("keydown.zf.slider").on("keydown.zf.slider", function (t) {
              var e,
                  n = u()(this),
                  i = s.options.doubleSided ? s.handles.index(n) : 0,
                  o = parseFloat(s.inputs.eq(i).val());
              r.Keyboard.handleKey(t, "Slider", {
                decrease: function () {
                  e = o - s.options.step;
                },
                increase: function () {
                  e = o + s.options.step;
                },
                decrease_fast: function () {
                  e = o - 10 * s.options.step;
                },
                increase_fast: function () {
                  e = o + 10 * s.options.step;
                },
                min: function () {
                  e = s.options.start;
                },
                max: function () {
                  e = s.options.end;
                },
                handled: function () {
                  t.preventDefault(), s._setHandlePos(n, e);
                }
              });
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.handles.off(".zf.slider"), this.inputs.off(".zf.slider"), this.$element.off(".zf.slider"), clearTimeout(this.timeout);
          }
        }]) && f(t.prototype, e), n && f(t, n), o;
      }();

      function v(t, e, n, i) {
        return Math.abs(t.position()[e] + t[i]() / 2 - n);
      }

      i.defaults = {
        start: 0,
        end: 100,
        step: 1,
        initialStart: 0,
        initialEnd: 100,
        binding: !1,
        clickSelect: !0,
        vertical: !1,
        draggable: !0,
        disabled: !1,
        doubleSided: !1,
        decimal: 2,
        moveTime: 200,
        disabledClass: "disabled",
        invertVertical: !1,
        changedDelay: 500,
        nonLinearBase: 5,
        positionValueFunction: "linear"
      };
    },
    "./js/foundation.smoothScroll.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "SmoothScroll", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.core.utils.js"),
          a = n("./js/foundation.core.plugin.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function l(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function u(t, e) {
        return (u = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function c(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = f(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = f(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function f(t) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && u(t, e);
        }(o, a["Plugin"]);
        var t,
            e,
            n,
            i = c(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, n = [{
          key: "scrollToLoc",
          value: function (t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : o.defaults,
                n = 2 < arguments.length ? arguments[2] : void 0,
                t = s()(t);
            if (!t.length) return !1;
            t = Math.round(t.offset().top - e.threshold / 2 - e.offset);
            s()("html, body").stop(!0).animate({
              scrollTop: t
            }, e.animationDuration, e.animationEasing, function () {
              "function" == typeof n && n();
            });
          }
        }], (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "SmoothScroll", this._init();
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element[0].id || Object(r.GetYoDigits)(6, "smooth-scroll");
            this.$element.attr({
              id: t
            }), this._events();
          }
        }, {
          key: "_events",
          value: function () {
            this._linkClickListener = this._handleLinkClick.bind(this), this.$element.on("click.zf.smoothScroll", this._linkClickListener), this.$element.on("click.zf.smoothScroll", 'a[href^="#"]', this._linkClickListener);
          }
        }, {
          key: "_handleLinkClick",
          value: function (t) {
            var e,
                n = this;
            s()(t.currentTarget).is('a[href^="#"]') && (e = t.currentTarget.getAttribute("href"), this._inTransition = !0, o.scrollToLoc(e, this.options, function () {
              n._inTransition = !1;
            }), t.preventDefault());
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off("click.zf.smoothScroll", this._linkClickListener), this.$element.off("click.zf.smoothScroll", 'a[href^="#"]', this._linkClickListener);
          }
        }]) && l(t.prototype, e), n && l(t, n), o;
      }();

      i.defaults = {
        animationDuration: 500,
        animationEasing: "linear",
        threshold: 50,
        offset: 0
      };
    },
    "./js/foundation.sticky.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Sticky", function () {
        return i;
      });
      var e = n("jquery"),
          a = n.n(e),
          s = n("./js/foundation.core.plugin.js"),
          r = n("./js/foundation.core.utils.js"),
          l = n("./js/foundation.util.mediaQuery.js"),
          u = n("./js/foundation.util.triggers.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = d(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = a.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Sticky", u.Triggers.init(a.a), this._init();
          }
        }, {
          key: "_init",
          value: function () {
            l.MediaQuery._init();

            var t = this.$element.parent("[data-sticky-container]"),
                e = this.$element[0].id || Object(r.GetYoDigits)(6, "sticky"),
                n = this;
            t.length ? this.$container = t : (this.wasWrapped = !0, this.$element.wrap(this.options.container), this.$container = this.$element.parent()), this.$container.addClass(this.options.containerClass), this.$element.addClass(this.options.stickyClass).attr({
              "data-resize": e,
              "data-mutate": e
            }), "" !== this.options.anchor && a()("#" + n.options.anchor).attr({
              "data-mutate": e
            }), this.scrollCount = this.options.checkEvery, this.isStuck = !1, this.onLoadListener = Object(r.onLoad)(a()(window), function () {
              n.containerHeight = "none" == n.$element.css("display") ? 0 : n.$element[0].getBoundingClientRect().height, n.$container.css("height", n.containerHeight), n.elemHeight = n.containerHeight, "" !== n.options.anchor ? n.$anchor = a()("#" + n.options.anchor) : n._parsePoints(), n._setSizes(function () {
                var t = window.pageYOffset;
                n._calc(!1, t), n.isStuck || n._removeSticky(!(t >= n.topPoint));
              }), n._events(e.split("-").reverse().join("-"));
            });
          }
        }, {
          key: "_parsePoints",
          value: function () {
            for (var t, e, n, i = ["" == this.options.topAnchor ? 1 : this.options.topAnchor, "" == this.options.btmAnchor ? document.documentElement.scrollHeight : this.options.btmAnchor], o = {}, s = 0, r = i.length; s < r && i[s]; s++) "number" == typeof i[s] ? n = i[s] : (t = i[s].split(":"), n = (e = a()("#".concat(t[0]))).offset().top, t[1] && "bottom" === t[1].toLowerCase() && (n += e[0].getBoundingClientRect().height)), o[s] = n;

            this.points = o;
          }
        }, {
          key: "_events",
          value: function (n) {
            var i = this,
                t = this.scrollListener = "scroll.zf.".concat(n);
            this.isOn || (this.canStick && (this.isOn = !0, a()(window).off(t).on(t, function (t) {
              0 === i.scrollCount ? (i.scrollCount = i.options.checkEvery, i._setSizes(function () {
                i._calc(!1, window.pageYOffset);
              })) : (i.scrollCount--, i._calc(!1, window.pageYOffset));
            })), this.$element.off("resizeme.zf.trigger").on("resizeme.zf.trigger", function (t, e) {
              i._eventsHandler(n);
            }), this.$element.on("mutateme.zf.trigger", function (t, e) {
              i._eventsHandler(n);
            }), this.$anchor && this.$anchor.on("mutateme.zf.trigger", function (t, e) {
              i._eventsHandler(n);
            }));
          }
        }, {
          key: "_eventsHandler",
          value: function (t) {
            var e = this,
                n = this.scrollListener = "scroll.zf.".concat(t);

            e._setSizes(function () {
              e._calc(!1), e.canStick ? e.isOn || e._events(t) : e.isOn && e._pauseListeners(n);
            });
          }
        }, {
          key: "_pauseListeners",
          value: function (t) {
            this.isOn = !1, a()(window).off(t), this.$element.trigger("pause.zf.sticky");
          }
        }, {
          key: "_calc",
          value: function (t, e) {
            if (t && this._setSizes(), !this.canStick) return this.isStuck && this._removeSticky(!0), !1;
            (e = e || window.pageYOffset) >= this.topPoint ? e <= this.bottomPoint ? this.isStuck || this._setSticky() : this.isStuck && this._removeSticky(!1) : this.isStuck && this._removeSticky(!0);
          }
        }, {
          key: "_setSticky",
          value: function () {
            var t = this,
                e = this.options.stickTo,
                n = "top" === e ? "marginTop" : "marginBottom",
                i = "top" === e ? "bottom" : "top",
                o = {};
            o[n] = "".concat(this.options[n], "em"), o[e] = 0, o[i] = "auto", this.isStuck = !0, this.$element.removeClass("is-anchored is-at-".concat(i)).addClass("is-stuck is-at-".concat(e)).css(o).trigger("sticky.zf.stuckto:".concat(e)), this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function () {
              t._setSizes();
            });
          }
        }, {
          key: "_removeSticky",
          value: function (t) {
            var e = this.options.stickTo,
                n = {},
                i = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,
                o = t ? "top" : "bottom";
            n["top" === e ? "marginTop" : "marginBottom"] = 0, n.bottom = "auto", n.top = t ? 0 : i, this.isStuck = !1, this.$element.removeClass("is-stuck is-at-".concat(e)).addClass("is-anchored is-at-".concat(o)).css(n).trigger("sticky.zf.unstuckfrom:".concat(o));
          }
        }, {
          key: "_setSizes",
          value: function (t) {
            this.canStick = l.MediaQuery.is(this.options.stickyOn), this.canStick || t && "function" == typeof t && t();
            var e,
                n = this.$container[0].getBoundingClientRect().width,
                i = window.getComputedStyle(this.$container[0]),
                o = parseInt(i["padding-left"], 10),
                i = parseInt(i["padding-right"], 10);
            this.$anchor && this.$anchor.length ? this.anchorHeight = this.$anchor[0].getBoundingClientRect().height : this._parsePoints(), this.$element.css({
              "max-width": "".concat(n - o - i, "px")
            }), !this.options.dynamicHeight && this.containerHeight || (e = this.$element[0].getBoundingClientRect().height || this.containerHeight, e = "none" == this.$element.css("display") ? 0 : e, this.$container.css("height", e), this.containerHeight = e), this.elemHeight = this.containerHeight, this.isStuck || this.$element.hasClass("is-at-bottom") && (e = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight, this.$element.css("top", e)), this._setBreakPoints(this.containerHeight, function () {
              t && "function" == typeof t && t();
            });
          }
        }, {
          key: "_setBreakPoints",
          value: function (t, e) {
            if (!this.canStick) {
              if (!e || "function" != typeof e) return !1;
              e();
            }

            var n = p(this.options.marginTop),
                i = p(this.options.marginBottom),
                o = this.points ? this.points[0] : this.$anchor.offset().top,
                s = this.points ? this.points[1] : o + this.anchorHeight,
                r = window.innerHeight;
            "top" === this.options.stickTo ? (o -= n, s -= t + n) : "bottom" === this.options.stickTo && (o -= r - (t + i), s -= r - i), this.topPoint = o, this.bottomPoint = s, e && "function" == typeof e && e();
          }
        }, {
          key: "_destroy",
          value: function () {
            this._removeSticky(!0), this.$element.removeClass("".concat(this.options.stickyClass, " is-anchored is-at-top")).css({
              height: "",
              top: "",
              bottom: "",
              "max-width": ""
            }).off("resizeme.zf.trigger").off("mutateme.zf.trigger"), this.$anchor && this.$anchor.length && this.$anchor.off("change.zf.sticky"), this.scrollListener && a()(window).off(this.scrollListener), this.onLoadListener && a()(window).off(this.onLoadListener), this.wasWrapped ? this.$element.unwrap() : this.$container.removeClass(this.options.containerClass).css({
              height: ""
            });
          }
        }]) && c(t.prototype, e), n && c(t, n), o;
      }();

      function p(t) {
        return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * t;
      }

      i.defaults = {
        container: "<div data-sticky-container></div>",
        stickTo: "top",
        anchor: "",
        topAnchor: "",
        btmAnchor: "",
        marginTop: 1,
        marginBottom: 1,
        stickyOn: "medium",
        stickyClass: "sticky",
        containerClass: "sticky-container",
        dynamicHeight: !0,
        checkEvery: -1
      };
    },
    "./js/foundation.tabs.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Tabs", function () {
        return i;
      });
      var e = n("jquery"),
          a = n.n(e),
          s = n("./js/foundation.core.plugin.js"),
          l = n("./js/foundation.core.utils.js"),
          r = n("./js/foundation.util.keyboard.js"),
          u = n("./js/foundation.util.imageLoader.js");

      function c(t) {
        return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function f(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function d(t, e) {
        return (d = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function h(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = o(n);
          return function (t, e) {
            {
              if (e && ("object" === c(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = o(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function o(t) {
        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && d(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            n,
            i = h(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = a.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Tabs", this._init(), r.Keyboard.register("Tabs", {
              ENTER: "open",
              SPACE: "open",
              ARROW_RIGHT: "next",
              ARROW_UP: "previous",
              ARROW_DOWN: "next",
              ARROW_LEFT: "previous"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t,
                i = this,
                r = this;
            this._isInitializing = !0, this.$element.attr({
              role: "tablist"
            }), this.$tabTitles = this.$element.find(".".concat(this.options.linkClass)), this.$tabContent = a()('[data-tabs-content="'.concat(this.$element[0].id, '"]')), this.$tabTitles.each(function () {
              var t = a()(this),
                  e = t.find("a"),
                  n = t.hasClass("".concat(r.options.linkActiveClass)),
                  i = e.attr("data-tabs-target") || e[0].hash.slice(1),
                  o = e[0].id || "".concat(i, "-label"),
                  s = a()("#".concat(i));
              t.attr({
                role: "presentation"
              }), e.attr({
                role: "tab",
                "aria-controls": i,
                "aria-selected": n,
                id: o,
                tabindex: n ? "0" : "-1"
              }), s.attr({
                role: "tabpanel",
                "aria-labelledby": o
              }), n && (r._initialAnchor = "#".concat(i)), n || s.attr("aria-hidden", "true"), n && r.options.autoFocus && (r.onLoadListener = Object(l.onLoad)(a()(window), function () {
                a()("html, body").animate({
                  scrollTop: t.offset().top
                }, r.options.deepLinkSmudgeDelay, function () {
                  e.focus();
                });
              }));
            }), this.options.matchHeight && ((t = this.$tabContent.find("img")).length ? Object(u.onImagesLoaded)(t, this._setHeight.bind(this)) : this._setHeight()), this._checkDeepLink = function () {
              var t = window.location.hash;

              if (!t.length) {
                if (i._isInitializing) return;
                i._initialAnchor && (t = i._initialAnchor);
              }

              var e = 0 <= t.indexOf("#") ? t.slice(1) : t,
                  n = e && a()("#".concat(e)),
                  t = t && i.$element.find('[href$="'.concat(t, '"],[data-tabs-target="').concat(e, '"]')).first();
              !n.length || !t.length || (n && n.length && t && t.length ? i.selectTab(n, !0) : i._collapse(), i.options.deepLinkSmudge && (e = i.$element.offset(), a()("html, body").animate({
                scrollTop: e.top - i.options.deepLinkSmudgeOffset
              }, i.options.deepLinkSmudgeDelay)), i.$element.trigger("deeplink.zf.tabs", [t, n]));
            }, this.options.deepLink && this._checkDeepLink(), this._events(), this._isInitializing = !1;
          }
        }, {
          key: "_events",
          value: function () {
            this._addKeyHandler(), this._addClickHandler(), this._setHeightMqHandler = null, this.options.matchHeight && (this._setHeightMqHandler = this._setHeight.bind(this), a()(window).on("changed.zf.mediaquery", this._setHeightMqHandler)), this.options.deepLink && a()(window).on("hashchange", this._checkDeepLink);
          }
        }, {
          key: "_addClickHandler",
          value: function () {
            var e = this;
            this.$element.off("click.zf.tabs").on("click.zf.tabs", ".".concat(this.options.linkClass), function (t) {
              t.preventDefault(), e._handleTabChange(a()(this));
            });
          }
        }, {
          key: "_addKeyHandler",
          value: function () {
            var s = this;
            this.$tabTitles.off("keydown.zf.tabs").on("keydown.zf.tabs", function (t) {
              var e, n, i, o;
              9 !== t.which && (e = a()(this), (n = e.parent("ul").children("li")).each(function (t) {
                a()(this).is(e) && (o = s.options.wrapOnKeys ? (i = 0 === t ? n.last() : n.eq(t - 1), t === n.length - 1 ? n.first() : n.eq(t + 1)) : (i = n.eq(Math.max(0, t - 1)), n.eq(Math.min(t + 1, n.length - 1))));
              }), r.Keyboard.handleKey(t, "Tabs", {
                open: function () {
                  e.find('[role="tab"]').focus(), s._handleTabChange(e);
                },
                previous: function () {
                  i.find('[role="tab"]').focus(), s._handleTabChange(i);
                },
                next: function () {
                  o.find('[role="tab"]').focus(), s._handleTabChange(o);
                },
                handled: function () {
                  t.preventDefault();
                }
              }));
            });
          }
        }, {
          key: "_handleTabChange",
          value: function (t, e) {
            var n, i, o;
            t.hasClass("".concat(this.options.linkActiveClass)) ? this.options.activeCollapse && this._collapse() : (n = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass)), i = (i = (o = t.find('[role="tab"]')).attr("data-tabs-target")) && i.length ? "#".concat(i) : o[0].hash, o = this.$tabContent.find(i), this._collapseTab(n), this._openTab(t), this.options.deepLink && !e && (this.options.updateHistory ? history.pushState({}, "", i) : history.replaceState({}, "", i)), this.$element.trigger("change.zf.tabs", [t, o]), o.find("[data-mutate]").trigger("mutateme.zf.trigger"));
          }
        }, {
          key: "_openTab",
          value: function (t) {
            var e = t.find('[role="tab"]'),
                n = e.attr("data-tabs-target") || e[0].hash.slice(1),
                n = this.$tabContent.find("#".concat(n));
            t.addClass("".concat(this.options.linkActiveClass)), e.attr({
              "aria-selected": "true",
              tabindex: "0"
            }), n.addClass("".concat(this.options.panelActiveClass)).removeAttr("aria-hidden");
          }
        }, {
          key: "_collapseTab",
          value: function (t) {
            t = t.removeClass("".concat(this.options.linkActiveClass)).find('[role="tab"]').attr({
              "aria-selected": "false",
              tabindex: -1
            });
            a()("#".concat(t.attr("aria-controls"))).removeClass("".concat(this.options.panelActiveClass)).attr({
              "aria-hidden": "true"
            });
          }
        }, {
          key: "_collapse",
          value: function () {
            var t = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass));
            t.length && (this._collapseTab(t), this.$element.trigger("collapse.zf.tabs", [t]));
          }
        }, {
          key: "selectTab",
          value: function (t, e) {
            var n,
                t = "object" === c(t) ? t[0].id : t;
            t.indexOf("#") < 0 ? n = "#".concat(t) : t = (n = t).slice(1);
            t = this.$tabTitles.has('[href$="'.concat(n, '"],[data-tabs-target="').concat(t, '"]')).first();

            this._handleTabChange(t, e);
          }
        }, {
          key: "_setHeight",
          value: function () {
            var i = 0,
                o = this;
            this.$tabContent && this.$tabContent.find(".".concat(this.options.panelClass)).css("height", "").each(function () {
              var t = a()(this),
                  e = t.hasClass("".concat(o.options.panelActiveClass));
              e || t.css({
                visibility: "hidden",
                display: "block"
              });
              var n = this.getBoundingClientRect().height;
              e || t.css({
                visibility: "",
                display: ""
              }), i = i < n ? n : i;
            }).css("height", "".concat(i, "px"));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.find(".".concat(this.options.linkClass)).off(".zf.tabs").hide().end().find(".".concat(this.options.panelClass)).hide(), this.options.matchHeight && null != this._setHeightMqHandler && a()(window).off("changed.zf.mediaquery", this._setHeightMqHandler), this.options.deepLink && a()(window).off("hashchange", this._checkDeepLink), this.onLoadListener && a()(window).off(this.onLoadListener);
          }
        }]) && f(t.prototype, e), n && f(t, n), o;
      }();

      i.defaults = {
        deepLink: !1,
        deepLinkSmudge: !1,
        deepLinkSmudgeDelay: 300,
        deepLinkSmudgeOffset: 0,
        updateHistory: !1,
        autoFocus: !1,
        wrapOnKeys: !0,
        matchHeight: !1,
        activeCollapse: !1,
        linkClass: "tabs-title",
        linkActiveClass: "is-active",
        panelClass: "tabs-panel",
        panelActiveClass: "is-active"
      };
    },
    "./js/foundation.toggler.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Toggler", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.util.motion.js"),
          a = n("./js/foundation.core.plugin.js"),
          l = n("./js/foundation.core.utils.js"),
          u = n("./js/foundation.util.triggers.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, a["Plugin"]);
        var t,
            e,
            n,
            i = d(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, t.data(), e), this.className = "", this.className = "Toggler", u.Triggers.init(s.a), this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            var t,
                i = this.$element[0].id,
                e = s()('[data-open~="'.concat(i, '"], [data-close~="').concat(i, '"], [data-toggle~="').concat(i, '"]'));
            if (this.options.animate) t = this.options.animate.split(" "), this.animationIn = t[0], this.animationOut = t[1] || null, e.attr("aria-expanded", !this.$element.is(":hidden"));else {
              if ("string" != typeof (t = this.options.toggler) || !t.length) throw new Error("The 'toggler' option containing the target class is required, got \"".concat(t, '"'));
              this.className = "." === t[0] ? t.slice(1) : t, e.attr("aria-expanded", this.$element.hasClass(this.className));
            }
            e.each(function (t, e) {
              var n = s()(e),
                  e = n.attr("aria-controls") || "";
              new RegExp("\\b".concat(Object(l.RegExpEscape)(i), "\\b")).test(e) || n.attr("aria-controls", e ? "".concat(e, " ").concat(i) : i);
            });
          }
        }, {
          key: "_events",
          value: function () {
            this.$element.off("toggle.zf.trigger").on("toggle.zf.trigger", this.toggle.bind(this));
          }
        }, {
          key: "toggle",
          value: function () {
            this[this.options.animate ? "_toggleAnimate" : "_toggleClass"]();
          }
        }, {
          key: "_toggleClass",
          value: function () {
            this.$element.toggleClass(this.className);
            var t = this.$element.hasClass(this.className);
            t ? this.$element.trigger("on.zf.toggler") : this.$element.trigger("off.zf.toggler"), this._updateARIA(t), this.$element.find("[data-mutate]").trigger("mutateme.zf.trigger");
          }
        }, {
          key: "_toggleAnimate",
          value: function () {
            var t = this;
            this.$element.is(":hidden") ? r.Motion.animateIn(this.$element, this.animationIn, function () {
              t._updateARIA(!0), this.trigger("on.zf.toggler"), this.find("[data-mutate]").trigger("mutateme.zf.trigger");
            }) : r.Motion.animateOut(this.$element, this.animationOut, function () {
              t._updateARIA(!1), this.trigger("off.zf.toggler"), this.find("[data-mutate]").trigger("mutateme.zf.trigger");
            });
          }
        }, {
          key: "_updateARIA",
          value: function (t) {
            var e = this.$element[0].id;
            s()('[data-open="'.concat(e, '"], [data-close="').concat(e, '"], [data-toggle="').concat(e, '"]')).attr({
              "aria-expanded": !!t
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.toggler");
          }
        }]) && c(t.prototype, e), n && c(t, n), o;
      }();

      i.defaults = {
        toggler: void 0,
        animate: !1
      };
    },
    "./js/foundation.tooltip.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Tooltip", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          r = n("./js/foundation.core.utils.js"),
          a = n("./js/foundation.util.mediaQuery.js"),
          l = n("./js/foundation.util.triggers.js"),
          u = n("./js/foundation.positionable.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e, n) {
        return (f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
          t = function (t, e) {
            for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = p(t)););

            return t;
          }(t, e);

          if (t) {
            e = Object.getOwnPropertyDescriptor(t, e);
            return e.get ? e.get.call(n) : e.value;
          }
        })(t, e, n || t);
      }

      function d(t, e) {
        return (d = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function h(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = p(n);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = p(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function p(t) {
        return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && d(t, e);
        }(o, u["Positionable"]);
        var t,
            e,
            n,
            i = h(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Tooltip", this.isActive = !1, this.isClick = !1, l.Triggers.init(s.a), this._init();
          }
        }, {
          key: "_init",
          value: function () {
            a.MediaQuery._init();

            var t = this.$element.attr("aria-describedby") || Object(r.GetYoDigits)(6, "tooltip");
            this.options.tipText = this.options.tipText || this.$element.attr("title"), this.template = this.options.template ? s()(this.options.template) : this._buildTemplate(t), (this.options.allowHtml ? this.template.appendTo(document.body).html(this.options.tipText) : this.template.appendTo(document.body).text(this.options.tipText)).hide(), this.$element.attr({
              title: "",
              "aria-describedby": t,
              "data-yeti-box": t,
              "data-toggle": t,
              "data-resize": t
            }).addClass(this.options.triggerClass), f(p(o.prototype), "_init", this).call(this), this._events();
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            var t = this.$element[0].className,
                t = (t = this.$element[0] instanceof SVGElement ? t.baseVal : t).match(/\b(top|left|right|bottom)\b/g);
            return t ? t[0] : "top";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            return "center";
          }
        }, {
          key: "_getHOffset",
          value: function () {
            return "left" === this.position || "right" === this.position ? this.options.hOffset + this.options.tooltipWidth : this.options.hOffset;
          }
        }, {
          key: "_getVOffset",
          value: function () {
            return "top" === this.position || "bottom" === this.position ? this.options.vOffset + this.options.tooltipHeight : this.options.vOffset;
          }
        }, {
          key: "_buildTemplate",
          value: function (t) {
            var e = "".concat(this.options.tooltipClass, " ").concat(this.options.templateClasses).trim();
            return s()("<div></div>").addClass(e).attr({
              role: "tooltip",
              "aria-hidden": !0,
              "data-is-active": !1,
              "data-is-focus": !1,
              id: t
            });
          }
        }, {
          key: "_setPosition",
          value: function () {
            f(p(o.prototype), "_setPosition", this).call(this, this.$element, this.template);
          }
        }, {
          key: "show",
          value: function () {
            if ("all" !== this.options.showOn && !a.MediaQuery.is(this.options.showOn)) return !1;
            this.template.css("visibility", "hidden").show(), this._setPosition(), this.template.removeClass("top bottom left right").addClass(this.position), this.template.removeClass("align-top align-bottom align-left align-right align-center").addClass("align-" + this.alignment), this.$element.trigger("closeme.zf.tooltip", this.template.attr("id")), this.template.attr({
              "data-is-active": !0,
              "aria-hidden": !1
            }), this.isActive = !0, this.template.stop().hide().css("visibility", "").fadeIn(this.options.fadeInDuration, function () {}), this.$element.trigger("show.zf.tooltip");
          }
        }, {
          key: "hide",
          value: function () {
            var t = this;
            this.template.stop().attr({
              "aria-hidden": !0,
              "data-is-active": !1
            }).fadeOut(this.options.fadeOutDuration, function () {
              t.isActive = !1, t.isClick = !1;
            }), this.$element.trigger("hide.zf.tooltip");
          }
        }, {
          key: "_events",
          value: function () {
            var e = this,
                t = "ontouchstart" in window || void 0 !== window.ontouchstart,
                n = (this.template, !1);
            t && this.options.disableForTouch || (this.options.disableHover || this.$element.on("mouseenter.zf.tooltip", function (t) {
              e.isActive || (e.timeout = setTimeout(function () {
                e.show();
              }, e.options.hoverDelay));
            }).on("mouseleave.zf.tooltip", Object(r.ignoreMousedisappear)(function (t) {
              clearTimeout(e.timeout), n && (!e.isClick || e.options.clickOpen) || e.hide();
            })), t && this.$element.on("tap.zf.tooltip touchend.zf.tooltip", function (t) {
              e.isActive ? e.hide() : e.show();
            }), this.options.clickOpen ? this.$element.on("mousedown.zf.tooltip", function (t) {
              e.isClick || (e.isClick = !0, !e.options.disableHover && e.$element.attr("tabindex") || e.isActive || e.show());
            }) : this.$element.on("mousedown.zf.tooltip", function (t) {
              e.isClick = !0;
            }), this.$element.on({
              "close.zf.trigger": this.hide.bind(this)
            }), this.$element.on("focus.zf.tooltip", function (t) {
              return n = !0, e.isClick ? (e.options.clickOpen || (n = !1), !1) : void e.show();
            }).on("focusout.zf.tooltip", function (t) {
              n = !1, e.isClick = !1, e.hide();
            }).on("resizeme.zf.trigger", function () {
              e.isActive && e._setPosition();
            }));
          }
        }, {
          key: "toggle",
          value: function () {
            this.isActive ? this.hide() : this.show();
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.attr("title", this.template.text()).off(".zf.trigger .zf.tooltip").removeClass(this.options.triggerClass).removeClass("top right left bottom").removeAttr("aria-describedby data-disable-hover data-resize data-toggle data-tooltip data-yeti-box"), this.template.remove();
          }
        }]) && c(t.prototype, e), n && c(t, n), o;
      }();

      i.defaults = {
        hoverDelay: 200,
        fadeInDuration: 150,
        fadeOutDuration: 150,
        disableHover: !1,
        disableForTouch: !1,
        templateClasses: "",
        tooltipClass: "tooltip",
        triggerClass: "has-tip",
        showOn: "small",
        template: "",
        tipText: "",
        touchCloseText: "Tap to close.",
        clickOpen: !0,
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !1,
        vOffset: 0,
        hOffset: 0,
        tooltipHeight: 14,
        tooltipWidth: 12,
        allowHtml: !1
      };
    },
    "./js/foundation.util.box.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Box", function () {
        return i;
      });
      var i = {
        ImNotTouchingYou: function (t, e, n, i, o) {
          return 0 === s(t, e, n, i, o);
        },
        OverlapArea: s,
        GetDimensions: f,
        GetExplicitOffsets: function (t, e, n, i, o, s, r) {
          var a,
              l,
              u = f(t),
              c = e ? f(e) : null;

          if (null !== c) {
            switch (n) {
              case "top":
                a = c.offset.top - (u.height + o);
                break;

              case "bottom":
                a = c.offset.top + c.height + o;
                break;

              case "left":
                l = c.offset.left - (u.width + s);
                break;

              case "right":
                l = c.offset.left + c.width + s;
            }

            switch (n) {
              case "top":
              case "bottom":
                switch (i) {
                  case "left":
                    l = c.offset.left + s;
                    break;

                  case "right":
                    l = c.offset.left - u.width + c.width - s;
                    break;

                  case "center":
                    l = r ? s : c.offset.left + c.width / 2 - u.width / 2 + s;
                }

                break;

              case "right":
              case "left":
                switch (i) {
                  case "bottom":
                    a = c.offset.top - o + c.height - u.height;
                    break;

                  case "top":
                    a = c.offset.top + o;
                    break;

                  case "center":
                    a = c.offset.top + o + c.height / 2 - u.height / 2;
                }

            }
          }

          return {
            top: a,
            left: l
          };
        }
      };

      function s(t, e, n, i, o) {
        var s,
            r,
            a,
            t = f(t);
        return t = e ? (s = (e = f(e)).height + e.offset.top - (t.offset.top + t.height), r = t.offset.top - e.offset.top, a = t.offset.left - e.offset.left, e.width + e.offset.left - (t.offset.left + t.width)) : (s = t.windowDims.height + t.windowDims.offset.top - (t.offset.top + t.height), r = t.offset.top - t.windowDims.offset.top, a = t.offset.left - t.windowDims.offset.left, t.windowDims.width - (t.offset.left + t.width)), s = o ? 0 : Math.min(s, 0), r = Math.min(r, 0), a = Math.min(a, 0), t = Math.min(t, 0), n ? a + t : i ? r + s : Math.sqrt(r * r + s * s + a * a + t * t);
      }

      function f(t) {
        if ((t = t.length ? t[0] : t) === window || t === document) throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
        var e = t.getBoundingClientRect(),
            n = t.parentNode.getBoundingClientRect(),
            i = document.body.getBoundingClientRect(),
            o = window.pageYOffset,
            t = window.pageXOffset;
        return {
          width: e.width,
          height: e.height,
          offset: {
            top: e.top + o,
            left: e.left + t
          },
          parentDims: {
            width: n.width,
            height: n.height,
            offset: {
              top: n.top + o,
              left: n.left + t
            }
          },
          windowDims: {
            width: i.width,
            height: i.height,
            offset: {
              top: o,
              left: t
            }
          }
        };
      }
    },
    "./js/foundation.util.imageLoader.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "onImagesLoaded", function () {
        return i;
      });
      var e = n("jquery"),
          o = n.n(e);

      function i(t, e) {
        var n = t.length;

        function i() {
          0 === --n && e();
        }

        0 === n && e(), t.each(function () {
          var t, n;
          this.complete && void 0 !== this.naturalWidth ? i() : (t = new Image(), n = "load.zf.images error.zf.images", o()(t).one(n, function t(e) {
            o()(this).off(n, t), i();
          }), t.src = o()(this).attr("src"));
        });
      }
    },
    "./js/foundation.util.keyboard.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Keyboard", function () {
        return u;
      });
      var e = n("jquery"),
          o = n.n(e),
          s = n("./js/foundation.core.utils.js"),
          i = {
        9: "TAB",
        13: "ENTER",
        27: "ESCAPE",
        32: "SPACE",
        35: "END",
        36: "HOME",
        37: "ARROW_LEFT",
        38: "ARROW_UP",
        39: "ARROW_RIGHT",
        40: "ARROW_DOWN"
      },
          r = {};

      function a(t) {
        return !!t && t.find("a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]").filter(function () {
          return !(!o()(this).is(":visible") || o()(this).attr("tabindex") < 0);
        }).sort(function (t, e) {
          if (o()(t).attr("tabindex") == o()(e).attr("tabindex")) return 0;
          var n = parseInt(o()(t).attr("tabindex")),
              i = parseInt(o()(e).attr("tabindex"));
          return void 0 === o()(t).attr("tabindex") && 0 < i ? 1 : void 0 === o()(e).attr("tabindex") && 0 < n ? -1 : 0 == n && 0 < i ? 1 : 0 == i && 0 < n || n < i ? -1 : i < n ? 1 : void 0;
        });
      }

      function l(t) {
        var e = (e = i[t.which || t.keyCode] || String.fromCharCode(t.which).toUpperCase()).replace(/\W+/, "");
        return t.shiftKey && (e = "SHIFT_".concat(e)), t.ctrlKey && (e = "CTRL_".concat(e)), e = (e = t.altKey ? "ALT_".concat(e) : e).replace(/_$/, "");
      }

      var u = {
        keys: function (t) {
          var e,
              n = {};

          for (e in t) n[t[e]] = t[e];

          return n;
        }(i),
        parseKey: l,
        handleKey: function (t, e, n) {
          var i = r[e],
              e = this.parseKey(t);
          if (!i) return console.warn("Component not defined!");
          !0 !== t.zfIsKeyHandled && ((e = n[(void 0 === i.ltr ? i : Object(s.rtl)() ? o.a.extend({}, i.ltr, i.rtl) : o.a.extend({}, i.rtl, i.ltr))[e]]) && "function" == typeof e ? (e = e.apply(), t.zfIsKeyHandled = !0, !n.handled && "function" != typeof n.handled || n.handled(e)) : !n.unhandled && "function" != typeof n.unhandled || n.unhandled());
        },
        findFocusable: a,
        register: function (t, e) {
          r[t] = e;
        },
        trapFocus: function (t) {
          var e = a(t),
              n = e.eq(0),
              i = e.eq(-1);
          t.on("keydown.zf.trapfocus", function (t) {
            t.target === i[0] && "TAB" === l(t) ? (t.preventDefault(), n.focus()) : t.target === n[0] && "SHIFT_TAB" === l(t) && (t.preventDefault(), i.focus());
          });
        },
        releaseFocus: function (t) {
          t.off("keydown.zf.trapfocus");
        }
      };
    },
    "./js/foundation.util.mediaQuery.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "MediaQuery", function () {
        return c;
      });
      var e = n("jquery"),
          o = n.n(e);

      function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function s(t, e) {
        return function (t) {
          if (Array.isArray(t)) return t;
        }(t) || function (t, e) {
          var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];

          if (null != n) {
            var i,
                o,
                s = [],
                r = !0,
                a = !1;

            try {
              for (n = n.call(t); !(r = (i = n.next()).done) && (s.push(i.value), !e || s.length !== e); r = !0);
            } catch (t) {
              a = !0, o = t;
            } finally {
              try {
                r || null == n.return || n.return();
              } finally {
                if (a) throw o;
              }
            }

            return s;
          }
        }(t, e) || function (t, e) {
          if (t) {
            if ("string" == typeof t) return r(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            return "Map" === (n = "Object" === n && t.constructor ? t.constructor.name : n) || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(t, e) : void 0;
          }
        }(t, e) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }

      function r(t, e) {
        (null == e || e > t.length) && (e = t.length);

        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];

        return i;
      }

      var a, l, u;
      window.matchMedia || (window.matchMedia = ((u = window.styleMedia || window.media) || (a = document.createElement("style"), e = document.getElementsByTagName("script")[0], l = null, a.type = "text/css", a.id = "matchmediajs-test", e ? e.parentNode.insertBefore(a, e) : document.head.appendChild(a), l = "getComputedStyle" in window && window.getComputedStyle(a, null) || a.currentStyle, u = {
        matchMedium: function (t) {
          t = "@media " + t + "{ #matchmediajs-test { width: 1px; } }";
          return a.styleSheet ? a.styleSheet.cssText = t : a.textContent = t, "1px" === l.width;
        }
      }), function (t) {
        return {
          matches: u.matchMedium(t || "all"),
          media: t || "all"
        };
      }));
      var c = {
        queries: [],
        current: "",
        _init: function () {
          if (!0 !== this.isInitialized) {
            this.isInitialized = !0;
            o()("meta.foundation-mq").length || o()('<meta class="foundation-mq" name="foundation-mq" content>').appendTo(document.head);
            var t,
                e,
                n,
                i = o()(".foundation-mq").css("font-family");

            for (n in e = {}, t = "string" == typeof (i = i) && (i = i.trim().slice(1, -1)) ? e = i.split("&").reduce(function (t, e) {
              var n = e.replace(/\+/g, " ").split("="),
                  e = n[0],
                  n = n[1],
                  e = decodeURIComponent(e),
                  n = void 0 === n ? null : decodeURIComponent(n);
              return t.hasOwnProperty(e) ? Array.isArray(t[e]) ? t[e].push(n) : t[e] = [t[e], n] : t[e] = n, t;
            }, {}) : e, this.queries = [], t) t.hasOwnProperty(n) && this.queries.push({
              name: n,
              value: "only screen and (min-width: ".concat(t[n], ")")
            });

            this.current = this._getCurrentSize(), this._watcher();
          }
        },
        _reInit: function () {
          this.isInitialized = !1, this._init();
        },
        atLeast: function (t) {
          t = this.get(t);
          return !!t && window.matchMedia(t).matches;
        },
        only: function (t) {
          return t === this._getCurrentSize();
        },
        upTo: function (t) {
          t = this.next(t);
          return !t || !this.atLeast(t);
        },
        is: function (t) {
          var e = s(t.trim().split(" ").filter(function (t) {
            return !!t.length;
          }), 2),
              n = e[0],
              e = e[1],
              e = void 0 === e ? "" : e;
          if ("only" === e) return this.only(n);
          if (!e || "up" === e) return this.atLeast(n);
          if ("down" === e) return this.upTo(n);
          throw new Error('\n      Invalid breakpoint passed to MediaQuery.is().\n      Expected a breakpoint name formatted like "<size> <modifier>", got "'.concat(t, '".\n    '));
        },
        get: function (t) {
          for (var e in this.queries) if (this.queries.hasOwnProperty(e)) {
            e = this.queries[e];
            if (t === e.name) return e.value;
          }

          return null;
        },
        next: function (e) {
          var n = this,
              t = this.queries.findIndex(function (t) {
            return n._getQueryName(t) === e;
          });
          if (-1 === t) throw new Error('\n        Unknown breakpoint "'.concat(e, '" passed to MediaQuery.next().\n        Ensure it is present in your Sass "$breakpoints" setting.\n      '));
          t = this.queries[t + 1];
          return t ? t.name : null;
        },
        _getQueryName: function (t) {
          if ("string" == typeof t) return t;
          if ("object" === i(t)) return t.name;
          throw new TypeError('\n      Invalid value passed to MediaQuery._getQueryName().\n      Expected a breakpoint name (String) or a breakpoint query (Object), got "'.concat(t, '" (').concat(i(t), ")\n    "));
        },
        _getCurrentSize: function () {
          for (var t, e = 0; e < this.queries.length; e++) {
            var n = this.queries[e];
            window.matchMedia(n.value).matches && (t = n);
          }

          return t && this._getQueryName(t);
        },
        _watcher: function () {
          var n = this;
          o()(window).off("resize.zf.mediaquery").on("resize.zf.mediaquery", function () {
            var t = n._getCurrentSize(),
                e = n.current;

            t !== e && (n.current = t, o()(window).trigger("changed.zf.mediaquery", [t, e]));
          });
        }
      };
    },
    "./js/foundation.util.motion.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Move", function () {
        return o;
      }), n.d(e, "Motion", function () {
        return i;
      });
      var e = n("jquery"),
          a = n.n(e),
          l = n("./js/foundation.core.utils.js"),
          u = ["mui-enter", "mui-leave"],
          c = ["mui-enter-active", "mui-leave-active"],
          i = {
        animateIn: function (t, e, n) {
          s(!0, t, e, n);
        },
        animateOut: function (t, e, n) {
          s(!1, t, e, n);
        }
      };

      function o(n, i, o) {
        var s,
            r,
            a = null;
        if (0 === n) return o.apply(i), void i.trigger("finished.zf.animate", [i]).triggerHandler("finished.zf.animate", [i]);
        s = window.requestAnimationFrame(function t(e) {
          r = e - (a = a || e), o.apply(i), r < n ? s = window.requestAnimationFrame(t, i) : (window.cancelAnimationFrame(s), i.trigger("finished.zf.animate", [i]).triggerHandler("finished.zf.animate", [i]));
        });
      }

      function s(t, e, n, i) {
        var o, s;

        function r() {
          e[0].style.transitionDuration = 0, e.removeClass("".concat(o, " ").concat(s, " ").concat(n));
        }

        (e = a()(e).eq(0)).length && (o = t ? u[0] : u[1], s = t ? c[0] : c[1], r(), e.addClass(n).css("transition", "none"), requestAnimationFrame(function () {
          e.addClass(o), t && e.show();
        }), requestAnimationFrame(function () {
          e[0].offsetWidth, e.css("transition", "").addClass(s);
        }), e.one(Object(l.transitionend)(e), function () {
          t || e.hide();
          r(), i && i.apply(e);
        }));
      }
    },
    "./js/foundation.util.nest.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Nest", function () {
        return i;
      });
      var e = n("jquery"),
          a = n.n(e),
          i = {
        Feather: function (t) {
          var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "zf";
          t.attr("role", "menubar"), t.find("a").attr({
            role: "menuitem"
          });
          var t = t.find("li").attr({
            role: "none"
          }),
              i = "is-".concat(n, "-submenu"),
              o = "".concat(i, "-item"),
              s = "is-".concat(n, "-submenu-parent"),
              r = "accordion" !== n;
          t.each(function () {
            var t = a()(this),
                e = t.children("ul");
            e.length && (t.addClass(s), r && (t.children("a:first").attr({
              "aria-haspopup": !0,
              "aria-label": t.children("a:first").text()
            }), "drilldown" === n && t.attr({
              "aria-expanded": !1
            })), e.addClass("submenu ".concat(i)).attr({
              "data-submenu": "",
              role: "menubar"
            }), "drilldown" === n && e.attr({
              "aria-hidden": !0
            })), t.parent("[data-submenu]").length && t.addClass("is-submenu-item ".concat(o));
          });
        },
        Burn: function (t, e) {
          var n = "is-".concat(e, "-submenu"),
              i = "".concat(n, "-item"),
              e = "is-".concat(e, "-submenu-parent");
          t.find(">li, > li > ul, .menu, .menu > li, [data-submenu] > li").removeClass("".concat(n, " ").concat(i, " ").concat(e, " is-submenu-item submenu is-active")).removeAttr("data-submenu").css("display", "");
        }
      };
    },
    "./js/foundation.util.timer.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Timer", function () {
        return i;
      });
      n("jquery");

      function i(e, t, n) {
        var i,
            o,
            s = this,
            r = t.duration,
            a = Object.keys(e.data())[0] || "timer",
            l = -1;
        this.isPaused = !1, this.restart = function () {
          l = -1, clearTimeout(o), this.start();
        }, this.start = function () {
          this.isPaused = !1, clearTimeout(o), l = l <= 0 ? r : l, e.data("paused", !1), i = Date.now(), o = setTimeout(function () {
            t.infinite && s.restart(), n && "function" == typeof n && n();
          }, l), e.trigger("timerstart.zf.".concat(a));
        }, this.pause = function () {
          this.isPaused = !0, clearTimeout(o), e.data("paused", !0);
          var t = Date.now();
          l -= t - i, e.trigger("timerpaused.zf.".concat(a));
        };
      }
    },
    "./js/foundation.util.touch.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Touch", function () {
        return u;
      });
      var e = n("jquery"),
          i = n.n(e);

      function o(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      var s,
          r,
          a,
          l,
          u = {},
          c = !1,
          f = !1;

      function d(t) {
        this.removeEventListener("touchmove", h), this.removeEventListener("touchend", d), f || (t = i.a.Event("tap", l || t), i()(this).trigger(t)), l = null, f = c = !1;
      }

      function h(t) {
        var e, n;
        !0 === i.a.spotSwipe.preventDefault && t.preventDefault(), c && (e = t.touches[0].pageX, e = s - e, f = !0, a = new Date().getTime() - r, (n = Math.abs(e) >= i.a.spotSwipe.moveThreshold && a <= i.a.spotSwipe.timeThreshold ? 0 < e ? "left" : "right" : n) && (t.preventDefault(), d.apply(this, arguments), i()(this).trigger(i.a.Event("swipe", Object.assign({}, t)), n).trigger(i.a.Event("swipe".concat(n), Object.assign({}, t)))));
      }

      function p(t) {
        1 === t.touches.length && (s = t.touches[0].pageX, t.touches[0].pageY, l = t, f = !(c = !0), r = new Date().getTime(), this.addEventListener("touchmove", h, {
          passive: !0 === i.a.spotSwipe.preventDefault
        }), this.addEventListener("touchend", d, !1));
      }

      function m() {
        this.addEventListener && this.addEventListener("touchstart", p, {
          passive: !0
        });
      }

      var v = function () {
        function e(t) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, e), this.version = "1.0.0", this.enabled = "ontouchstart" in document.documentElement, this.preventDefault = !1, this.moveThreshold = 75, this.timeThreshold = 200, this.$ = t, this._init();
        }

        var t, n, i;
        return t = e, (n = [{
          key: "_init",
          value: function () {
            var t = this.$;
            t.event.special.swipe = {
              setup: m
            }, t.event.special.tap = {
              setup: m
            }, t.each(["left", "up", "down", "right"], function () {
              t.event.special["swipe".concat(this)] = {
                setup: function () {
                  t(this).on("swipe", t.noop);
                }
              };
            });
          }
        }]) && o(t.prototype, n), i && o(t, i), e;
      }();

      u.setupSpotSwipe = function (t) {
        t.spotSwipe = new v(t);
      }, u.setupTouchHandler = function (i) {
        i.fn.addTouch = function () {
          this.each(function (t, e) {
            i(e).bind("touchstart touchmove touchend touchcancel", function (t) {
              n(t);
            });
          });

          var n = function (t) {
            var e,
                n = t.changedTouches[0],
                t = {
              touchstart: "mousedown",
              touchmove: "mousemove",
              touchend: "mouseup"
            }[t.type];
            "MouseEvent" in window && "function" == typeof window.MouseEvent ? e = new window.MouseEvent(t, {
              bubbles: !0,
              cancelable: !0,
              screenX: n.screenX,
              screenY: n.screenY,
              clientX: n.clientX,
              clientY: n.clientY
            }) : (e = document.createEvent("MouseEvent")).initMouseEvent(t, !0, !0, window, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(e);
          };
        };
      }, u.init = function (t) {
        void 0 === t.spotSwipe && (u.setupSpotSwipe(t), u.setupTouchHandler(t));
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Triggers", function () {
        return u;
      });
      var e = n("jquery"),
          s = n.n(e),
          i = n("./js/foundation.core.utils.js"),
          o = n("./js/foundation.util.motion.js");

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(e, n) {
        e.data(n).split(" ").forEach(function (t) {
          s()("#".concat(t))["close" === n ? "trigger" : "triggerHandler"]("".concat(n, ".zf.trigger"), [e]);
        });
      }

      var l = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          u = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function c(e, t, n) {
        var i,
            o = Array.prototype.slice.call(arguments, 3);
        s()(window).off(t).on(t, function (t) {
          i && clearTimeout(i), i = setTimeout(function () {
            n.apply(null, o);
          }, e || 10);
        });
      }

      u.Listeners.Basic = {
        openListener: function () {
          a(s()(this), "open");
        },
        closeListener: function () {
          s()(this).data("close") ? a(s()(this), "close") : s()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          s()(this).data("toggle") ? a(s()(this), "toggle") : s()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = s()(this).data("closable");
          t.stopPropagation(), "" !== e ? o.Motion.animateOut(s()(this), e, function () {
            s()(this).trigger("closed.zf");
          }) : s()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = s()(this).data("toggle-focus");
          s()("#".concat(t)).triggerHandler("toggle.zf.trigger", [s()(this)]);
        }
      }, u.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", u.Listeners.Basic.openListener);
      }, u.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", u.Listeners.Basic.closeListener);
      }, u.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", u.Listeners.Basic.toggleListener);
      }, u.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", u.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", u.Listeners.Basic.closeableListener);
      }, u.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", u.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", u.Listeners.Basic.toggleFocusListener);
      }, u.Listeners.Global = {
        resizeListener: function (t) {
          l || t.each(function () {
            s()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          l || t.each(function () {
            s()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          s()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = s()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, u.Initializers.addClosemeListener = function (t) {
        var e = s()("[data-yeti-box]"),
            n = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? n.push(t) : "object" === r(t) && "string" == typeof t[0] ? n = n.concat(t) : console.error("Plugin names must be strings")), e.length && (n = n.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), s()(window).off(n).on(n, u.Listeners.Global.closeMeListener));
      }, u.Initializers.addResizeListener = function (t) {
        var e = s()("[data-resize]");
        e.length && c(t, "resize.zf.trigger", u.Listeners.Global.resizeListener, e);
      }, u.Initializers.addScrollListener = function (t) {
        var e = s()("[data-scroll]");
        e.length && c(t, "scroll.zf.trigger", u.Listeners.Global.scrollListener, e);
      }, u.Initializers.addMutationEventsListener = function (t) {
        if (!l) return !1;

        function e(t) {
          var e = s()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var n = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (n.length) for (var i = 0; i <= n.length - 1; i++) new l(e).observe(n[i], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, u.Initializers.addSimpleListeners = function () {
        var t = s()(document);
        u.Initializers.addOpenListener(t), u.Initializers.addCloseListener(t), u.Initializers.addToggleListener(t), u.Initializers.addCloseableListener(t), u.Initializers.addToggleFocusListener(t);
      }, u.Initializers.addGlobalListeners = function () {
        var t = s()(document);
        u.Initializers.addMutationEventsListener(t), u.Initializers.addResizeListener(), u.Initializers.addScrollListener(), u.Initializers.addClosemeListener();
      }, u.init = function (t, e) {
        Object(i.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (u.Initializers.addSimpleListeners(), u.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = u, e.IHearYou = u.Initializers.addGlobalListeners);
      };
    },
    0: function (t, e, n) {
      t.exports = n("./js/entries/foundation.js");
    },
    jquery: function (t, e) {
      t.exports = n;
    }
  }, s = {}, o.m = i, o.c = s, o.d = function (t, e, n) {
    o.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, o.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, o.t = function (e, t) {
    if (1 & t && (e = o(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (o.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var i in e) o.d(n, i, function (t) {
      return e[t];
    }.bind(null, i));
    return n;
  }, o.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return o.d(e, "a", e), e;
  }, o.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, o.p = "", o(o.s = 0);

  function o(t) {
    if (s[t]) return s[t].exports;
    var e = s[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return i[t].call(e.exports, e, e.exports, o), e.l = !0, e.exports;
  }

  var i, s;
});
!function (t, n) {
  "object" == typeof exports && "object" == typeof module ? module.exports = n(require("jquery")) : "function" == typeof define && define.amd ? define(["jquery"], n) : "object" == typeof exports ? exports["foundation.core"] = n(require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.core"] = n(t.jQuery));
}(window, function (e) {
  return r = {
    "./js/entries/plugins/foundation.core.js": function (t, n, e) {
      "use strict";

      e.r(n);
      var r = e("jquery"),
          r = e.n(r),
          i = e("./js/foundation.core.js");
      e.d(n, "Foundation", function () {
        return i.Foundation;
      });
      var o = e("./js/foundation.core.plugin.js"),
          a = e("./js/foundation.core.utils.js");
      e.d(n, "Plugin", function () {
        return o.Plugin;
      }), e.d(n, "rtl", function () {
        return a.rtl;
      }), e.d(n, "GetYoDigits", function () {
        return a.GetYoDigits;
      }), e.d(n, "RegExpEscape", function () {
        return a.RegExpEscape;
      }), e.d(n, "transitionend", function () {
        return a.transitionend;
      }), e.d(n, "onLoad", function () {
        return a.onLoad;
      }), e.d(n, "ignoreMousedisappear", function () {
        return a.ignoreMousedisappear;
      }), i.Foundation.addToJquery(r.a), i.Foundation.Plugin = o.Plugin, i.Foundation.rtl = a.rtl, i.Foundation.GetYoDigits = a.GetYoDigits, i.Foundation.transitionend = a.transitionend, i.Foundation.RegExpEscape = a.RegExpEscape, i.Foundation.onLoad = a.onLoad, window.Foundation = i.Foundation;
    },
    "./js/foundation.core.js": function (t, n, e) {
      "use strict";

      e.r(n), e.d(n, "Foundation", function () {
        return s;
      });
      var n = e("jquery"),
          o = e.n(n),
          r = e("./js/foundation.core.utils.js"),
          a = e("./js/foundation.util.mediaQuery.js");

      function u(t) {
        return (u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      var s = {
        version: "6.7.3",
        _plugins: {},
        _uuids: [],
        plugin: function (t, n) {
          var e = n || c(t),
              n = i(e);
          this._plugins[n] = this[e] = t;
        },
        registerPlugin: function (t, n) {
          n = n ? i(n) : c(t.constructor).toLowerCase();
          t.uuid = Object(r.GetYoDigits)(6, n), t.$element.attr("data-".concat(n)) || t.$element.attr("data-".concat(n), t.uuid), t.$element.data("zfPlugin") || t.$element.data("zfPlugin", t), t.$element.trigger("init.zf.".concat(n)), this._uuids.push(t.uuid);
        },
        unregisterPlugin: function (t) {
          var n,
              e = i(c(t.$element.data("zfPlugin").constructor));

          for (n in this._uuids.splice(this._uuids.indexOf(t.uuid), 1), t.$element.removeAttr("data-".concat(e)).removeData("zfPlugin").trigger("destroyed.zf.".concat(e)), t) t[n] = null;
        },
        reInit: function (t) {
          var n,
              e,
              r = t instanceof o.a;

          try {
            r ? t.each(function () {
              o()(this).data("zfPlugin")._init();
            }) : (n = u(t), e = this, {
              object: function (t) {
                t.forEach(function (t) {
                  t = i(t), o()("[data-" + t + "]").foundation("_init");
                });
              },
              string: function () {
                t = i(t), o()("[data-" + t + "]").foundation("_init");
              },
              undefined: function () {
                this.object(Object.keys(e._plugins));
              }
            }[n](t));
          } catch (t) {
            console.error(t);
          } finally {
            return t;
          }
        },
        reflow: function (e, t) {
          void 0 === t ? t = Object.keys(this._plugins) : "string" == typeof t && (t = [t]);
          var i = this;
          o.a.each(t, function (t, n) {
            var r = i._plugins[n];
            o()(e).find("[data-" + n + "]").addBack("[data-" + n + "]").filter(function () {
              return void 0 === o()(this).data("zfPlugin");
            }).each(function () {
              var t = o()(this),
                  e = {
                reflow: !0
              };
              t.attr("data-options") && t.attr("data-options").split(";").forEach(function (t, n) {
                t = t.split(":").map(function (t) {
                  return t.trim();
                });
                t[0] && (e[t[0]] = function (t) {
                  {
                    if ("true" === t) return !0;
                    if ("false" === t) return !1;
                    if (!isNaN(+t)) return parseFloat(t);
                  }
                  return t;
                }(t[1]));
              });

              try {
                t.data("zfPlugin", new r(o()(this), e));
              } catch (t) {
                console.error(t);
              } finally {
                return;
              }
            });
          });
        },
        getFnName: c,
        addToJquery: function (o) {
          return o.fn.foundation = function (e) {
            var t = u(e),
                n = o(".no-js");
            if (n.length && n.removeClass("no-js"), "undefined" === t) a.MediaQuery._init(), s.reflow(this);else {
              if ("string" !== t) throw new TypeError("We're sorry, ".concat(t, " is not a valid parameter. You must use a string representing the method you wish to invoke."));
              var r = Array.prototype.slice.call(arguments, 1),
                  i = this.data("zfPlugin");
              if (void 0 === i || void 0 === i[e]) throw new ReferenceError("We're sorry, '" + e + "' is not an available method for " + (i ? c(i) : "this element") + ".");
              1 === this.length ? i[e].apply(i, r) : this.each(function (t, n) {
                i[e].apply(o(n).data("zfPlugin"), r);
              });
            }
            return this;
          }, o;
        }
      };

      function c(t) {
        if (void 0 !== Function.prototype.name) return (void 0 === t.prototype ? t : t.prototype).constructor.name;
        t = /function\s([^(]{1,})\(/.exec(t.toString());
        return t && 1 < t.length ? t[1].trim() : "";
      }

      function i(t) {
        return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }

      s.util = {
        throttle: function (e, r) {
          var i = null;
          return function () {
            var t = this,
                n = arguments;
            null === i && (i = setTimeout(function () {
              e.apply(t, n), i = null;
            }, r));
          };
        }
      }, window.Foundation = s, function () {
        Date.now && window.Date.now || (window.Date.now = Date.now = function () {
          return new Date().getTime();
        });

        for (var r, t = ["webkit", "moz"], n = 0; n < t.length && !window.requestAnimationFrame; ++n) {
          var e = t[n];
          window.requestAnimationFrame = window[e + "RequestAnimationFrame"], window.cancelAnimationFrame = window[e + "CancelAnimationFrame"] || window[e + "CancelRequestAnimationFrame"];
        }

        !/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) && window.requestAnimationFrame && window.cancelAnimationFrame || (r = 0, window.requestAnimationFrame = function (t) {
          var n = Date.now(),
              e = Math.max(r + 16, n);
          return setTimeout(function () {
            t(r = e);
          }, e - n);
        }, window.cancelAnimationFrame = clearTimeout), window.performance && window.performance.now || (window.performance = {
          start: Date.now(),
          now: function () {
            return Date.now() - this.start;
          }
        });
      }(), Function.prototype.bind || (Function.prototype.bind = function (t) {
        if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");

        function n() {
          return r.apply(this instanceof i ? this : t, e.concat(Array.prototype.slice.call(arguments)));
        }

        var e = Array.prototype.slice.call(arguments, 1),
            r = this,
            i = function () {};

        return this.prototype && (i.prototype = this.prototype), n.prototype = new i(), n;
      });
    },
    "./js/foundation.core.plugin.js": function (t, n, e) {
      "use strict";

      e.r(n), e.d(n, "Plugin", function () {
        return r;
      });
      var n = e("jquery"),
          i = e("./js/foundation.core.utils.js");

      function o(t, n) {
        for (var e = 0; e < n.length; e++) {
          var r = n[e];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
        }
      }

      var r = function () {
        function e(t, n) {
          !function (t, n) {
            if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function");
          }(this, e), this._setup(t, n);
          n = a(this);
          this.uuid = Object(i.GetYoDigits)(6, n), this.$element.attr("data-".concat(n)) || this.$element.attr("data-".concat(n), this.uuid), this.$element.data("zfPlugin") || this.$element.data("zfPlugin", this), this.$element.trigger("init.zf.".concat(n));
        }

        var t, n, r;
        return t = e, (n = [{
          key: "destroy",
          value: function () {
            this._destroy();

            var t,
                n = a(this);

            for (t in this.$element.removeAttr("data-".concat(n)).removeData("zfPlugin").trigger("destroyed.zf.".concat(n)), this) this[t] = null;
          }
        }]) && o(t.prototype, n), r && o(t, r), e;
      }();

      function a(t) {
        return t.className.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
    },
    "./js/foundation.core.utils.js": function (t, n, e) {
      "use strict";

      e.r(n), e.d(n, "rtl", function () {
        return r;
      }), e.d(n, "GetYoDigits", function () {
        return i;
      }), e.d(n, "RegExpEscape", function () {
        return o;
      }), e.d(n, "transitionend", function () {
        return a;
      }), e.d(n, "onLoad", function () {
        return u;
      }), e.d(n, "ignoreMousedisappear", function () {
        return c;
      });
      var n = e("jquery"),
          s = e.n(n);

      function r() {
        return "rtl" === s()("html").attr("dir");
      }

      function i() {
        for (var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 6, n = 1 < arguments.length ? arguments[1] : void 0, e = "", r = "0123456789abcdefghijklmnopqrstuvwxyz", i = r.length, o = 0; o < t; o++) e += r[Math.floor(Math.random() * i)];

        return n ? "".concat(e, "-").concat(n) : e;
      }

      function o(t) {
        return t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      function a(t) {
        var n,
            e,
            r = {
          transition: "transitionend",
          WebkitTransition: "webkitTransitionEnd",
          MozTransition: "transitionend",
          OTransition: "otransitionend"
        },
            i = document.createElement("div");

        for (e in r) void 0 !== i.style[e] && (n = r[e]);

        return n || (setTimeout(function () {
          t.triggerHandler("transitionend", [t]);
        }, 1), "transitionend");
      }

      function u(t, n) {
        function e() {
          return t.triggerHandler(i);
        }

        var r = "complete" === document.readyState,
            i = (r ? "_didLoad" : "load") + ".zf.util.onLoad";
        return t && (n && t.one(i, n), r ? setTimeout(e) : s()(window).one("load", e)), i;
      }

      function c(o) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
            n = t.ignoreLeaveWindow,
            a = void 0 !== n && n,
            t = t.ignoreReappear,
            u = void 0 !== t && t;
        return function (n) {
          for (var t = arguments.length, e = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) e[r - 1] = arguments[r];

          var i = o.bind.apply(o, [this, n].concat(e));
          if (null !== n.relatedTarget) return i();
          setTimeout(function () {
            return a || !document.hasFocus || document.hasFocus() ? void (u || s()(document).one("mouseenter", function (t) {
              s()(n.currentTarget).has(t.target).length || (n.relatedTarget = t.target, i());
            })) : i();
          }, 0);
        };
      }
    },
    "./js/foundation.util.mediaQuery.js": function (t, n, e) {
      "use strict";

      e.r(n), e.d(n, "MediaQuery", function () {
        return d;
      });
      var n = e("jquery"),
          i = e.n(n);

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function o(t, n) {
        return function (t) {
          if (Array.isArray(t)) return t;
        }(t) || function (t, n) {
          var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];

          if (null != e) {
            var r,
                i,
                o = [],
                a = !0,
                u = !1;

            try {
              for (e = e.call(t); !(a = (r = e.next()).done) && (o.push(r.value), !n || o.length !== n); a = !0);
            } catch (t) {
              u = !0, i = t;
            } finally {
              try {
                a || null == e.return || e.return();
              } finally {
                if (u) throw i;
              }
            }

            return o;
          }
        }(t, n) || function (t, n) {
          if (t) {
            if ("string" == typeof t) return a(t, n);
            var e = Object.prototype.toString.call(t).slice(8, -1);
            return "Map" === (e = "Object" === e && t.constructor ? t.constructor.name : e) || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? a(t, n) : void 0;
          }
        }(t, n) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }

      function a(t, n) {
        (null == n || n > t.length) && (n = t.length);

        for (var e = 0, r = new Array(n); e < n; e++) r[e] = t[e];

        return r;
      }

      var u, s, c;
      window.matchMedia || (window.matchMedia = ((c = window.styleMedia || window.media) || (u = document.createElement("style"), n = document.getElementsByTagName("script")[0], s = null, u.type = "text/css", u.id = "matchmediajs-test", n ? n.parentNode.insertBefore(u, n) : document.head.appendChild(u), s = "getComputedStyle" in window && window.getComputedStyle(u, null) || u.currentStyle, c = {
        matchMedium: function (t) {
          t = "@media " + t + "{ #matchmediajs-test { width: 1px; } }";
          return u.styleSheet ? u.styleSheet.cssText = t : u.textContent = t, "1px" === s.width;
        }
      }), function (t) {
        return {
          matches: c.matchMedium(t || "all"),
          media: t || "all"
        };
      }));
      var d = {
        queries: [],
        current: "",
        _init: function () {
          if (!0 !== this.isInitialized) {
            this.isInitialized = !0;
            i()("meta.foundation-mq").length || i()('<meta class="foundation-mq" name="foundation-mq" content>').appendTo(document.head);
            var t,
                n,
                e,
                r = i()(".foundation-mq").css("font-family");

            for (e in n = {}, t = "string" == typeof (r = r) && (r = r.trim().slice(1, -1)) ? n = r.split("&").reduce(function (t, n) {
              var e = n.replace(/\+/g, " ").split("="),
                  n = e[0],
                  e = e[1],
                  n = decodeURIComponent(n),
                  e = void 0 === e ? null : decodeURIComponent(e);
              return t.hasOwnProperty(n) ? Array.isArray(t[n]) ? t[n].push(e) : t[n] = [t[n], e] : t[n] = e, t;
            }, {}) : n, this.queries = [], t) t.hasOwnProperty(e) && this.queries.push({
              name: e,
              value: "only screen and (min-width: ".concat(t[e], ")")
            });

            this.current = this._getCurrentSize(), this._watcher();
          }
        },
        _reInit: function () {
          this.isInitialized = !1, this._init();
        },
        atLeast: function (t) {
          t = this.get(t);
          return !!t && window.matchMedia(t).matches;
        },
        only: function (t) {
          return t === this._getCurrentSize();
        },
        upTo: function (t) {
          t = this.next(t);
          return !t || !this.atLeast(t);
        },
        is: function (t) {
          var n = o(t.trim().split(" ").filter(function (t) {
            return !!t.length;
          }), 2),
              e = n[0],
              n = n[1],
              n = void 0 === n ? "" : n;
          if ("only" === n) return this.only(e);
          if (!n || "up" === n) return this.atLeast(e);
          if ("down" === n) return this.upTo(e);
          throw new Error('\n      Invalid breakpoint passed to MediaQuery.is().\n      Expected a breakpoint name formatted like "<size> <modifier>", got "'.concat(t, '".\n    '));
        },
        get: function (t) {
          for (var n in this.queries) if (this.queries.hasOwnProperty(n)) {
            n = this.queries[n];
            if (t === n.name) return n.value;
          }

          return null;
        },
        next: function (n) {
          var e = this,
              t = this.queries.findIndex(function (t) {
            return e._getQueryName(t) === n;
          });
          if (-1 === t) throw new Error('\n        Unknown breakpoint "'.concat(n, '" passed to MediaQuery.next().\n        Ensure it is present in your Sass "$breakpoints" setting.\n      '));
          t = this.queries[t + 1];
          return t ? t.name : null;
        },
        _getQueryName: function (t) {
          if ("string" == typeof t) return t;
          if ("object" === r(t)) return t.name;
          throw new TypeError('\n      Invalid value passed to MediaQuery._getQueryName().\n      Expected a breakpoint name (String) or a breakpoint query (Object), got "'.concat(t, '" (').concat(r(t), ")\n    "));
        },
        _getCurrentSize: function () {
          for (var t, n = 0; n < this.queries.length; n++) {
            var e = this.queries[n];
            window.matchMedia(e.value).matches && (t = e);
          }

          return t && this._getQueryName(t);
        },
        _watcher: function () {
          var e = this;
          i()(window).off("resize.zf.mediaquery").on("resize.zf.mediaquery", function () {
            var t = e._getCurrentSize(),
                n = e.current;

            t !== n && (e.current = t, i()(window).trigger("changed.zf.mediaquery", [t, n]));
          });
        }
      };
    },
    0: function (t, n, e) {
      t.exports = e("./js/entries/plugins/foundation.core.js");
    },
    jquery: function (t, n) {
      t.exports = e;
    }
  }, o = {}, i.m = r, i.c = o, i.d = function (t, n, e) {
    i.o(t, n) || Object.defineProperty(t, n, {
      enumerable: !0,
      get: e
    });
  }, i.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, i.t = function (n, t) {
    if (1 & t && (n = i(n)), 8 & t) return n;
    if (4 & t && "object" == typeof n && n && n.__esModule) return n;
    var e = Object.create(null);
    if (i.r(e), Object.defineProperty(e, "default", {
      enumerable: !0,
      value: n
    }), 2 & t && "string" != typeof n) for (var r in n) i.d(e, r, function (t) {
      return n[t];
    }.bind(null, r));
    return e;
  }, i.n = function (t) {
    var n = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return i.d(n, "a", n), n;
  }, i.o = function (t, n) {
    return Object.prototype.hasOwnProperty.call(t, n);
  }, i.p = "", i(i.s = 0);

  function i(t) {
    if (o[t]) return o[t].exports;
    var n = o[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return r[t].call(n.exports, n, n.exports, i), n.l = !0, n.exports;
  }

  var r, o;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], t) : "object" == typeof exports ? exports["foundation.util.mediaQuery"] = t(require("./foundation.core"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.jQuery));
}(window, function (n, r) {
  return o = {
    "./foundation.core": function (e, t) {
      e.exports = n;
    },
    "./js/entries/plugins/foundation.util.mediaQuery.js": function (e, t, n) {
      "use strict";

      n.r(t);
      var r = n("./foundation.core");
      n.d(t, "Foundation", function () {
        return r.Foundation;
      });
      var i = n("./js/foundation.util.mediaQuery.js");
      n.d(t, "MediaQuery", function () {
        return i.MediaQuery;
      }), r.Foundation.MediaQuery = i.MediaQuery, r.Foundation.MediaQuery._init();
    },
    "./js/foundation.util.mediaQuery.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "MediaQuery", function () {
        return d;
      });
      var t = n("jquery"),
          i = n.n(t);

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function o(e, t) {
        return function (e) {
          if (Array.isArray(e)) return e;
        }(e) || function (e, t) {
          var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];

          if (null != n) {
            var r,
                i,
                o = [],
                u = !0,
                a = !1;

            try {
              for (n = n.call(e); !(u = (r = n.next()).done) && (o.push(r.value), !t || o.length !== t); u = !0);
            } catch (e) {
              a = !0, i = e;
            } finally {
              try {
                u || null == n.return || n.return();
              } finally {
                if (a) throw i;
              }
            }

            return o;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if ("string" == typeof e) return u(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            return "Map" === (n = "Object" === n && e.constructor ? e.constructor.name : n) || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? u(e, t) : void 0;
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }

      function u(e, t) {
        (null == t || t > e.length) && (t = e.length);

        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];

        return r;
      }

      var a, s, c;
      window.matchMedia || (window.matchMedia = ((c = window.styleMedia || window.media) || (a = document.createElement("style"), t = document.getElementsByTagName("script")[0], s = null, a.type = "text/css", a.id = "matchmediajs-test", t ? t.parentNode.insertBefore(a, t) : document.head.appendChild(a), s = "getComputedStyle" in window && window.getComputedStyle(a, null) || a.currentStyle, c = {
        matchMedium: function (e) {
          e = "@media " + e + "{ #matchmediajs-test { width: 1px; } }";
          return a.styleSheet ? a.styleSheet.cssText = e : a.textContent = e, "1px" === s.width;
        }
      }), function (e) {
        return {
          matches: c.matchMedium(e || "all"),
          media: e || "all"
        };
      }));
      var d = {
        queries: [],
        current: "",
        _init: function () {
          if (!0 !== this.isInitialized) {
            this.isInitialized = !0;
            i()("meta.foundation-mq").length || i()('<meta class="foundation-mq" name="foundation-mq" content>').appendTo(document.head);
            var e,
                t,
                n,
                r = i()(".foundation-mq").css("font-family");

            for (n in t = {}, e = "string" == typeof (r = r) && (r = r.trim().slice(1, -1)) ? t = r.split("&").reduce(function (e, t) {
              var n = t.replace(/\+/g, " ").split("="),
                  t = n[0],
                  n = n[1],
                  t = decodeURIComponent(t),
                  n = void 0 === n ? null : decodeURIComponent(n);
              return e.hasOwnProperty(t) ? Array.isArray(e[t]) ? e[t].push(n) : e[t] = [e[t], n] : e[t] = n, e;
            }, {}) : t, this.queries = [], e) e.hasOwnProperty(n) && this.queries.push({
              name: n,
              value: "only screen and (min-width: ".concat(e[n], ")")
            });

            this.current = this._getCurrentSize(), this._watcher();
          }
        },
        _reInit: function () {
          this.isInitialized = !1, this._init();
        },
        atLeast: function (e) {
          e = this.get(e);
          return !!e && window.matchMedia(e).matches;
        },
        only: function (e) {
          return e === this._getCurrentSize();
        },
        upTo: function (e) {
          e = this.next(e);
          return !e || !this.atLeast(e);
        },
        is: function (e) {
          var t = o(e.trim().split(" ").filter(function (e) {
            return !!e.length;
          }), 2),
              n = t[0],
              t = t[1],
              t = void 0 === t ? "" : t;
          if ("only" === t) return this.only(n);
          if (!t || "up" === t) return this.atLeast(n);
          if ("down" === t) return this.upTo(n);
          throw new Error('\n      Invalid breakpoint passed to MediaQuery.is().\n      Expected a breakpoint name formatted like "<size> <modifier>", got "'.concat(e, '".\n    '));
        },
        get: function (e) {
          for (var t in this.queries) if (this.queries.hasOwnProperty(t)) {
            t = this.queries[t];
            if (e === t.name) return t.value;
          }

          return null;
        },
        next: function (t) {
          var n = this,
              e = this.queries.findIndex(function (e) {
            return n._getQueryName(e) === t;
          });
          if (-1 === e) throw new Error('\n        Unknown breakpoint "'.concat(t, '" passed to MediaQuery.next().\n        Ensure it is present in your Sass "$breakpoints" setting.\n      '));
          e = this.queries[e + 1];
          return e ? e.name : null;
        },
        _getQueryName: function (e) {
          if ("string" == typeof e) return e;
          if ("object" === r(e)) return e.name;
          throw new TypeError('\n      Invalid value passed to MediaQuery._getQueryName().\n      Expected a breakpoint name (String) or a breakpoint query (Object), got "'.concat(e, '" (').concat(r(e), ")\n    "));
        },
        _getCurrentSize: function () {
          for (var e, t = 0; t < this.queries.length; t++) {
            var n = this.queries[t];
            window.matchMedia(n.value).matches && (e = n);
          }

          return e && this._getQueryName(e);
        },
        _watcher: function () {
          var n = this;
          i()(window).off("resize.zf.mediaquery").on("resize.zf.mediaquery", function () {
            var e = n._getCurrentSize(),
                t = n.current;

            e !== t && (n.current = e, i()(window).trigger("changed.zf.mediaquery", [e, t]));
          });
        }
      };
    },
    24: function (e, t, n) {
      e.exports = n("./js/entries/plugins/foundation.util.mediaQuery.js");
    },
    jquery: function (e, t) {
      e.exports = r;
    }
  }, u = {}, i.m = o, i.c = u, i.d = function (e, t, n) {
    i.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    });
  }, i.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, i.t = function (t, e) {
    if (1 & e && (t = i(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (i.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var r in t) i.d(n, r, function (e) {
      return t[e];
    }.bind(null, r));
    return n;
  }, i.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return i.d(t, "a", t), t;
  }, i.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, i.p = "", i(i.s = 24);

  function i(e) {
    if (u[e]) return u[e].exports;
    var t = u[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return o[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
  }

  var o, u;
});
!function (n, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], t) : "object" == typeof exports ? exports["foundation.util.motion"] = t(require("./foundation.core"), require("jquery")) : (n.__FOUNDATION_EXTERNAL__ = n.__FOUNDATION_EXTERNAL__ || {}, n.__FOUNDATION_EXTERNAL__["foundation.util.motion"] = t(n.__FOUNDATION_EXTERNAL__["foundation.core"], n.jQuery));
}(window, function (e, o) {
  return r = {
    "./foundation.core": function (n, t) {
      n.exports = e;
    },
    "./js/entries/plugins/foundation.util.motion.js": function (n, t, e) {
      "use strict";

      e.r(t);
      var o = e("./foundation.core");
      e.d(t, "Foundation", function () {
        return o.Foundation;
      });
      var i = e("./js/foundation.util.motion.js");
      e.d(t, "Motion", function () {
        return i.Motion;
      }), e.d(t, "Move", function () {
        return i.Move;
      }), o.Foundation.Motion = i.Motion, o.Foundation.Move = i.Move;
    },
    "./js/foundation.util.motion.js": function (n, t, e) {
      "use strict";

      e.r(t), e.d(t, "Move", function () {
        return i;
      }), e.d(t, "Motion", function () {
        return o;
      });
      var t = e("jquery"),
          a = e.n(t),
          f = e("./foundation.core"),
          c = ["mui-enter", "mui-leave"],
          d = ["mui-enter-active", "mui-leave-active"],
          o = {
        animateIn: function (n, t, e) {
          r(!0, n, t, e);
        },
        animateOut: function (n, t, e) {
          r(!1, n, t, e);
        }
      };

      function i(e, o, i) {
        var r,
            u,
            a = null;
        if (0 === e) return i.apply(o), void o.trigger("finished.zf.animate", [o]).triggerHandler("finished.zf.animate", [o]);
        r = window.requestAnimationFrame(function n(t) {
          u = t - (a = a || t), i.apply(o), u < e ? r = window.requestAnimationFrame(n, o) : (window.cancelAnimationFrame(r), o.trigger("finished.zf.animate", [o]).triggerHandler("finished.zf.animate", [o]));
        });
      }

      function r(n, t, e, o) {
        var i, r;

        function u() {
          t[0].style.transitionDuration = 0, t.removeClass("".concat(i, " ").concat(r, " ").concat(e));
        }

        (t = a()(t).eq(0)).length && (i = n ? c[0] : c[1], r = n ? d[0] : d[1], u(), t.addClass(e).css("transition", "none"), requestAnimationFrame(function () {
          t.addClass(i), n && t.show();
        }), requestAnimationFrame(function () {
          t[0].offsetWidth, t.css("transition", "").addClass(r);
        }), t.one(Object(f.transitionend)(t), function () {
          n || t.hide();
          u(), o && o.apply(t);
        }));
      }
    },
    25: function (n, t, e) {
      n.exports = e("./js/entries/plugins/foundation.util.motion.js");
    },
    jquery: function (n, t) {
      n.exports = o;
    }
  }, u = {}, i.m = r, i.c = u, i.d = function (n, t, e) {
    i.o(n, t) || Object.defineProperty(n, t, {
      enumerable: !0,
      get: e
    });
  }, i.r = function (n) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(n, "__esModule", {
      value: !0
    });
  }, i.t = function (t, n) {
    if (1 & n && (t = i(t)), 8 & n) return t;
    if (4 & n && "object" == typeof t && t && t.__esModule) return t;
    var e = Object.create(null);
    if (i.r(e), Object.defineProperty(e, "default", {
      enumerable: !0,
      value: t
    }), 2 & n && "string" != typeof t) for (var o in t) i.d(e, o, function (n) {
      return t[n];
    }.bind(null, o));
    return e;
  }, i.n = function (n) {
    var t = n && n.__esModule ? function () {
      return n.default;
    } : function () {
      return n;
    };
    return i.d(t, "a", t), t;
  }, i.o = function (n, t) {
    return Object.prototype.hasOwnProperty.call(n, t);
  }, i.p = "", i(i.s = 25);

  function i(n) {
    if (u[n]) return u[n].exports;
    var t = u[n] = {
      i: n,
      l: !1,
      exports: {}
    };
    return r[n].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
  }

  var r, u;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core")) : "function" == typeof define && define.amd ? define(["./foundation.core"], e) : "object" == typeof exports ? exports["foundation.util.box"] = e(require("./foundation.core")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.util.box"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"]));
}(window, function (o) {
  return n = {
    "./foundation.core": function (t, e) {
      t.exports = o;
    },
    "./js/entries/plugins/foundation.util.box.js": function (t, e, o) {
      "use strict";

      o.r(e);
      var n = o("./foundation.core");
      o.d(e, "Foundation", function () {
        return n.Foundation;
      });
      var i = o("./js/foundation.util.box.js");
      o.d(e, "Box", function () {
        return i.Box;
      }), n.Foundation.Box = i.Box;
    },
    "./js/foundation.util.box.js": function (t, e, o) {
      "use strict";

      o.r(e), o.d(e, "Box", function () {
        return n;
      });
      var n = {
        ImNotTouchingYou: function (t, e, o, n, i) {
          return 0 === f(t, e, o, n, i);
        },
        OverlapArea: f,
        GetDimensions: c,
        GetExplicitOffsets: function (t, e, o, n, i, f, r) {
          var s,
              u,
              a = c(t),
              d = e ? c(e) : null;

          if (null !== d) {
            switch (o) {
              case "top":
                s = d.offset.top - (a.height + i);
                break;

              case "bottom":
                s = d.offset.top + d.height + i;
                break;

              case "left":
                u = d.offset.left - (a.width + f);
                break;

              case "right":
                u = d.offset.left + d.width + f;
            }

            switch (o) {
              case "top":
              case "bottom":
                switch (n) {
                  case "left":
                    u = d.offset.left + f;
                    break;

                  case "right":
                    u = d.offset.left - a.width + d.width - f;
                    break;

                  case "center":
                    u = r ? f : d.offset.left + d.width / 2 - a.width / 2 + f;
                }

                break;

              case "right":
              case "left":
                switch (n) {
                  case "bottom":
                    s = d.offset.top - i + d.height - a.height;
                    break;

                  case "top":
                    s = d.offset.top + i;
                    break;

                  case "center":
                    s = d.offset.top + i + d.height / 2 - a.height / 2;
                }

            }
          }

          return {
            top: s,
            left: u
          };
        }
      };

      function f(t, e, o, n, i) {
        var f,
            r,
            s,
            t = c(t);
        return t = e ? (f = (e = c(e)).height + e.offset.top - (t.offset.top + t.height), r = t.offset.top - e.offset.top, s = t.offset.left - e.offset.left, e.width + e.offset.left - (t.offset.left + t.width)) : (f = t.windowDims.height + t.windowDims.offset.top - (t.offset.top + t.height), r = t.offset.top - t.windowDims.offset.top, s = t.offset.left - t.windowDims.offset.left, t.windowDims.width - (t.offset.left + t.width)), f = i ? 0 : Math.min(f, 0), r = Math.min(r, 0), s = Math.min(s, 0), t = Math.min(t, 0), o ? s + t : n ? r + f : Math.sqrt(r * r + f * f + s * s + t * t);
      }

      function c(t) {
        if ((t = t.length ? t[0] : t) === window || t === document) throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
        var e = t.getBoundingClientRect(),
            o = t.parentNode.getBoundingClientRect(),
            n = document.body.getBoundingClientRect(),
            i = window.pageYOffset,
            t = window.pageXOffset;
        return {
          width: e.width,
          height: e.height,
          offset: {
            top: e.top + i,
            left: e.left + t
          },
          parentDims: {
            width: o.width,
            height: o.height,
            offset: {
              top: o.top + i,
              left: o.left + t
            }
          },
          windowDims: {
            width: n.width,
            height: n.height,
            offset: {
              top: i,
              left: t
            }
          }
        };
      }
    },
    21: function (t, e, o) {
      t.exports = o("./js/entries/plugins/foundation.util.box.js");
    }
  }, f = {}, i.m = n, i.c = f, i.d = function (t, e, o) {
    i.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: o
    });
  }, i.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, i.t = function (e, t) {
    if (1 & t && (e = i(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var o = Object.create(null);
    if (i.r(o), Object.defineProperty(o, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var n in e) i.d(o, n, function (t) {
      return e[t];
    }.bind(null, n));
    return o;
  }, i.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return i.d(e, "a", e), e;
  }, i.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, i.p = "", i(i.s = 21);

  function i(t) {
    if (f[t]) return f[t].exports;
    var e = f[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return n[t].call(e.exports, e, e.exports, i), e.l = !0, e.exports;
  }

  var n, f;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], t) : "object" == typeof exports ? exports["foundation.util.keyboard"] = t(require("./foundation.core"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.jQuery));
}(window, function (n, r) {
  return i = {
    "./foundation.core": function (e, t) {
      e.exports = n;
    },
    "./js/entries/plugins/foundation.util.keyboard.js": function (e, t, n) {
      "use strict";

      n.r(t);
      var r = n("./foundation.core");
      n.d(t, "Foundation", function () {
        return r.Foundation;
      });
      var o = n("./js/foundation.util.keyboard.js");
      n.d(t, "Keyboard", function () {
        return o.Keyboard;
      }), r.Foundation.Keyboard = o.Keyboard;
    },
    "./js/foundation.util.keyboard.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "Keyboard", function () {
        return f;
      });
      var t = n("jquery"),
          o = n.n(t),
          i = n("./foundation.core"),
          r = {
        9: "TAB",
        13: "ENTER",
        27: "ESCAPE",
        32: "SPACE",
        35: "END",
        36: "HOME",
        37: "ARROW_LEFT",
        38: "ARROW_UP",
        39: "ARROW_RIGHT",
        40: "ARROW_DOWN"
      },
          u = {};

      function a(e) {
        return !!e && e.find("a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]").filter(function () {
          return !(!o()(this).is(":visible") || o()(this).attr("tabindex") < 0);
        }).sort(function (e, t) {
          if (o()(e).attr("tabindex") == o()(t).attr("tabindex")) return 0;
          var n = parseInt(o()(e).attr("tabindex")),
              r = parseInt(o()(t).attr("tabindex"));
          return void 0 === o()(e).attr("tabindex") && 0 < r ? 1 : void 0 === o()(t).attr("tabindex") && 0 < n ? -1 : 0 == n && 0 < r ? 1 : 0 == r && 0 < n || n < r ? -1 : r < n ? 1 : void 0;
        });
      }

      function d(e) {
        var t = (t = r[e.which || e.keyCode] || String.fromCharCode(e.which).toUpperCase()).replace(/\W+/, "");
        return e.shiftKey && (t = "SHIFT_".concat(t)), e.ctrlKey && (t = "CTRL_".concat(t)), t = (t = e.altKey ? "ALT_".concat(t) : t).replace(/_$/, "");
      }

      var f = {
        keys: function (e) {
          var t,
              n = {};

          for (t in e) n[e[t]] = e[t];

          return n;
        }(r),
        parseKey: d,
        handleKey: function (e, t, n) {
          var r = u[t],
              t = this.parseKey(e);
          if (!r) return console.warn("Component not defined!");
          !0 !== e.zfIsKeyHandled && ((t = n[(void 0 === r.ltr ? r : Object(i.rtl)() ? o.a.extend({}, r.ltr, r.rtl) : o.a.extend({}, r.rtl, r.ltr))[t]]) && "function" == typeof t ? (t = t.apply(), e.zfIsKeyHandled = !0, !n.handled && "function" != typeof n.handled || n.handled(t)) : !n.unhandled && "function" != typeof n.unhandled || n.unhandled());
        },
        findFocusable: a,
        register: function (e, t) {
          u[e] = t;
        },
        trapFocus: function (e) {
          var t = a(e),
              n = t.eq(0),
              r = t.eq(-1);
          e.on("keydown.zf.trapfocus", function (e) {
            e.target === r[0] && "TAB" === d(e) ? (e.preventDefault(), n.focus()) : e.target === n[0] && "SHIFT_TAB" === d(e) && (e.preventDefault(), r.focus());
          });
        },
        releaseFocus: function (e) {
          e.off("keydown.zf.trapfocus");
        }
      };
    },
    23: function (e, t, n) {
      e.exports = n("./js/entries/plugins/foundation.util.keyboard.js");
    },
    jquery: function (e, t) {
      e.exports = r;
    }
  }, u = {}, o.m = i, o.c = u, o.d = function (e, t, n) {
    o.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    });
  }, o.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, o.t = function (t, e) {
    if (1 & e && (t = o(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (o.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var r in t) o.d(n, r, function (e) {
      return t[e];
    }.bind(null, r));
    return n;
  }, o.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return o.d(t, "a", t), t;
  }, o.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, o.p = "", o(o.s = 23);

  function o(e) {
    if (u[e]) return u[e].exports;
    var t = u[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return i[e].call(t.exports, t, t.exports, o), t.l = !0, t.exports;
  }

  var i, u;
});
!function (e, n) {
  "object" == typeof exports && "object" == typeof module ? module.exports = n(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], n) : "object" == typeof exports ? exports["foundation.util.nest"] = n(require("./foundation.core"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.util.nest"] = n(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.jQuery));
}(window, function (t, r) {
  return u = {
    "./foundation.core": function (e, n) {
      e.exports = t;
    },
    "./js/entries/plugins/foundation.util.nest.js": function (e, n, t) {
      "use strict";

      t.r(n);
      var r = t("./foundation.core");
      t.d(n, "Foundation", function () {
        return r.Foundation;
      });
      var o = t("./js/foundation.util.nest.js");
      t.d(n, "Nest", function () {
        return o.Nest;
      }), r.Foundation.Nest = o.Nest;
    },
    "./js/foundation.util.nest.js": function (e, n, t) {
      "use strict";

      t.r(n), t.d(n, "Nest", function () {
        return r;
      });
      var n = t("jquery"),
          a = t.n(n),
          r = {
        Feather: function (e) {
          var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "zf";
          e.attr("role", "menubar"), e.find("a").attr({
            role: "menuitem"
          });
          var e = e.find("li").attr({
            role: "none"
          }),
              r = "is-".concat(t, "-submenu"),
              o = "".concat(r, "-item"),
              u = "is-".concat(t, "-submenu-parent"),
              i = "accordion" !== t;
          e.each(function () {
            var e = a()(this),
                n = e.children("ul");
            n.length && (e.addClass(u), i && (e.children("a:first").attr({
              "aria-haspopup": !0,
              "aria-label": e.children("a:first").text()
            }), "drilldown" === t && e.attr({
              "aria-expanded": !1
            })), n.addClass("submenu ".concat(r)).attr({
              "data-submenu": "",
              role: "menubar"
            }), "drilldown" === t && n.attr({
              "aria-hidden": !0
            })), e.parent("[data-submenu]").length && e.addClass("is-submenu-item ".concat(o));
          });
        },
        Burn: function (e, n) {
          var t = "is-".concat(n, "-submenu"),
              r = "".concat(t, "-item"),
              n = "is-".concat(n, "-submenu-parent");
          e.find(">li, > li > ul, .menu, .menu > li, [data-submenu] > li").removeClass("".concat(t, " ").concat(r, " ").concat(n, " is-submenu-item submenu is-active")).removeAttr("data-submenu").css("display", "");
        }
      };
    },
    26: function (e, n, t) {
      e.exports = t("./js/entries/plugins/foundation.util.nest.js");
    },
    jquery: function (e, n) {
      e.exports = r;
    }
  }, i = {}, o.m = u, o.c = i, o.d = function (e, n, t) {
    o.o(e, n) || Object.defineProperty(e, n, {
      enumerable: !0,
      get: t
    });
  }, o.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, o.t = function (n, e) {
    if (1 & e && (n = o(n)), 8 & e) return n;
    if (4 & e && "object" == typeof n && n && n.__esModule) return n;
    var t = Object.create(null);
    if (o.r(t), Object.defineProperty(t, "default", {
      enumerable: !0,
      value: n
    }), 2 & e && "string" != typeof n) for (var r in n) o.d(t, r, function (e) {
      return n[e];
    }.bind(null, r));
    return t;
  }, o.n = function (e) {
    var n = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return o.d(n, "a", n), n;
  }, o.o = function (e, n) {
    return Object.prototype.hasOwnProperty.call(e, n);
  }, o.p = "", o(o.s = 26);

  function o(e) {
    if (i[e]) return i[e].exports;
    var n = i[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return u[e].call(n.exports, n, n.exports, o), n.l = !0, n.exports;
  }

  var u, i;
});
!function (e, n) {
  "object" == typeof exports && "object" == typeof module ? module.exports = n(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], n) : "object" == typeof exports ? exports["foundation.util.imageLoader"] = n(require("./foundation.core"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.util.imageLoader"] = n(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.jQuery));
}(window, function (o, t) {
  return u = {
    "./foundation.core": function (e, n) {
      e.exports = o;
    },
    "./js/entries/plugins/foundation.util.imageLoader.js": function (e, n, o) {
      "use strict";

      o.r(n);
      var t = o("./foundation.core");
      o.d(n, "Foundation", function () {
        return t.Foundation;
      });
      var r = o("./js/foundation.util.imageLoader.js");
      o.d(n, "onImagesLoaded", function () {
        return r.onImagesLoaded;
      }), t.Foundation.onImagesLoaded = r.onImagesLoaded;
    },
    "./js/foundation.util.imageLoader.js": function (e, n, o) {
      "use strict";

      o.r(n), o.d(n, "onImagesLoaded", function () {
        return t;
      });
      var n = o("jquery"),
          r = o.n(n);

      function t(e, n) {
        var o = e.length;

        function t() {
          0 === --o && n();
        }

        0 === o && n(), e.each(function () {
          var e, o;
          this.complete && void 0 !== this.naturalWidth ? t() : (e = new Image(), o = "load.zf.images error.zf.images", r()(e).one(o, function e(n) {
            r()(this).off(o, e), t();
          }), e.src = r()(this).attr("src"));
        });
      }
    },
    22: function (e, n, o) {
      e.exports = o("./js/entries/plugins/foundation.util.imageLoader.js");
    },
    jquery: function (e, n) {
      e.exports = t;
    }
  }, i = {}, r.m = u, r.c = i, r.d = function (e, n, o) {
    r.o(e, n) || Object.defineProperty(e, n, {
      enumerable: !0,
      get: o
    });
  }, r.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, r.t = function (n, e) {
    if (1 & e && (n = r(n)), 8 & e) return n;
    if (4 & e && "object" == typeof n && n && n.__esModule) return n;
    var o = Object.create(null);
    if (r.r(o), Object.defineProperty(o, "default", {
      enumerable: !0,
      value: n
    }), 2 & e && "string" != typeof n) for (var t in n) r.d(o, t, function (e) {
      return n[e];
    }.bind(null, t));
    return o;
  }, r.n = function (e) {
    var n = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return r.d(n, "a", n), n;
  }, r.o = function (e, n) {
    return Object.prototype.hasOwnProperty.call(e, n);
  }, r.p = "", r(r.s = 22);

  function r(e) {
    if (i[e]) return i[e].exports;
    var n = i[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return u[e].call(n.exports, n, n.exports, r), n.l = !0, n.exports;
  }

  var u, i;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], e) : "object" == typeof exports ? exports["foundation.util.timer"] = e(require("./foundation.core"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.util.timer"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.jQuery));
}(window, function (n, r) {
  return i = {
    "./foundation.core": function (t, e) {
      t.exports = n;
    },
    "./js/entries/plugins/foundation.util.timer.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var r = n("./foundation.core");
      n.d(e, "Foundation", function () {
        return r.Foundation;
      });
      var o = n("./js/foundation.util.timer.js");
      n.d(e, "Timer", function () {
        return o.Timer;
      }), r.Foundation.Timer = o.Timer;
    },
    "./js/foundation.util.timer.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Timer", function () {
        return r;
      });
      n("jquery");

      function r(e, t, n) {
        var r,
            o,
            i = this,
            u = t.duration,
            a = Object.keys(e.data())[0] || "timer",
            f = -1;
        this.isPaused = !1, this.restart = function () {
          f = -1, clearTimeout(o), this.start();
        }, this.start = function () {
          this.isPaused = !1, clearTimeout(o), f = f <= 0 ? u : f, e.data("paused", !1), r = Date.now(), o = setTimeout(function () {
            t.infinite && i.restart(), n && "function" == typeof n && n();
          }, f), e.trigger("timerstart.zf.".concat(a));
        }, this.pause = function () {
          this.isPaused = !0, clearTimeout(o), e.data("paused", !0);
          var t = Date.now();
          f -= t - r, e.trigger("timerpaused.zf.".concat(a));
        };
      }
    },
    27: function (t, e, n) {
      t.exports = n("./js/entries/plugins/foundation.util.timer.js");
    },
    jquery: function (t, e) {
      t.exports = r;
    }
  }, u = {}, o.m = i, o.c = u, o.d = function (t, e, n) {
    o.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, o.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, o.t = function (e, t) {
    if (1 & t && (e = o(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (o.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var r in e) o.d(n, r, function (t) {
      return e[t];
    }.bind(null, r));
    return n;
  }, o.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return o.d(e, "a", e), e;
  }, o.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, o.p = "", o(o.s = 27);

  function o(t) {
    if (u[t]) return u[t].exports;
    var e = u[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return i[t].call(e.exports, e, e.exports, o), e.l = !0, e.exports;
  }

  var i, u;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], t) : "object" == typeof exports ? exports["foundation.util.touch"] = t(require("./foundation.core"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.util.touch"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.jQuery));
}(window, function (n, o) {
  return u = {
    "./foundation.core": function (e, t) {
      e.exports = n;
    },
    "./js/entries/plugins/foundation.util.touch.js": function (e, t, n) {
      "use strict";

      n.r(t);
      var o = n("jquery"),
          o = n.n(o),
          i = n("./js/foundation.util.touch.js");
      n.d(t, "Touch", function () {
        return i.Touch;
      });
      var u = n("./foundation.core");
      n.d(t, "Foundation", function () {
        return u.Foundation;
      }), i.Touch.init(o.a), window.Foundation.Touch = i.Touch;
    },
    "./js/foundation.util.touch.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "Touch", function () {
        return a;
      });
      var t = n("jquery"),
          o = n.n(t);

      function i(e, t) {
        for (var n = 0; n < t.length; n++) {
          var o = t[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
        }
      }

      var u,
          r,
          c,
          s,
          a = {},
          f = !1,
          p = !1;

      function l(e) {
        this.removeEventListener("touchmove", d), this.removeEventListener("touchend", l), p || (e = o.a.Event("tap", s || e), o()(this).trigger(e)), s = null, p = f = !1;
      }

      function d(e) {
        var t, n;
        !0 === o.a.spotSwipe.preventDefault && e.preventDefault(), f && (t = e.touches[0].pageX, t = u - t, p = !0, c = new Date().getTime() - r, (n = Math.abs(t) >= o.a.spotSwipe.moveThreshold && c <= o.a.spotSwipe.timeThreshold ? 0 < t ? "left" : "right" : n) && (e.preventDefault(), l.apply(this, arguments), o()(this).trigger(o.a.Event("swipe", Object.assign({}, e)), n).trigger(o.a.Event("swipe".concat(n), Object.assign({}, e)))));
      }

      function h(e) {
        1 === e.touches.length && (u = e.touches[0].pageX, e.touches[0].pageY, s = e, p = !(f = !0), r = new Date().getTime(), this.addEventListener("touchmove", d, {
          passive: !0 === o.a.spotSwipe.preventDefault
        }), this.addEventListener("touchend", l, !1));
      }

      function v() {
        this.addEventListener && this.addEventListener("touchstart", h, {
          passive: !0
        });
      }

      var w = function () {
        function t(e) {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.version = "1.0.0", this.enabled = "ontouchstart" in document.documentElement, this.preventDefault = !1, this.moveThreshold = 75, this.timeThreshold = 200, this.$ = e, this._init();
        }

        var e, n, o;
        return e = t, (n = [{
          key: "_init",
          value: function () {
            var e = this.$;
            e.event.special.swipe = {
              setup: v
            }, e.event.special.tap = {
              setup: v
            }, e.each(["left", "up", "down", "right"], function () {
              e.event.special["swipe".concat(this)] = {
                setup: function () {
                  e(this).on("swipe", e.noop);
                }
              };
            });
          }
        }]) && i(e.prototype, n), o && i(e, o), t;
      }();

      a.setupSpotSwipe = function (e) {
        e.spotSwipe = new w(e);
      }, a.setupTouchHandler = function (o) {
        o.fn.addTouch = function () {
          this.each(function (e, t) {
            o(t).bind("touchstart touchmove touchend touchcancel", function (e) {
              n(e);
            });
          });

          var n = function (e) {
            var t,
                n = e.changedTouches[0],
                e = {
              touchstart: "mousedown",
              touchmove: "mousemove",
              touchend: "mouseup"
            }[e.type];
            "MouseEvent" in window && "function" == typeof window.MouseEvent ? t = new window.MouseEvent(e, {
              bubbles: !0,
              cancelable: !0,
              screenX: n.screenX,
              screenY: n.screenY,
              clientX: n.clientX,
              clientY: n.clientY
            }) : (t = document.createEvent("MouseEvent")).initMouseEvent(e, !0, !0, window, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(t);
          };
        };
      }, a.init = function (e) {
        void 0 === e.spotSwipe && (a.setupSpotSwipe(e), a.setupTouchHandler(e));
      };
    },
    28: function (e, t, n) {
      e.exports = n("./js/entries/plugins/foundation.util.touch.js");
    },
    jquery: function (e, t) {
      e.exports = o;
    }
  }, r = {}, i.m = u, i.c = r, i.d = function (e, t, n) {
    i.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    });
  }, i.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, i.t = function (t, e) {
    if (1 & e && (t = i(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (i.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var o in t) i.d(n, o, function (e) {
      return t[e];
    }.bind(null, o));
    return n;
  }, i.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return i.d(t, "a", t), t;
  }, i.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, i.p = "", i(i.s = 28);

  function i(e) {
    if (r[e]) return r[e].exports;
    var t = r[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return u[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
  }

  var u, r;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.motion", "jquery"], t) : "object" == typeof exports ? exports["foundation.util.triggers"] = t(require("./foundation.core"), require("./foundation.util.motion"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.util.triggers"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.motion"], e.jQuery));
}(window, function (i, r, n) {
  return s = {
    "./foundation.core": function (e, t) {
      e.exports = i;
    },
    "./foundation.util.motion": function (e, t) {
      e.exports = r;
    },
    "./js/entries/plugins/foundation.util.triggers.js": function (e, t, i) {
      "use strict";

      i.r(t);
      var r = i("./foundation.core");
      i.d(t, "Foundation", function () {
        return r.Foundation;
      });
      var n = i("jquery"),
          n = i.n(n),
          o = i("./js/foundation.util.triggers.js");
      i.d(t, "Triggers", function () {
        return o.Triggers;
      }), o.Triggers.init(n.a, r.Foundation);
    },
    "./js/foundation.util.triggers.js": function (e, t, i) {
      "use strict";

      i.r(t), i.d(t, "Triggers", function () {
        return c;
      });
      var t = i("jquery"),
          o = i.n(t),
          r = i("./foundation.core"),
          n = i("./foundation.util.motion");

      function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function a(t, i) {
        t.data(i).split(" ").forEach(function (e) {
          o()("#".concat(e))["close" === i ? "trigger" : "triggerHandler"]("".concat(i, ".zf.trigger"), [t]);
        });
      }

      var l = function () {
        for (var e = ["WebKit", "Moz", "O", "Ms", ""], t = 0; t < e.length; t++) if ("".concat(e[t], "MutationObserver") in window) return window["".concat(e[t], "MutationObserver")];

        return !1;
      }(),
          c = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function u(t, e, i) {
        var r,
            n = Array.prototype.slice.call(arguments, 3);
        o()(window).off(e).on(e, function (e) {
          r && clearTimeout(r), r = setTimeout(function () {
            i.apply(null, n);
          }, t || 10);
        });
      }

      c.Listeners.Basic = {
        openListener: function () {
          a(o()(this), "open");
        },
        closeListener: function () {
          o()(this).data("close") ? a(o()(this), "close") : o()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          o()(this).data("toggle") ? a(o()(this), "toggle") : o()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (e) {
          var t = o()(this).data("closable");
          e.stopPropagation(), "" !== t ? n.Motion.animateOut(o()(this), t, function () {
            o()(this).trigger("closed.zf");
          }) : o()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var e = o()(this).data("toggle-focus");
          o()("#".concat(e)).triggerHandler("toggle.zf.trigger", [o()(this)]);
        }
      }, c.Initializers.addOpenListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.openListener), e.on("click.zf.trigger", "[data-open]", c.Listeners.Basic.openListener);
      }, c.Initializers.addCloseListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.closeListener), e.on("click.zf.trigger", "[data-close]", c.Listeners.Basic.closeListener);
      }, c.Initializers.addToggleListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.toggleListener), e.on("click.zf.trigger", "[data-toggle]", c.Listeners.Basic.toggleListener);
      }, c.Initializers.addCloseableListener = function (e) {
        e.off("close.zf.trigger", c.Listeners.Basic.closeableListener), e.on("close.zf.trigger", "[data-closeable], [data-closable]", c.Listeners.Basic.closeableListener);
      }, c.Initializers.addToggleFocusListener = function (e) {
        e.off("focus.zf.trigger blur.zf.trigger", c.Listeners.Basic.toggleFocusListener), e.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", c.Listeners.Basic.toggleFocusListener);
      }, c.Listeners.Global = {
        resizeListener: function (e) {
          l || e.each(function () {
            o()(this).triggerHandler("resizeme.zf.trigger");
          }), e.attr("data-events", "resize");
        },
        scrollListener: function (e) {
          l || e.each(function () {
            o()(this).triggerHandler("scrollme.zf.trigger");
          }), e.attr("data-events", "scroll");
        },
        closeMeListener: function (e, t) {
          e = e.namespace.split(".")[0];
          o()("[data-".concat(e, "]")).not('[data-yeti-box="'.concat(t, '"]')).each(function () {
            var e = o()(this);
            e.triggerHandler("close.zf.trigger", [e]);
          });
        }
      }, c.Initializers.addClosemeListener = function (e) {
        var t = o()("[data-yeti-box]"),
            i = ["dropdown", "tooltip", "reveal"];
        e && ("string" == typeof e ? i.push(e) : "object" === s(e) && "string" == typeof e[0] ? i = i.concat(e) : console.error("Plugin names must be strings")), t.length && (i = i.map(function (e) {
          return "closeme.zf.".concat(e);
        }).join(" "), o()(window).off(i).on(i, c.Listeners.Global.closeMeListener));
      }, c.Initializers.addResizeListener = function (e) {
        var t = o()("[data-resize]");
        t.length && u(e, "resize.zf.trigger", c.Listeners.Global.resizeListener, t);
      }, c.Initializers.addScrollListener = function (e) {
        var t = o()("[data-scroll]");
        t.length && u(e, "scroll.zf.trigger", c.Listeners.Global.scrollListener, t);
      }, c.Initializers.addMutationEventsListener = function (e) {
        if (!l) return !1;

        function t(e) {
          var t = o()(e[0].target);

          switch (e[0].type) {
            case "attributes":
              "scroll" === t.attr("data-events") && "data-events" === e[0].attributeName && t.triggerHandler("scrollme.zf.trigger", [t, window.pageYOffset]), "resize" === t.attr("data-events") && "data-events" === e[0].attributeName && t.triggerHandler("resizeme.zf.trigger", [t]), "style" === e[0].attributeName && (t.closest("[data-mutate]").attr("data-events", "mutate"), t.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [t.closest("[data-mutate]")]));
              break;

            case "childList":
              t.closest("[data-mutate]").attr("data-events", "mutate"), t.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [t.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var i = e.find("[data-resize], [data-scroll], [data-mutate]");
        if (i.length) for (var r = 0; r <= i.length - 1; r++) new l(t).observe(i[r], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, c.Initializers.addSimpleListeners = function () {
        var e = o()(document);
        c.Initializers.addOpenListener(e), c.Initializers.addCloseListener(e), c.Initializers.addToggleListener(e), c.Initializers.addCloseableListener(e), c.Initializers.addToggleFocusListener(e);
      }, c.Initializers.addGlobalListeners = function () {
        var e = o()(document);
        c.Initializers.addMutationEventsListener(e), c.Initializers.addResizeListener(), c.Initializers.addScrollListener(), c.Initializers.addClosemeListener();
      }, c.init = function (e, t) {
        Object(r.onLoad)(e(window), function () {
          !0 !== e.triggersInitialized && (c.Initializers.addSimpleListeners(), c.Initializers.addGlobalListeners(), e.triggersInitialized = !0);
        }), t && (t.Triggers = c, t.IHearYou = c.Initializers.addGlobalListeners);
      };
    },
    29: function (e, t, i) {
      e.exports = i("./js/entries/plugins/foundation.util.triggers.js");
    },
    jquery: function (e, t) {
      e.exports = n;
    }
  }, a = {}, o.m = s, o.c = a, o.d = function (e, t, i) {
    o.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: i
    });
  }, o.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, o.t = function (t, e) {
    if (1 & e && (t = o(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var i = Object.create(null);
    if (o.r(i), Object.defineProperty(i, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var r in t) o.d(i, r, function (e) {
      return t[e];
    }.bind(null, r));
    return i;
  }, o.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return o.d(t, "a", t), t;
  }, o.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, o.p = "", o(o.s = 29);

  function o(e) {
    if (a[e]) return a[e].exports;
    var t = a[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return s[e].call(t.exports, t, t.exports, o), t.l = !0, t.exports;
  }

  var s, a;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], e) : "object" == typeof exports ? exports["foundation.smoothScroll"] = e(require("./foundation.core"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.smoothScroll"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.jQuery));
}(window, function (o, n) {
  return i = {
    "./foundation.core": function (t, e) {
      t.exports = o;
    },
    "./js/entries/plugins/foundation.smoothScroll.js": function (t, e, o) {
      "use strict";

      o.r(e);
      var n = o("./foundation.core");
      o.d(e, "Foundation", function () {
        return n.Foundation;
      });
      var r = o("./js/foundation.smoothScroll.js");
      o.d(e, "SmoothScroll", function () {
        return r.SmoothScroll;
      }), n.Foundation.plugin(r.SmoothScroll, "SmoothScroll");
    },
    "./js/foundation.smoothScroll.js": function (t, e, o) {
      "use strict";

      o.r(e), o.d(e, "SmoothScroll", function () {
        return n;
      });
      var e = o("jquery"),
          i = o.n(e),
          u = o("./foundation.core");

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var o = 0; o < e.length; o++) {
          var n = e[o];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
      }

      function l(t, e) {
        return (l = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(o) {
        var n = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = s(o);
          return function (t, e) {
            {
              if (e && ("object" === r(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, n ? (t = s(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function s(t) {
        return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var n = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && l(t, e);
        }(r, u["Plugin"]);
        var t,
            e,
            o,
            n = f(r);

        function r() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, r), n.apply(this, arguments);
        }

        return t = r, o = [{
          key: "scrollToLoc",
          value: function (t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : r.defaults,
                o = 2 < arguments.length ? arguments[2] : void 0,
                t = i()(t);
            if (!t.length) return !1;
            t = Math.round(t.offset().top - e.threshold / 2 - e.offset);
            i()("html, body").stop(!0).animate({
              scrollTop: t
            }, e.animationDuration, e.animationEasing, function () {
              "function" == typeof o && o();
            });
          }
        }], (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = i.a.extend({}, r.defaults, this.$element.data(), e), this.className = "SmoothScroll", this._init();
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element[0].id || Object(u.GetYoDigits)(6, "smooth-scroll");
            this.$element.attr({
              id: t
            }), this._events();
          }
        }, {
          key: "_events",
          value: function () {
            this._linkClickListener = this._handleLinkClick.bind(this), this.$element.on("click.zf.smoothScroll", this._linkClickListener), this.$element.on("click.zf.smoothScroll", 'a[href^="#"]', this._linkClickListener);
          }
        }, {
          key: "_handleLinkClick",
          value: function (t) {
            var e,
                o = this;
            i()(t.currentTarget).is('a[href^="#"]') && (e = t.currentTarget.getAttribute("href"), this._inTransition = !0, r.scrollToLoc(e, this.options, function () {
              o._inTransition = !1;
            }), t.preventDefault());
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off("click.zf.smoothScroll", this._linkClickListener), this.$element.off("click.zf.smoothScroll", 'a[href^="#"]', this._linkClickListener);
          }
        }]) && c(t.prototype, e), o && c(t, o), r;
      }();

      n.defaults = {
        animationDuration: 500,
        animationEasing: "linear",
        threshold: 50,
        offset: 0
      };
    },
    16: function (t, e, o) {
      t.exports = o("./js/entries/plugins/foundation.smoothScroll.js");
    },
    jquery: function (t, e) {
      t.exports = n;
    }
  }, u = {}, r.m = i, r.c = u, r.d = function (t, e, o) {
    r.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: o
    });
  }, r.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, r.t = function (e, t) {
    if (1 & t && (e = r(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var o = Object.create(null);
    if (r.r(o), Object.defineProperty(o, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var n in e) r.d(o, n, function (t) {
      return e[t];
    }.bind(null, n));
    return o;
  }, r.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return r.d(e, "a", e), e;
  }, r.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, r.p = "", r(r.s = 16);

  function r(t) {
    if (u[t]) return u[t].exports;
    var e = u[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return i[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports;
  }

  var i, u;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "jquery"], e) : "object" == typeof exports ? exports["foundation.abide"] = e(require("./foundation.core"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.abide"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.jQuery));
}(window, function (r, i) {
  return a = {
    "./foundation.core": function (t, e) {
      t.exports = r;
    },
    "./js/entries/plugins/foundation.abide.js": function (t, e, r) {
      "use strict";

      r.r(e);
      var i = r("./foundation.core");
      r.d(e, "Foundation", function () {
        return i.Foundation;
      });
      var n = r("./js/foundation.abide.js");
      r.d(e, "Abide", function () {
        return n.Abide;
      }), i.Foundation.plugin(n.Abide, "Abide");
    },
    "./js/foundation.abide.js": function (t, e, r) {
      "use strict";

      r.r(e), r.d(e, "Abide", function () {
        return i;
      });
      var e = r("jquery"),
          d = r.n(e),
          o = r("./foundation.core");

      function n(t) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(t, e) {
        for (var r = 0; r < e.length; r++) {
          var i = e[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function s(t, e) {
        return (s = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function l(r) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = u(r);
          return function (t, e) {
            {
              if (e && ("object" === n(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = u(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function u(t) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && s(t, e);
        }(n, o["Plugin"]);
        var t,
            e,
            r,
            i = l(n);

        function n() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, n), i.apply(this, arguments);
        }

        return t = n, (e = [{
          key: "_setup",
          value: function (t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            this.$element = t, this.options = d.a.extend(!0, {}, n.defaults, this.$element.data(), e), this.isEnabled = !0, this.formnovalidate = null, this.className = "Abide", this._init();
          }
        }, {
          key: "_init",
          value: function () {
            var r = this;
            this.$inputs = d.a.merge(this.$element.find("input").not('[type="submit"]'), this.$element.find("textarea, select")), this.$submits = this.$element.find('[type="submit"]');
            var t = this.$element.find("[data-abide-error]");
            this.options.a11yAttributes && (this.$inputs.each(function (t, e) {
              return r.addA11yAttributes(d()(e));
            }), t.each(function (t, e) {
              return r.addGlobalErrorA11yAttributes(d()(e));
            })), this._events();
          }
        }, {
          key: "_events",
          value: function () {
            var e = this;
            this.$element.off(".abide").on("reset.zf.abide", function () {
              e.resetForm();
            }).on("submit.zf.abide", function () {
              return e.validateForm();
            }), this.$submits.off("click.zf.abide keydown.zf.abide").on("click.zf.abide keydown.zf.abide", function (t) {
              t.key && " " !== t.key && "Enter" !== t.key || (t.preventDefault(), e.formnovalidate = null !== t.target.getAttribute("formnovalidate"), e.$element.submit());
            }), "fieldChange" === this.options.validateOn && this.$inputs.off("change.zf.abide").on("change.zf.abide", function (t) {
              e.validateInput(d()(t.target));
            }), this.options.liveValidate && this.$inputs.off("input.zf.abide").on("input.zf.abide", function (t) {
              e.validateInput(d()(t.target));
            }), this.options.validateOnBlur && this.$inputs.off("blur.zf.abide").on("blur.zf.abide", function (t) {
              e.validateInput(d()(t.target));
            });
          }
        }, {
          key: "_reflow",
          value: function () {
            this._init();
          }
        }, {
          key: "_validationIsDisabled",
          value: function () {
            return !1 === this.isEnabled || ("boolean" == typeof this.formnovalidate ? this.formnovalidate : !!this.$submits.length && null !== this.$submits[0].getAttribute("formnovalidate"));
          }
        }, {
          key: "enableValidation",
          value: function () {
            this.isEnabled = !0;
          }
        }, {
          key: "disableValidation",
          value: function () {
            this.isEnabled = !1;
          }
        }, {
          key: "requiredCheck",
          value: function (t) {
            if (!t.attr("required")) return !0;
            var e = !0;

            switch (t[0].type) {
              case "checkbox":
                e = t[0].checked;
                break;

              case "select":
              case "select-one":
              case "select-multiple":
                var r = t.find("option:selected");
                r.length && r.val() || (e = !1);
                break;

              default:
                t.val() && t.val().length || (e = !1);
            }

            return e;
          }
        }, {
          key: "findFormError",
          value: function (e, t) {
            var r = this,
                i = e.length ? e[0].id : "",
                n = e.siblings(this.options.formErrorSelector);
            return n.length || (n = e.parent().find(this.options.formErrorSelector)), i && (n = n.add(this.$element.find('[data-form-error-for="'.concat(i, '"]')))), t && (n = n.not("[data-form-error-on]"), t.forEach(function (t) {
              n = (n = n.add(e.siblings('[data-form-error-on="'.concat(t, '"]')))).add(r.$element.find('[data-form-error-for="'.concat(i, '"][data-form-error-on="').concat(t, '"]')));
            })), n;
          }
        }, {
          key: "findLabel",
          value: function (t) {
            var e = t[0].id,
                e = this.$element.find('label[for="'.concat(e, '"]'));
            return e.length ? e : t.closest("label");
          }
        }, {
          key: "findRadioLabels",
          value: function (t) {
            var i = this,
                t = t.map(function (t, e) {
              var r = e.id,
                  r = i.$element.find('label[for="'.concat(r, '"]'));
              return (r = !r.length ? d()(e).closest("label") : r)[0];
            });
            return d()(t);
          }
        }, {
          key: "findCheckboxLabels",
          value: function (t) {
            var i = this,
                t = t.map(function (t, e) {
              var r = e.id,
                  r = i.$element.find('label[for="'.concat(r, '"]'));
              return (r = !r.length ? d()(e).closest("label") : r)[0];
            });
            return d()(t);
          }
        }, {
          key: "addErrorClasses",
          value: function (t, e) {
            var r = this.findLabel(t),
                e = this.findFormError(t, e);
            r.length && r.addClass(this.options.labelErrorClass), e.length && e.addClass(this.options.formErrorClass), t.addClass(this.options.inputErrorClass).attr({
              "data-invalid": "",
              "aria-invalid": !0
            });
          }
        }, {
          key: "addA11yAttributes",
          value: function (t) {
            var e,
                r,
                i = this.findFormError(t),
                n = i.filter("label"),
                a = i.first();
            i.length && (void 0 === t.attr("aria-describedby") && (void 0 === (e = a.attr("id")) && (e = Object(o.GetYoDigits)(6, "abide-error"), a.attr("id", e)), t.attr("aria-describedby", e)), n.filter("[for]").length < n.length && (void 0 === (r = t.attr("id")) && (r = Object(o.GetYoDigits)(6, "abide-input"), t.attr("id", r)), n.each(function (t, e) {
              e = d()(e);
              void 0 === e.attr("for") && e.attr("for", r);
            })), i.each(function (t, e) {
              e = d()(e);
              void 0 === e.attr("role") && e.attr("role", "alert");
            }).end());
          }
        }, {
          key: "addGlobalErrorA11yAttributes",
          value: function (t) {
            void 0 === t.attr("aria-live") && t.attr("aria-live", this.options.a11yErrorLevel);
          }
        }, {
          key: "removeRadioErrorClasses",
          value: function (t) {
            var e = this.$element.find(':radio[name="'.concat(t, '"]')),
                r = this.findRadioLabels(e),
                t = this.findFormError(e);
            r.length && r.removeClass(this.options.labelErrorClass), t.length && t.removeClass(this.options.formErrorClass), e.removeClass(this.options.inputErrorClass).attr({
              "data-invalid": null,
              "aria-invalid": null
            });
          }
        }, {
          key: "removeCheckboxErrorClasses",
          value: function (t) {
            var e = this.$element.find(':checkbox[name="'.concat(t, '"]')),
                r = this.findCheckboxLabels(e),
                t = this.findFormError(e);
            r.length && r.removeClass(this.options.labelErrorClass), t.length && t.removeClass(this.options.formErrorClass), e.removeClass(this.options.inputErrorClass).attr({
              "data-invalid": null,
              "aria-invalid": null
            });
          }
        }, {
          key: "removeErrorClasses",
          value: function (t) {
            if ("radio" == t[0].type) return this.removeRadioErrorClasses(t.attr("name"));
            if ("checkbox" == t[0].type) return this.removeCheckboxErrorClasses(t.attr("name"));
            var e = this.findLabel(t),
                r = this.findFormError(t);
            e.length && e.removeClass(this.options.labelErrorClass), r.length && r.removeClass(this.options.formErrorClass), t.removeClass(this.options.inputErrorClass).attr({
              "data-invalid": null,
              "aria-invalid": null
            });
          }
        }, {
          key: "validateInput",
          value: function (e) {
            var r,
                i = this,
                t = this.requiredCheck(e),
                n = e.attr("data-validator"),
                a = [],
                o = !0;
            if (this._validationIsDisabled()) return !0;
            if (e.is("[data-abide-ignore]") || e.is('[type="hidden"]') || e.is("[disabled]")) return !0;

            switch (e[0].type) {
              case "radio":
                this.validateRadio(e.attr("name")) || a.push("required");
                break;

              case "checkbox":
                this.validateCheckbox(e.attr("name")) || a.push("required"), o = !1;
                break;

              case "select":
              case "select-one":
              case "select-multiple":
                t || a.push("required");
                break;

              default:
                t || a.push("required"), this.validateText(e) || a.push("pattern");
            }

            n && (r = !!e.attr("required"), n.split(" ").forEach(function (t) {
              i.options.validators[t](e, r, e.parent()) || a.push(t);
            })), e.attr("data-equalto") && (this.options.validators.equalTo(e) || a.push("equalTo"));
            var s,
                l = 0 === a.length,
                u = (l ? "valid" : "invalid") + ".zf.abide";
            return !l || (n = this.$element.find('[data-equalto="'.concat(e.attr("id"), '"]'))).length && (s = this, n.each(function () {
              d()(this).val() && s.validateInput(d()(this));
            })), o && (l ? this.removeErrorClasses(e) : this.addErrorClasses(e, a)), e.trigger(u, [e]), l;
          }
        }, {
          key: "validateForm",
          value: function () {
            var t,
                r = this,
                e = [],
                i = this;
            if (this.initialized || (this.initialized = !0), this._validationIsDisabled()) return !(this.formnovalidate = null);
            this.$inputs.each(function () {
              if ("checkbox" === d()(this)[0].type) {
                if (d()(this).attr("name") === t) return !0;
                t = d()(this).attr("name");
              }

              e.push(i.validateInput(d()(this)));
            });
            var n = -1 === e.indexOf(!1);
            return this.$element.find("[data-abide-error]").each(function (t, e) {
              e = d()(e);
              r.options.a11yAttributes && r.addGlobalErrorA11yAttributes(e), e.css("display", n ? "none" : "block");
            }), this.$element.trigger((n ? "formvalid" : "forminvalid") + ".zf.abide", [this.$element]), n;
          }
        }, {
          key: "validateText",
          value: function (t, e) {
            e = e || t.attr("data-pattern") || t.attr("pattern") || t.attr("type");
            var r = t.val(),
                i = !0;
            return r.length && (this.options.patterns.hasOwnProperty(e) ? i = this.options.patterns[e].test(r) : e !== t.attr("type") && (i = new RegExp(e).test(r))), i;
          }
        }, {
          key: "validateRadio",
          value: function (t) {
            var t = this.$element.find(':radio[name="'.concat(t, '"]')),
                r = !1,
                i = !1;
            return t.each(function (t, e) {
              d()(e).attr("required") && (i = !0);
            }), (r = !i ? !0 : r) || t.each(function (t, e) {
              d()(e).prop("checked") && (r = !0);
            }), r;
          }
        }, {
          key: "validateCheckbox",
          value: function (t) {
            var r = this,
                t = this.$element.find(':checkbox[name="'.concat(t, '"]')),
                i = !1,
                n = !1,
                a = 1,
                o = 0;
            return t.each(function (t, e) {
              d()(e).attr("required") && (n = !0);
            }), (i = !n ? !0 : i) || (t.each(function (t, e) {
              d()(e).prop("checked") && o++, void 0 !== d()(e).attr("data-min-required") && (a = parseInt(d()(e).attr("data-min-required")));
            }), a <= o && (i = !0)), !0 !== this.initialized && 1 < a || (t.each(function (t, e) {
              i ? r.removeErrorClasses(d()(e)) : r.addErrorClasses(d()(e), ["required"]);
            }), i);
          }
        }, {
          key: "matchValidation",
          value: function (e, t, r) {
            var i = this;
            return r = !!r, -1 === t.split(" ").map(function (t) {
              return i.options.validators[t](e, r, e.parent());
            }).indexOf(!1);
          }
        }, {
          key: "resetForm",
          value: function () {
            var t = this.$element,
                e = this.options;
            d()(".".concat(e.labelErrorClass), t).not("small").removeClass(e.labelErrorClass), d()(".".concat(e.inputErrorClass), t).not("small").removeClass(e.inputErrorClass), d()("".concat(e.formErrorSelector, ".").concat(e.formErrorClass)).removeClass(e.formErrorClass), t.find("[data-abide-error]").css("display", "none"), d()(":input", t).not(":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]").val("").attr({
              "data-invalid": null,
              "aria-invalid": null
            }), d()(":input:radio", t).not("[data-abide-ignore]").prop("checked", !1).attr({
              "data-invalid": null,
              "aria-invalid": null
            }), d()(":input:checkbox", t).not("[data-abide-ignore]").prop("checked", !1).attr({
              "data-invalid": null,
              "aria-invalid": null
            }), t.trigger("formreset.zf.abide", [t]);
          }
        }, {
          key: "_destroy",
          value: function () {
            var t = this;
            this.$element.off(".abide").find("[data-abide-error]").css("display", "none"), this.$inputs.off(".abide").each(function () {
              t.removeErrorClasses(d()(this));
            }), this.$submits.off(".abide");
          }
        }]) && a(t.prototype, e), r && a(t, r), n;
      }();

      i.defaults = {
        validateOn: "fieldChange",
        labelErrorClass: "is-invalid-label",
        inputErrorClass: "is-invalid-input",
        formErrorSelector: ".form-error",
        formErrorClass: "is-visible",
        a11yAttributes: !0,
        a11yErrorLevel: "assertive",
        liveValidate: !1,
        validateOnBlur: !1,
        patterns: {
          alpha: /^[a-zA-Z]+$/,
          alpha_numeric: /^[a-zA-Z0-9]+$/,
          integer: /^[-+]?\d+$/,
          number: /^[-+]?\d*(?:[\.\,]\d+)?$/,
          card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
          cvv: /^([0-9]){3,4}$/,
          email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,
          url: /^((?:(https?|ftps?|file|ssh|sftp):\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\))+(?:\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?\xab\xbb\u201c\u201d\u2018\u2019]))$/,
          domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,
          datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
          date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
          time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
          dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
          month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
          day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,
          color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,
          website: {
            test: function (t) {
              return i.defaults.patterns.domain.test(t) || i.defaults.patterns.url.test(t);
            }
          }
        },
        validators: {
          equalTo: function (t, e, r) {
            return d()("#".concat(t.attr("data-equalto"))).val() === t.val();
          }
        }
      };
    },
    0: function (t, e, r) {
      t.exports = r("./js/entries/plugins/foundation.abide.js");
    },
    jquery: function (t, e) {
      t.exports = i;
    }
  }, o = {}, n.m = a, n.c = o, n.d = function (t, e, r) {
    n.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: r
    });
  }, n.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, n.t = function (e, t) {
    if (1 & t && (e = n(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var r = Object.create(null);
    if (n.r(r), Object.defineProperty(r, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var i in e) n.d(r, i, function (t) {
      return e[t];
    }.bind(null, i));
    return r;
  }, n.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return n.d(e, "a", e), e;
  }, n.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, n.p = "", n(n.s = 0);

  function n(t) {
    if (o[t]) return o[t].exports;
    var e = o[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return a[t].call(e.exports, e, e.exports, n), e.l = !0, e.exports;
  }

  var a, o;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.keyboard"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.keyboard", "jquery"], e) : "object" == typeof exports ? exports["foundation.accordion"] = e(require("./foundation.core"), require("./foundation.util.keyboard"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.accordion"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], t.jQuery));
}(window, function (n, o, i) {
  return a = {
    "./foundation.core": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.keyboard": function (t, e) {
      t.exports = o;
    },
    "./js/entries/plugins/foundation.accordion.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var o = n("./foundation.core");
      n.d(e, "Foundation", function () {
        return o.Foundation;
      });
      var i = n("./js/foundation.accordion.js");
      n.d(e, "Accordion", function () {
        return i.Accordion;
      }), o.Foundation.plugin(i.Accordion, "Accordion");
    },
    "./js/foundation.accordion.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Accordion", function () {
        return o;
      });
      var e = n("jquery"),
          r = n.n(e),
          a = n("./foundation.core"),
          c = n("./foundation.util.keyboard");

      function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function s(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      function u(t, e) {
        return (u = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function l(n) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = d(n);
          return function (t, e) {
            {
              if (e && ("object" === i(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, o ? (t = d(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var o = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && u(t, e);
        }(i, a["Plugin"]);
        var t,
            e,
            n,
            o = l(i);

        function i() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, i), o.apply(this, arguments);
        }

        return t = i, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = r.a.extend({}, i.defaults, this.$element.data(), e), this.className = "Accordion", this._init(), c.Keyboard.register("Accordion", {
              ENTER: "toggle",
              SPACE: "toggle",
              ARROW_DOWN: "next",
              ARROW_UP: "previous",
              HOME: "first",
              END: "last"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var n = this;
            this._isInitializing = !0, this.$tabs = this.$element.children("[data-accordion-item]"), this.$tabs.each(function (t, e) {
              var n = r()(e),
                  o = n.children("[data-tab-content]"),
                  i = o[0].id || Object(a.GetYoDigits)(6, "accordion"),
                  e = e.id ? "".concat(e.id, "-label") : "".concat(i, "-label");
              n.find("a:first").attr({
                "aria-controls": i,
                id: e,
                "aria-expanded": !1
              }), o.attr({
                role: "region",
                "aria-labelledby": e,
                "aria-hidden": !0,
                id: i
              });
            });
            var t = this.$element.find(".is-active").children("[data-tab-content]");
            t.length && (this._initialAnchor = t.prev("a").attr("href"), this._openSingleTab(t)), this._checkDeepLink = function () {
              var t = window.location.hash;

              if (!t.length) {
                if (n._isInitializing) return;
                n._initialAnchor && (t = n._initialAnchor);
              }

              var e = t && r()(t),
                  t = t && n.$element.find('[href$="'.concat(t, '"]'));
              !e.length || !t.length || (e && t && t.length ? t.parent("[data-accordion-item]").hasClass("is-active") || n._openSingleTab(e) : n._closeAllTabs(), n.options.deepLinkSmudge && Object(a.onLoad)(r()(window), function () {
                var t = n.$element.offset();
                r()("html, body").animate({
                  scrollTop: t.top - n.options.deepLinkSmudgeOffset
                }, n.options.deepLinkSmudgeDelay);
              }), n.$element.trigger("deeplink.zf.accordion", [t, e]));
            }, this.options.deepLink && this._checkDeepLink(), this._events(), this._isInitializing = !1;
          }
        }, {
          key: "_events",
          value: function () {
            var o = this;
            this.$tabs.each(function () {
              var e = r()(this),
                  n = e.children("[data-tab-content]");
              n.length && e.children("a").off("click.zf.accordion keydown.zf.accordion").on("click.zf.accordion", function (t) {
                t.preventDefault(), o.toggle(n);
              }).on("keydown.zf.accordion", function (t) {
                c.Keyboard.handleKey(t, "Accordion", {
                  toggle: function () {
                    o.toggle(n);
                  },
                  next: function () {
                    var t = e.next().find("a").focus();
                    o.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  previous: function () {
                    var t = e.prev().find("a").focus();
                    o.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  first: function () {
                    var t = o.$tabs.first().find(".accordion-title").focus();
                    o.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  last: function () {
                    var t = o.$tabs.last().find(".accordion-title").focus();
                    o.options.multiExpand || t.trigger("click.zf.accordion");
                  },
                  handled: function () {
                    t.preventDefault();
                  }
                });
              });
            }), this.options.deepLink && r()(window).on("hashchange", this._checkDeepLink);
          }
        }, {
          key: "toggle",
          value: function (t) {
            t.closest("[data-accordion]").is("[disabled]") ? console.info("Cannot toggle an accordion that is disabled.") : (t.parent().hasClass("is-active") ? this.up(t) : this.down(t), this.options.deepLink && (t = t.prev("a").attr("href"), this.options.updateHistory ? history.pushState({}, "", t) : history.replaceState({}, "", t)));
          }
        }, {
          key: "down",
          value: function (t) {
            t.closest("[data-accordion]").is("[disabled]") ? console.info("Cannot call down on an accordion that is disabled.") : this.options.multiExpand ? this._openTab(t) : this._openSingleTab(t);
          }
        }, {
          key: "up",
          value: function (t) {
            var e;
            this.$element.is("[disabled]") ? console.info("Cannot call up on an accordion that is disabled.") : (e = t.parent()).hasClass("is-active") && (e = e.siblings(), (this.options.allowAllClosed || e.hasClass("is-active")) && this._closeTab(t));
          }
        }, {
          key: "_openSingleTab",
          value: function (t) {
            var e = this.$element.children(".is-active").children("[data-tab-content]");
            e.length && this._closeTab(e.not(t)), this._openTab(t);
          }
        }, {
          key: "_openTab",
          value: function (t) {
            var e = this,
                n = t.parent(),
                o = t.attr("aria-labelledby");
            t.attr("aria-hidden", !1), n.addClass("is-active"), r()("#".concat(o)).attr({
              "aria-expanded": !0
            }), t.finish().slideDown(this.options.slideSpeed, function () {
              e.$element.trigger("down.zf.accordion", [t]);
            });
          }
        }, {
          key: "_closeTab",
          value: function (t) {
            var e = this,
                n = t.parent(),
                o = t.attr("aria-labelledby");
            t.attr("aria-hidden", !0), n.removeClass("is-active"), r()("#".concat(o)).attr({
              "aria-expanded": !1
            }), t.finish().slideUp(this.options.slideSpeed, function () {
              e.$element.trigger("up.zf.accordion", [t]);
            });
          }
        }, {
          key: "_closeAllTabs",
          value: function () {
            var t = this.$element.children(".is-active").children("[data-tab-content]");
            t.length && this._closeTab(t);
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.find("[data-tab-content]").stop(!0).slideUp(0).css("display", ""), this.$element.find("a").off(".zf.accordion"), this.options.deepLink && r()(window).off("hashchange", this._checkDeepLink);
          }
        }]) && s(t.prototype, e), n && s(t, n), i;
      }();

      o.defaults = {
        slideSpeed: 250,
        multiExpand: !1,
        allowAllClosed: !1,
        deepLink: !1,
        deepLinkSmudge: !1,
        deepLinkSmudgeDelay: 300,
        deepLinkSmudgeOffset: 0,
        updateHistory: !1
      };
    },
    1: function (t, e, n) {
      t.exports = n("./js/entries/plugins/foundation.accordion.js");
    },
    jquery: function (t, e) {
      t.exports = i;
    }
  }, c = {}, r.m = a, r.c = c, r.d = function (t, e, n) {
    r.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, r.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, r.t = function (e, t) {
    if (1 & t && (e = r(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (r.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var o in e) r.d(n, o, function (t) {
      return e[t];
    }.bind(null, o));
    return n;
  }, r.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return r.d(e, "a", e), e;
  }, r.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, r.p = "", r(r.s = 1);

  function r(t) {
    if (c[t]) return c[t].exports;
    var e = c[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return a[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports;
  }

  var a, c;
});
!function (e, n) {
  "object" == typeof exports && "object" == typeof module ? module.exports = n(require("./foundation.core"), require("./foundation.util.keyboard"), require("./foundation.util.nest"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.keyboard", "./foundation.util.nest", "jquery"], n) : "object" == typeof exports ? exports["foundation.accordionMenu"] = n(require("./foundation.core"), require("./foundation.util.keyboard"), require("./foundation.util.nest"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.accordionMenu"] = n(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], e.__FOUNDATION_EXTERNAL__["foundation.util.nest"], e.jQuery));
}(window, function (t, i, o, r) {
  return a = {
    "./foundation.core": function (e, n) {
      e.exports = t;
    },
    "./foundation.util.keyboard": function (e, n) {
      e.exports = i;
    },
    "./foundation.util.nest": function (e, n) {
      e.exports = o;
    },
    "./js/entries/plugins/foundation.accordionMenu.js": function (e, n, t) {
      "use strict";

      t.r(n);
      var i = t("./foundation.core");
      t.d(n, "Foundation", function () {
        return i.Foundation;
      });
      var o = t("./js/foundation.accordionMenu.js");
      t.d(n, "AccordionMenu", function () {
        return o.AccordionMenu;
      }), i.Foundation.plugin(o.AccordionMenu, "AccordionMenu");
    },
    "./js/foundation.accordionMenu.js": function (e, n, t) {
      "use strict";

      t.r(n), t.d(n, "AccordionMenu", function () {
        return i;
      });
      var n = t("jquery"),
          a = t.n(n),
          s = t("./foundation.util.keyboard"),
          u = t("./foundation.util.nest"),
          c = t("./foundation.core");

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function r(e, n) {
        for (var t = 0; t < n.length; t++) {
          var i = n[t];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
      }

      function l(e, n) {
        return (l = Object.setPrototypeOf || function (e, n) {
          return e.__proto__ = n, e;
        })(e, n);
      }

      function d(t) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              n = f(t);
          return function (e, n) {
            {
              if (n && ("object" === o(n) || "function" == typeof n)) return n;
              if (void 0 !== n) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, i ? (e = f(this).constructor, Reflect.construct(n, arguments, e)) : n.apply(this, arguments));
        };
      }

      function f(e) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var i = function () {
        !function (e, n) {
          if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(n && n.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), n && l(e, n);
        }(o, c["Plugin"]);
        var e,
            n,
            t,
            i = d(o);

        function o() {
          return function (e, n) {
            if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return e = o, (n = [{
          key: "_setup",
          value: function (e, n) {
            this.$element = e, this.options = a.a.extend({}, o.defaults, this.$element.data(), n), this.className = "AccordionMenu", this._init(), s.Keyboard.register("AccordionMenu", {
              ENTER: "toggle",
              SPACE: "toggle",
              ARROW_RIGHT: "open",
              ARROW_UP: "up",
              ARROW_DOWN: "down",
              ARROW_LEFT: "close",
              ESCAPE: "closeAll"
            });
          }
        }, {
          key: "_init",
          value: function () {
            u.Nest.Feather(this.$element, "accordion");
            var r = this;
            this.$element.find("[data-submenu]").not(".is-active").slideUp(0), this.$element.attr({
              "aria-multiselectable": this.options.multiOpen
            }), this.$menuLinks = this.$element.find(".is-accordion-submenu-parent"), this.$menuLinks.each(function () {
              var e = this.id || Object(c.GetYoDigits)(6, "acc-menu-link"),
                  n = a()(this),
                  t = n.children("[data-submenu]"),
                  i = t[0].id || Object(c.GetYoDigits)(6, "acc-menu"),
                  o = t.hasClass("is-active");
              r.options.parentLink && n.children("a").clone().prependTo(t).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-accordion-submenu-item"></li>'), r.options.submenuToggle ? (n.addClass("has-submenu-toggle"), n.children("a").after('<button id="' + e + '" class="submenu-toggle" aria-controls="' + i + '" aria-expanded="' + o + '" title="' + r.options.submenuToggleText + '"><span class="submenu-toggle-text">' + r.options.submenuToggleText + "</span></button>")) : n.attr({
                "aria-controls": i,
                "aria-expanded": o,
                id: e
              }), t.attr({
                "aria-labelledby": e,
                "aria-hidden": !o,
                role: "group",
                id: i
              });
            });
            var e = this.$element.find(".is-active");
            e.length && e.each(function () {
              r.down(a()(this));
            }), this._events();
          }
        }, {
          key: "_events",
          value: function () {
            var u = this;
            this.$element.find("li").each(function () {
              var n = a()(this).children("[data-submenu]");
              n.length && (u.options.submenuToggle ? a()(this).children(".submenu-toggle").off("click.zf.accordionMenu").on("click.zf.accordionMenu", function (e) {
                u.toggle(n);
              }) : a()(this).children("a").off("click.zf.accordionMenu").on("click.zf.accordionMenu", function (e) {
                e.preventDefault(), u.toggle(n);
              }));
            }).on("keydown.zf.accordionMenu", function (n) {
              var t,
                  i,
                  o = a()(this),
                  r = o.parent("ul").children("li"),
                  e = o.children("[data-submenu]");
              r.each(function (e) {
                a()(this).is(o) && (t = r.eq(Math.max(0, e - 1)).find("a").first(), i = r.eq(Math.min(e + 1, r.length - 1)).find("a").first(), a()(this).children("[data-submenu]:visible").length && (i = o.find("li:first-child").find("a").first()), a()(this).is(":first-child") ? t = o.parents("li").first().find("a").first() : t.parents("li").first().children("[data-submenu]:visible").length && (t = t.parents("li").find("li:last-child").find("a").first()), a()(this).is(":last-child") && (i = o.parents("li").first().next("li").find("a").first()));
              }), s.Keyboard.handleKey(n, "AccordionMenu", {
                open: function () {
                  e.is(":hidden") && (u.down(e), e.find("li").first().find("a").first().focus());
                },
                close: function () {
                  e.length && !e.is(":hidden") ? u.up(e) : o.parent("[data-submenu]").length && (u.up(o.parent("[data-submenu]")), o.parents("li").first().find("a").first().focus());
                },
                up: function () {
                  return t.focus(), !0;
                },
                down: function () {
                  return i.focus(), !0;
                },
                toggle: function () {
                  return !u.options.submenuToggle && (o.children("[data-submenu]").length ? (u.toggle(o.children("[data-submenu]")), !0) : void 0);
                },
                closeAll: function () {
                  u.hideAll();
                },
                handled: function (e) {
                  e && n.preventDefault();
                }
              });
            });
          }
        }, {
          key: "hideAll",
          value: function () {
            this.up(this.$element.find("[data-submenu]"));
          }
        }, {
          key: "showAll",
          value: function () {
            this.down(this.$element.find("[data-submenu]"));
          }
        }, {
          key: "toggle",
          value: function (e) {
            e.is(":animated") || (e.is(":hidden") ? this.down(e) : this.up(e));
          }
        }, {
          key: "down",
          value: function (e) {
            var n,
                t = this;
            this.options.multiOpen || (n = e.parentsUntil(this.$element).add(e).add(e.find(".is-active")), n = this.$element.find(".is-active").not(n), this.up(n)), e.addClass("is-active").attr({
              "aria-hidden": !1
            }), (this.options.submenuToggle ? e.prev(".submenu-toggle") : e.parent(".is-accordion-submenu-parent")).attr({
              "aria-expanded": !0
            }), e.slideDown(this.options.slideSpeed, function () {
              t.$element.trigger("down.zf.accordionMenu", [e]);
            });
          }
        }, {
          key: "up",
          value: function (e) {
            var n = this,
                t = e.find("[data-submenu]"),
                i = e.add(t);
            t.slideUp(0), i.removeClass("is-active").attr("aria-hidden", !0), (this.options.submenuToggle ? i.prev(".submenu-toggle") : i.parent(".is-accordion-submenu-parent")).attr("aria-expanded", !1), e.slideUp(this.options.slideSpeed, function () {
              n.$element.trigger("up.zf.accordionMenu", [e]);
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.find("[data-submenu]").slideDown(0).css("display", ""), this.$element.find("a").off("click.zf.accordionMenu"), this.$element.find("[data-is-parent-link]").detach(), this.options.submenuToggle && (this.$element.find(".has-submenu-toggle").removeClass("has-submenu-toggle"), this.$element.find(".submenu-toggle").remove()), u.Nest.Burn(this.$element, "accordion");
          }
        }]) && r(e.prototype, n), t && r(e, t), o;
      }();

      i.defaults = {
        parentLink: !1,
        slideSpeed: 250,
        submenuToggle: !1,
        submenuToggleText: "Toggle menu",
        multiOpen: !0
      };
    },
    2: function (e, n, t) {
      e.exports = t("./js/entries/plugins/foundation.accordionMenu.js");
    },
    jquery: function (e, n) {
      e.exports = r;
    }
  }, s = {}, u.m = a, u.c = s, u.d = function (e, n, t) {
    u.o(e, n) || Object.defineProperty(e, n, {
      enumerable: !0,
      get: t
    });
  }, u.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, u.t = function (n, e) {
    if (1 & e && (n = u(n)), 8 & e) return n;
    if (4 & e && "object" == typeof n && n && n.__esModule) return n;
    var t = Object.create(null);
    if (u.r(t), Object.defineProperty(t, "default", {
      enumerable: !0,
      value: n
    }), 2 & e && "string" != typeof n) for (var i in n) u.d(t, i, function (e) {
      return n[e];
    }.bind(null, i));
    return t;
  }, u.n = function (e) {
    var n = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return u.d(n, "a", n), n;
  }, u.o = function (e, n) {
    return Object.prototype.hasOwnProperty.call(e, n);
  }, u.p = "", u(u.s = 2);

  function u(e) {
    if (s[e]) return s[e].exports;
    var n = s[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return a[e].call(n.exports, n, n.exports, u), n.l = !0, n.exports;
  }

  var a, s;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.keyboard"), require("./foundation.util.nest"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.box", "./foundation.util.keyboard", "./foundation.util.nest", "jquery"], t) : "object" == typeof exports ? exports["foundation.drilldown"] = t(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.keyboard"), require("./foundation.util.nest"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.drilldown"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.box"], e.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], e.__FOUNDATION_EXTERNAL__["foundation.util.nest"], e.jQuery));
}(window, function (n, i, o, r, s) {
  return l = {
    "./foundation.core": function (e, t) {
      e.exports = n;
    },
    "./foundation.util.box": function (e, t) {
      e.exports = i;
    },
    "./foundation.util.keyboard": function (e, t) {
      e.exports = o;
    },
    "./foundation.util.nest": function (e, t) {
      e.exports = r;
    },
    "./js/entries/plugins/foundation.drilldown.js": function (e, t, n) {
      "use strict";

      n.r(t);
      var i = n("./foundation.core");
      n.d(t, "Foundation", function () {
        return i.Foundation;
      });
      var o = n("./js/foundation.drilldown.js");
      n.d(t, "Drilldown", function () {
        return o.Drilldown;
      }), i.Foundation.plugin(o.Drilldown, "Drilldown");
    },
    "./js/foundation.drilldown.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "Drilldown", function () {
        return i;
      });
      var t = n("jquery"),
          s = n.n(t),
          a = n("./foundation.util.keyboard"),
          r = n("./foundation.util.nest"),
          l = n("./foundation.core"),
          u = n("./foundation.util.box");

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function d(e, t) {
        for (var n = 0; n < t.length; n++) {
          var i = t[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
      }

      function c(e, t) {
        return (c = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        })(e, t);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              t = h(n);
          return function (e, t) {
            {
              if (t && ("object" === o(t) || "function" == typeof t)) return t;
              if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, i ? (e = h(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments));
        };
      }

      function h(e) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var i = function () {
        !function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), t && c(e, t);
        }(o, l["Plugin"]);
        var e,
            t,
            n,
            i = f(o);

        function o() {
          return function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return e = o, (t = [{
          key: "_setup",
          value: function (e, t) {
            this.$element = e, this.options = s.a.extend({}, o.defaults, this.$element.data(), t), this.className = "Drilldown", this._init(), a.Keyboard.register("Drilldown", {
              ENTER: "open",
              SPACE: "open",
              ARROW_RIGHT: "next",
              ARROW_UP: "up",
              ARROW_DOWN: "down",
              ARROW_LEFT: "previous",
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            r.Nest.Feather(this.$element, "drilldown"), this.options.autoApplyClass && this.$element.addClass("drilldown"), this.$element.attr({
              "aria-multiselectable": !1
            }), this.$submenuAnchors = this.$element.find("li.is-drilldown-submenu-parent").children("a"), this.$submenus = this.$submenuAnchors.parent("li").children("[data-submenu]").attr("role", "group"), this.$menuItems = this.$element.find("li").not(".js-drilldown-back").find("a"), this.$currentMenu = this.$element, this.$element.attr("data-mutate", this.$element.attr("data-drilldown") || Object(l.GetYoDigits)(6, "drilldown")), this._prepareMenu(), this._registerEvents(), this._keyboardEvents();
          }
        }, {
          key: "_prepareMenu",
          value: function () {
            var n = this;
            this.$submenuAnchors.each(function () {
              var e = s()(this),
                  t = e.parent();
              n.options.parentLink && e.clone().prependTo(t.children("[data-submenu]")).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="none"></li>'), e.data("savedHref", e.attr("href")).removeAttr("href").attr("tabindex", 0), e.children("[data-submenu]").attr({
                "aria-hidden": !0,
                tabindex: 0,
                role: "group"
              }), n._events(e);
            }), this.$submenus.each(function () {
              var e = s()(this);
              if (!e.find(".js-drilldown-back").length) switch (n.options.backButtonPosition) {
                case "bottom":
                  e.append(n.options.backButton);
                  break;

                case "top":
                  e.prepend(n.options.backButton);
                  break;

                default:
                  console.error("Unsupported backButtonPosition value '" + n.options.backButtonPosition + "'");
              }

              n._back(e);
            }), this.$submenus.addClass("invisible"), this.options.autoHeight || this.$submenus.addClass("drilldown-submenu-cover-previous"), this.$element.parent().hasClass("is-drilldown") || (this.$wrapper = s()(this.options.wrapper).addClass("is-drilldown"), this.options.animateHeight && this.$wrapper.addClass("animate-height"), this.$element.wrap(this.$wrapper)), this.$wrapper = this.$element.parent(), this.$wrapper.css(this._getMaxDims());
          }
        }, {
          key: "_resize",
          value: function () {
            this.$wrapper.css({
              "max-width": "none",
              "min-height": "none"
            }), this.$wrapper.css(this._getMaxDims());
          }
        }, {
          key: "_events",
          value: function (n) {
            var i = this;
            n.off("click.zf.drilldown").on("click.zf.drilldown", function (e) {
              var t;
              s()(e.target).parentsUntil("ul", "li").hasClass("is-drilldown-submenu-parent") && e.preventDefault(), i._show(n.parent("li")), i.options.closeOnClick && (t = s()("body")).off(".zf.drilldown").on("click.zf.drilldown", function (e) {
                e.target === i.$element[0] || s.a.contains(i.$element[0], e.target) || (e.preventDefault(), i._hideAll(), t.off(".zf.drilldown"));
              });
            });
          }
        }, {
          key: "_registerEvents",
          value: function () {
            this.options.scrollTop && (this._bindHandler = this._scrollTop.bind(this), this.$element.on("open.zf.drilldown hide.zf.drilldown close.zf.drilldown closed.zf.drilldown", this._bindHandler)), this.$element.on("mutateme.zf.trigger", this._resize.bind(this));
          }
        }, {
          key: "_scrollTop",
          value: function () {
            var e = this,
                t = "" != e.options.scrollTopElement ? s()(e.options.scrollTopElement) : e.$element,
                t = parseInt(t.offset().top + e.options.scrollTopOffset, 10);
            s()("html, body").stop(!0).animate({
              scrollTop: t
            }, e.options.animationDuration, e.options.animationEasing, function () {
              this === s()("html")[0] && e.$element.trigger("scrollme.zf.drilldown");
            });
          }
        }, {
          key: "_keyboardEvents",
          value: function () {
            var e = this;
            this.$menuItems.add(this.$element.find(".js-drilldown-back > a, .is-submenu-parent-item > a")).on("keydown.zf.drilldown", function (t) {
              var n,
                  i,
                  o = s()(this),
                  r = o.parent("li").parent("ul").children("li").children("a");
              r.each(function (e) {
                s()(this).is(o) && (n = r.eq(Math.max(0, e - 1)), i = r.eq(Math.min(e + 1, r.length - 1)));
              }), a.Keyboard.handleKey(t, "Drilldown", {
                next: function () {
                  if (o.is(e.$submenuAnchors)) return e._show(o.parent("li")), o.parent("li").one(Object(l.transitionend)(o), function () {
                    o.parent("li").find("ul li a").not(".js-drilldown-back a").first().focus();
                  }), !0;
                },
                previous: function () {
                  return e._hide(o.parent("li").parent("ul")), o.parent("li").parent("ul").one(Object(l.transitionend)(o), function () {
                    setTimeout(function () {
                      o.parent("li").parent("ul").parent("li").children("a").first().focus();
                    }, 1);
                  }), !0;
                },
                up: function () {
                  return n.focus(), !o.is(e.$element.find("> li:first-child > a"));
                },
                down: function () {
                  return i.focus(), !o.is(e.$element.find("> li:last-child > a"));
                },
                close: function () {
                  o.is(e.$element.find("> li > a")) || (e._hide(o.parent().parent()), o.parent().parent().siblings("a").focus());
                },
                open: function () {
                  return (!e.options.parentLink || !o.attr("href")) && (o.is(e.$menuItems) ? o.is(e.$submenuAnchors) ? (e._show(o.parent("li")), o.parent("li").one(Object(l.transitionend)(o), function () {
                    o.parent("li").find("ul li a").not(".js-drilldown-back a").first().focus();
                  }), !0) : void 0 : (e._hide(o.parent("li").parent("ul")), o.parent("li").parent("ul").one(Object(l.transitionend)(o), function () {
                    setTimeout(function () {
                      o.parent("li").parent("ul").parent("li").children("a").first().focus();
                    }, 1);
                  }), !0));
                },
                handled: function (e) {
                  e && t.preventDefault();
                }
              });
            });
          }
        }, {
          key: "_hideAll",
          value: function () {
            var e,
                t = this,
                n = this.$element.find(".is-drilldown-submenu.is-active");
            n.addClass("is-closing"), this.options.autoHeight && (e = n.parent().closest("ul").data("calcHeight"), this.$wrapper.css({
              height: e
            })), this.$element.trigger("close.zf.drilldown"), n.one(Object(l.transitionend)(n), function () {
              n.removeClass("is-active is-closing"), t.$element.trigger("closed.zf.drilldown");
            });
          }
        }, {
          key: "_back",
          value: function (n) {
            var i = this;
            n.off("click.zf.drilldown"), n.children(".js-drilldown-back").on("click.zf.drilldown", function (e) {
              i._hide(n);

              var t = n.parent("li").parent("ul").parent("li");
              t.length ? i._show(t) : i.$currentMenu = i.$element;
            });
          }
        }, {
          key: "_menuLinkEvents",
          value: function () {
            var t = this;
            this.$menuItems.not(".is-drilldown-submenu-parent").off("click.zf.drilldown").on("click.zf.drilldown", function (e) {
              setTimeout(function () {
                t._hideAll();
              }, 0);
            });
          }
        }, {
          key: "_setShowSubMenuClasses",
          value: function (e, t) {
            e.addClass("is-active").removeClass("invisible").attr("aria-hidden", !1), e.parent("li").attr("aria-expanded", !0), !0 === t && this.$element.trigger("open.zf.drilldown", [e]);
          }
        }, {
          key: "_setHideSubMenuClasses",
          value: function (e, t) {
            e.removeClass("is-active").addClass("invisible").attr("aria-hidden", !0), e.parent("li").attr("aria-expanded", !1), !0 === t && e.trigger("hide.zf.drilldown", [e]);
          }
        }, {
          key: "_showMenu",
          value: function (t, n) {
            var i = this;
            if (this.$element.find('li[aria-expanded="true"] > ul[data-submenu]').each(function (e) {
              i._setHideSubMenuClasses(s()(this));
            }), (this.$currentMenu = t).is("[data-drilldown]")) return !0 === n && t.find("li > a").first().focus(), void (this.options.autoHeight && this.$wrapper.css("height", t.data("calcHeight")));
            var o = t.children().first().parentsUntil("[data-drilldown]", "[data-submenu]");
            o.each(function (e) {
              0 === e && i.options.autoHeight && i.$wrapper.css("height", s()(this).data("calcHeight"));
              e = e == o.length - 1;
              !0 == e && s()(this).one(Object(l.transitionend)(s()(this)), function () {
                !0 === n && t.find("li > a").first().focus();
              }), i._setShowSubMenuClasses(s()(this), e);
            });
          }
        }, {
          key: "_show",
          value: function (e) {
            var t = e.children("[data-submenu]");
            e.attr("aria-expanded", !0), this.$currentMenu = t, e.parent().closest("ul").addClass("invisible"), t.addClass("is-active visible").removeClass("invisible").attr("aria-hidden", !1), this.options.autoHeight && this.$wrapper.css({
              height: t.data("calcHeight")
            }), this.$element.trigger("open.zf.drilldown", [e]);
          }
        }, {
          key: "_hide",
          value: function (e) {
            this.options.autoHeight && this.$wrapper.css({
              height: e.parent().closest("ul").data("calcHeight")
            });
            e.parent().closest("ul").removeClass("invisible"), e.parent("li").attr("aria-expanded", !1), e.attr("aria-hidden", !0), e.addClass("is-closing").one(Object(l.transitionend)(e), function () {
              e.removeClass("is-active is-closing visible"), e.blur().addClass("invisible");
            }), e.trigger("hide.zf.drilldown", [e]);
          }
        }, {
          key: "_getMaxDims",
          value: function () {
            var t = 0,
                e = {},
                n = this;
            return this.$submenus.add(this.$element).each(function () {
              s()(this).children("li").length;
              var e = u.Box.GetDimensions(this).height;
              t = t < e ? e : t, n.options.autoHeight && s()(this).data("calcHeight", e);
            }), this.options.autoHeight ? e.height = this.$currentMenu.data("calcHeight") : e["min-height"] = "".concat(t, "px"), e["max-width"] = "".concat(this.$element[0].getBoundingClientRect().width, "px"), e;
          }
        }, {
          key: "_destroy",
          value: function () {
            s()("body").off(".zf.drilldown"), this.options.scrollTop && this.$element.off(".zf.drilldown", this._bindHandler), this._hideAll(), this.$element.off("mutateme.zf.trigger"), r.Nest.Burn(this.$element, "drilldown"), this.$element.unwrap().find(".js-drilldown-back, .is-submenu-parent-item").remove().end().find(".is-active, .is-closing, .is-drilldown-submenu").removeClass("is-active is-closing is-drilldown-submenu").off("transitionend otransitionend webkitTransitionEnd").end().find("[data-submenu]").removeAttr("aria-hidden tabindex role"), this.$submenuAnchors.each(function () {
              s()(this).off(".zf.drilldown");
            }), this.$element.find("[data-is-parent-link]").detach(), this.$submenus.removeClass("drilldown-submenu-cover-previous invisible"), this.$element.find("a").each(function () {
              var e = s()(this);
              e.removeAttr("tabindex"), e.data("savedHref") && e.attr("href", e.data("savedHref")).removeData("savedHref");
            });
          }
        }]) && d(e.prototype, t), n && d(e, n), o;
      }();

      i.defaults = {
        autoApplyClass: !0,
        backButton: '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',
        backButtonPosition: "top",
        wrapper: "<div></div>",
        parentLink: !1,
        closeOnClick: !1,
        autoHeight: !1,
        animateHeight: !1,
        scrollTop: !1,
        scrollTopElement: "",
        scrollTopOffset: 0,
        animationDuration: 500,
        animationEasing: "swing"
      };
    },
    3: function (e, t, n) {
      e.exports = n("./js/entries/plugins/foundation.drilldown.js");
    },
    jquery: function (e, t) {
      e.exports = s;
    }
  }, u = {}, a.m = l, a.c = u, a.d = function (e, t, n) {
    a.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    });
  }, a.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, a.t = function (t, e) {
    if (1 & e && (t = a(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (a.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var i in t) a.d(n, i, function (e) {
      return t[e];
    }.bind(null, i));
    return n;
  }, a.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return a.d(t, "a", t), t;
  }, a.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, a.p = "", a(a.s = 3);

  function a(e) {
    if (u[e]) return u[e].exports;
    var t = u[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return l[e].call(t.exports, t, t.exports, a), t.l = !0, t.exports;
  }

  var l, u;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.keyboard"), require("./foundation.util.motion"), require("./foundation.util.touch"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.box", "./foundation.util.keyboard", "./foundation.util.motion", "./foundation.util.touch", "jquery"], e) : "object" == typeof exports ? exports["foundation.dropdown"] = e(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.keyboard"), require("./foundation.util.motion"), require("./foundation.util.touch"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.dropdown"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.box"], t.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], t.__FOUNDATION_EXTERNAL__["foundation.util.motion"], t.__FOUNDATION_EXTERNAL__["foundation.util.touch"], t.jQuery));
}(window, function (o, n, i, r, s, a) {
  return l = {
    "./foundation.core": function (t, e) {
      t.exports = o;
    },
    "./foundation.util.box": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.keyboard": function (t, e) {
      t.exports = i;
    },
    "./foundation.util.motion": function (t, e) {
      t.exports = r;
    },
    "./foundation.util.touch": function (t, e) {
      t.exports = s;
    },
    "./js/entries/plugins/foundation.dropdown.js": function (t, e, o) {
      "use strict";

      o.r(e);
      var n = o("./foundation.core");
      o.d(e, "Foundation", function () {
        return n.Foundation;
      });
      var i = o("./js/foundation.dropdown.js");
      o.d(e, "Dropdown", function () {
        return i.Dropdown;
      }), n.Foundation.plugin(i.Dropdown, "Dropdown");
    },
    "./js/foundation.dropdown.js": function (t, e, o) {
      "use strict";

      o.r(e), o.d(e, "Dropdown", function () {
        return n;
      });
      var e = o("jquery"),
          r = o.n(e),
          s = o("./foundation.util.keyboard"),
          a = o("./foundation.core"),
          u = o("./js/foundation.positionable.js"),
          l = o("./js/foundation.util.triggers.js"),
          c = o("./foundation.util.touch");

      function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function f(t, e) {
        for (var o = 0; o < e.length; o++) {
          var n = e[o];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
      }

      function d(t, e, o) {
        return (d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, o) {
          t = function (t, e) {
            for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = g(t)););

            return t;
          }(t, e);

          if (t) {
            e = Object.getOwnPropertyDescriptor(t, e);
            return e.get ? e.get.call(o) : e.value;
          }
        })(t, e, o || t);
      }

      function h(t, e) {
        return (h = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function p(o) {
        var n = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = g(o);
          return function (t, e) {
            {
              if (e && ("object" === i(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, n ? (t = g(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function g(t) {
        return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var n = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && h(t, e);
        }(i, u["Positionable"]);
        var t,
            e,
            o,
            n = p(i);

        function i() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, i), n.apply(this, arguments);
        }

        return t = i, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = r.a.extend({}, i.defaults, this.$element.data(), e), this.className = "Dropdown", c.Touch.init(r.a), l.Triggers.init(r.a), this._init(), s.Keyboard.register("Dropdown", {
              ENTER: "toggle",
              SPACE: "toggle",
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element.attr("id");
            this.$anchors = r()('[data-toggle="'.concat(t, '"]')).length ? r()('[data-toggle="'.concat(t, '"]')) : r()('[data-open="'.concat(t, '"]')), this.$anchors.attr({
              "aria-controls": t,
              "data-is-focus": !1,
              "data-yeti-box": t,
              "aria-haspopup": !0,
              "aria-expanded": !1
            }), this._setCurrentAnchor(this.$anchors.first()), this.options.parentClass ? this.$parent = this.$element.parents("." + this.options.parentClass) : this.$parent = null, void 0 === this.$element.attr("aria-labelledby") && (void 0 === this.$currentAnchor.attr("id") && this.$currentAnchor.attr("id", Object(a.GetYoDigits)(6, "dd-anchor")), this.$element.attr("aria-labelledby", this.$currentAnchor.attr("id"))), this.$element.attr({
              "aria-hidden": "true",
              "data-yeti-box": t,
              "data-resize": t
            }), d(g(i.prototype), "_init", this).call(this), this._events();
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            var t = this.$element[0].className.match(/(top|left|right|bottom)/g);
            return t ? t[0] : "bottom";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            var t = /float-(\S+)/.exec(this.$currentAnchor.attr("class"));
            return t ? t[1] : d(g(i.prototype), "_getDefaultAlignment", this).call(this);
          }
        }, {
          key: "_setPosition",
          value: function () {
            this.$element.removeClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment)), d(g(i.prototype), "_setPosition", this).call(this, this.$currentAnchor, this.$element, this.$parent), this.$element.addClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment));
          }
        }, {
          key: "_setCurrentAnchor",
          value: function (t) {
            this.$currentAnchor = r()(t);
          }
        }, {
          key: "_events",
          value: function () {
            var o = this,
                e = "ontouchstart" in window || void 0 !== window.ontouchstart;
            this.$element.on({
              "open.zf.trigger": this.open.bind(this),
              "close.zf.trigger": this.close.bind(this),
              "toggle.zf.trigger": this.toggle.bind(this),
              "resizeme.zf.trigger": this._setPosition.bind(this)
            }), this.$anchors.off("click.zf.trigger").on("click.zf.trigger", function (t) {
              o._setCurrentAnchor(this), (!1 === o.options.forceFollow || e && o.options.hover && !1 === o.$element.hasClass("is-open")) && t.preventDefault();
            }), this.options.hover && (this.$anchors.off("mouseenter.zf.dropdown mouseleave.zf.dropdown").on("mouseenter.zf.dropdown", function () {
              o._setCurrentAnchor(this);

              var t = r()("body").data();
              void 0 !== t.whatinput && "mouse" !== t.whatinput || (clearTimeout(o.timeout), o.timeout = setTimeout(function () {
                o.open(), o.$anchors.data("hover", !0);
              }, o.options.hoverDelay));
            }).on("mouseleave.zf.dropdown", Object(a.ignoreMousedisappear)(function () {
              clearTimeout(o.timeout), o.timeout = setTimeout(function () {
                o.close(), o.$anchors.data("hover", !1);
              }, o.options.hoverDelay);
            })), this.options.hoverPane && this.$element.off("mouseenter.zf.dropdown mouseleave.zf.dropdown").on("mouseenter.zf.dropdown", function () {
              clearTimeout(o.timeout);
            }).on("mouseleave.zf.dropdown", Object(a.ignoreMousedisappear)(function () {
              clearTimeout(o.timeout), o.timeout = setTimeout(function () {
                o.close(), o.$anchors.data("hover", !1);
              }, o.options.hoverDelay);
            }))), this.$anchors.add(this.$element).on("keydown.zf.dropdown", function (t) {
              var e = r()(this);
              s.Keyboard.findFocusable(o.$element);
              s.Keyboard.handleKey(t, "Dropdown", {
                open: function () {
                  e.is(o.$anchors) && !e.is("input, textarea") && (o.open(), o.$element.attr("tabindex", -1).focus(), t.preventDefault());
                },
                close: function () {
                  o.close(), o.$anchors.focus();
                }
              });
            });
          }
        }, {
          key: "_addBodyHandler",
          value: function () {
            var e = r()(document.body).not(this.$element),
                o = this;
            e.off("click.zf.dropdown tap.zf.dropdown").on("click.zf.dropdown tap.zf.dropdown", function (t) {
              o.$anchors.is(t.target) || o.$anchors.find(t.target).length || o.$element.is(t.target) || o.$element.find(t.target).length || (o.close(), e.off("click.zf.dropdown tap.zf.dropdown"));
            });
          }
        }, {
          key: "open",
          value: function () {
            var t;
            this.$element.trigger("closeme.zf.dropdown", this.$element.attr("id")), this.$anchors.addClass("hover").attr({
              "aria-expanded": !0
            }), this.$element.addClass("is-opening"), this._setPosition(), this.$element.removeClass("is-opening").addClass("is-open").attr({
              "aria-hidden": !1
            }), !this.options.autoFocus || (t = s.Keyboard.findFocusable(this.$element)).length && t.eq(0).focus(), this.options.closeOnClick && this._addBodyHandler(), this.options.trapFocus && s.Keyboard.trapFocus(this.$element), this.$element.trigger("show.zf.dropdown", [this.$element]);
          }
        }, {
          key: "close",
          value: function () {
            if (!this.$element.hasClass("is-open")) return !1;
            this.$element.removeClass("is-open").attr({
              "aria-hidden": !0
            }), this.$anchors.removeClass("hover").attr("aria-expanded", !1), this.$element.trigger("hide.zf.dropdown", [this.$element]), this.options.trapFocus && s.Keyboard.releaseFocus(this.$element);
          }
        }, {
          key: "toggle",
          value: function () {
            this.$element.hasClass("is-open") ? this.$anchors.data("hover") || this.close() : this.open();
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.trigger").hide(), this.$anchors.off(".zf.dropdown"), r()(document.body).off("click.zf.dropdown tap.zf.dropdown");
          }
        }]) && f(t.prototype, e), o && f(t, o), i;
      }();

      n.defaults = {
        parentClass: null,
        hoverDelay: 250,
        hover: !1,
        hoverPane: !1,
        vOffset: 0,
        hOffset: 0,
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !0,
        trapFocus: !1,
        autoFocus: !1,
        closeOnClick: !1,
        forceFollow: !0
      };
    },
    "./js/foundation.positionable.js": function (t, e, o) {
      "use strict";

      o.r(e), o.d(e, "Positionable", function () {
        return n;
      });
      var s = o("./foundation.util.box"),
          r = o("./foundation.core");

      function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(t, e) {
        for (var o = 0; o < e.length; o++) {
          var n = e[o];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
      }

      function u(t, e) {
        return (u = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function l(o) {
        var n = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = c(o);
          return function (t, e) {
            {
              if (e && ("object" === i(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, n ? (t = c(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function c(t) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var f = ["left", "right", "top", "bottom"],
          e = ["top", "bottom", "center"],
          o = ["left", "right", "center"],
          d = {
        left: e,
        right: e,
        top: o,
        bottom: o
      };

      function h(t, e) {
        t = e.indexOf(t);
        return t === e.length - 1 ? e[0] : e[t + 1];
      }

      var n = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && u(t, e);
        }(i, r["Plugin"]);
        var t,
            e,
            o,
            n = l(i);

        function i() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, i), n.apply(this, arguments);
        }

        return t = i, (e = [{
          key: "_init",
          value: function () {
            this.triedPositions = {}, this.position = "auto" === this.options.position ? this._getDefaultPosition() : this.options.position, this.alignment = "auto" === this.options.alignment ? this._getDefaultAlignment() : this.options.alignment, this.originalPosition = this.position, this.originalAlignment = this.alignment;
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            return "bottom";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            switch (this.position) {
              case "bottom":
              case "top":
                return Object(r.rtl)() ? "right" : "left";

              case "left":
              case "right":
                return "bottom";
            }
          }
        }, {
          key: "_reposition",
          value: function () {
            this._alignmentsExhausted(this.position) ? (this.position = h(this.position, f), this.alignment = d[this.position][0]) : this._realign();
          }
        }, {
          key: "_realign",
          value: function () {
            this._addTriedPosition(this.position, this.alignment), this.alignment = h(this.alignment, d[this.position]);
          }
        }, {
          key: "_addTriedPosition",
          value: function (t, e) {
            this.triedPositions[t] = this.triedPositions[t] || [], this.triedPositions[t].push(e);
          }
        }, {
          key: "_positionsExhausted",
          value: function () {
            for (var t = !0, e = 0; e < f.length; e++) t = t && this._alignmentsExhausted(f[e]);

            return t;
          }
        }, {
          key: "_alignmentsExhausted",
          value: function (t) {
            return this.triedPositions[t] && this.triedPositions[t].length == d[t].length;
          }
        }, {
          key: "_getVOffset",
          value: function () {
            return this.options.vOffset;
          }
        }, {
          key: "_getHOffset",
          value: function () {
            return this.options.hOffset;
          }
        }, {
          key: "_setPosition",
          value: function (t, e, o) {
            if ("false" === t.attr("aria-expanded")) return !1;

            if (this.options.allowOverlap || (this.position = this.originalPosition, this.alignment = this.originalAlignment), e.offset(s.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset())), !this.options.allowOverlap) {
              for (var n = 1e8, i = {
                position: this.position,
                alignment: this.alignment
              }; !this._positionsExhausted();) {
                var r = s.Box.OverlapArea(e, o, !1, !1, this.options.allowBottomOverlap);
                if (0 === r) return;
                r < n && (n = r, i = {
                  position: this.position,
                  alignment: this.alignment
                }), this._reposition(), e.offset(s.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
              }

              this.position = i.position, this.alignment = i.alignment, e.offset(s.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
            }
          }
        }]) && a(t.prototype, e), o && a(t, o), i;
      }();

      n.defaults = {
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !0,
        vOffset: 0,
        hOffset: 0
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, o) {
      "use strict";

      o.r(e), o.d(e, "Triggers", function () {
        return l;
      });
      var e = o("jquery"),
          r = o.n(e),
          n = o("./foundation.core"),
          i = o("./foundation.util.motion");

      function s(t) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(e, o) {
        e.data(o).split(" ").forEach(function (t) {
          r()("#".concat(t))["close" === o ? "trigger" : "triggerHandler"]("".concat(o, ".zf.trigger"), [e]);
        });
      }

      var u = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          l = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function c(e, t, o) {
        var n,
            i = Array.prototype.slice.call(arguments, 3);
        r()(window).off(t).on(t, function (t) {
          n && clearTimeout(n), n = setTimeout(function () {
            o.apply(null, i);
          }, e || 10);
        });
      }

      l.Listeners.Basic = {
        openListener: function () {
          a(r()(this), "open");
        },
        closeListener: function () {
          r()(this).data("close") ? a(r()(this), "close") : r()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          r()(this).data("toggle") ? a(r()(this), "toggle") : r()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = r()(this).data("closable");
          t.stopPropagation(), "" !== e ? i.Motion.animateOut(r()(this), e, function () {
            r()(this).trigger("closed.zf");
          }) : r()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = r()(this).data("toggle-focus");
          r()("#".concat(t)).triggerHandler("toggle.zf.trigger", [r()(this)]);
        }
      }, l.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", l.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", l.Listeners.Basic.openListener);
      }, l.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", l.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", l.Listeners.Basic.closeListener);
      }, l.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", l.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", l.Listeners.Basic.toggleListener);
      }, l.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", l.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", l.Listeners.Basic.closeableListener);
      }, l.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", l.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", l.Listeners.Basic.toggleFocusListener);
      }, l.Listeners.Global = {
        resizeListener: function (t) {
          u || t.each(function () {
            r()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          u || t.each(function () {
            r()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          r()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = r()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, l.Initializers.addClosemeListener = function (t) {
        var e = r()("[data-yeti-box]"),
            o = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? o.push(t) : "object" === s(t) && "string" == typeof t[0] ? o = o.concat(t) : console.error("Plugin names must be strings")), e.length && (o = o.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), r()(window).off(o).on(o, l.Listeners.Global.closeMeListener));
      }, l.Initializers.addResizeListener = function (t) {
        var e = r()("[data-resize]");
        e.length && c(t, "resize.zf.trigger", l.Listeners.Global.resizeListener, e);
      }, l.Initializers.addScrollListener = function (t) {
        var e = r()("[data-scroll]");
        e.length && c(t, "scroll.zf.trigger", l.Listeners.Global.scrollListener, e);
      }, l.Initializers.addMutationEventsListener = function (t) {
        if (!u) return !1;

        function e(t) {
          var e = r()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var o = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (o.length) for (var n = 0; n <= o.length - 1; n++) new u(e).observe(o[n], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, l.Initializers.addSimpleListeners = function () {
        var t = r()(document);
        l.Initializers.addOpenListener(t), l.Initializers.addCloseListener(t), l.Initializers.addToggleListener(t), l.Initializers.addCloseableListener(t), l.Initializers.addToggleFocusListener(t);
      }, l.Initializers.addGlobalListeners = function () {
        var t = r()(document);
        l.Initializers.addMutationEventsListener(t), l.Initializers.addResizeListener(), l.Initializers.addScrollListener(), l.Initializers.addClosemeListener();
      }, l.init = function (t, e) {
        Object(n.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (l.Initializers.addSimpleListeners(), l.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = l, e.IHearYou = l.Initializers.addGlobalListeners);
      };
    },
    4: function (t, e, o) {
      t.exports = o("./js/entries/plugins/foundation.dropdown.js");
    },
    jquery: function (t, e) {
      t.exports = a;
    }
  }, c = {}, u.m = l, u.c = c, u.d = function (t, e, o) {
    u.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: o
    });
  }, u.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, u.t = function (e, t) {
    if (1 & t && (e = u(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var o = Object.create(null);
    if (u.r(o), Object.defineProperty(o, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var n in e) u.d(o, n, function (t) {
      return e[t];
    }.bind(null, n));
    return o;
  }, u.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return u.d(e, "a", e), e;
  }, u.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, u.p = "", u(u.s = 4);

  function u(t) {
    if (c[t]) return c[t].exports;
    var e = c[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return l[t].call(e.exports, e, e.exports, u), e.l = !0, e.exports;
  }

  var l, c;
});
!function (e, n) {
  "object" == typeof exports && "object" == typeof module ? module.exports = n(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.keyboard"), require("./foundation.util.nest"), require("./foundation.util.touch"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.box", "./foundation.util.keyboard", "./foundation.util.nest", "./foundation.util.touch", "jquery"], n) : "object" == typeof exports ? exports["foundation.dropdownMenu"] = n(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.keyboard"), require("./foundation.util.nest"), require("./foundation.util.touch"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.dropdownMenu"] = n(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.box"], e.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], e.__FOUNDATION_EXTERNAL__["foundation.util.nest"], e.__FOUNDATION_EXTERNAL__["foundation.util.touch"], e.jQuery));
}(window, function (t, o, i, r, s, u) {
  return d = {
    "./foundation.core": function (e, n) {
      e.exports = t;
    },
    "./foundation.util.box": function (e, n) {
      e.exports = o;
    },
    "./foundation.util.keyboard": function (e, n) {
      e.exports = i;
    },
    "./foundation.util.nest": function (e, n) {
      e.exports = r;
    },
    "./foundation.util.touch": function (e, n) {
      e.exports = s;
    },
    "./js/entries/plugins/foundation.dropdownMenu.js": function (e, n, t) {
      "use strict";

      t.r(n);
      var o = t("./foundation.core");
      t.d(n, "Foundation", function () {
        return o.Foundation;
      });
      var i = t("./js/foundation.dropdownMenu.js");
      t.d(n, "DropdownMenu", function () {
        return i.DropdownMenu;
      }), o.Foundation.plugin(i.DropdownMenu, "DropdownMenu");
    },
    "./js/foundation.dropdownMenu.js": function (e, n, t) {
      "use strict";

      t.r(n), t.d(n, "DropdownMenu", function () {
        return o;
      });
      var n = t("jquery"),
          f = t.n(n),
          u = t("./foundation.core"),
          p = t("./foundation.util.keyboard"),
          r = t("./foundation.util.nest"),
          s = t("./foundation.util.box"),
          a = t("./foundation.util.touch");

      function i(e) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function d(e, n) {
        for (var t = 0; t < n.length; t++) {
          var o = n[t];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
        }
      }

      function l(e, n) {
        return (l = Object.setPrototypeOf || function (e, n) {
          return e.__proto__ = n, e;
        })(e, n);
      }

      function c(t) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              n = h(t);
          return function (e, n) {
            {
              if (n && ("object" === i(n) || "function" == typeof n)) return n;
              if (void 0 !== n) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, o ? (e = h(this).constructor, Reflect.construct(n, arguments, e)) : n.apply(this, arguments));
        };
      }

      function h(e) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var o = function () {
        !function (e, n) {
          if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(n && n.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), n && l(e, n);
        }(i, u["Plugin"]);
        var e,
            n,
            t,
            o = c(i);

        function i() {
          return function (e, n) {
            if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function");
          }(this, i), o.apply(this, arguments);
        }

        return e = i, (n = [{
          key: "_setup",
          value: function (e, n) {
            this.$element = e, this.options = f.a.extend({}, i.defaults, this.$element.data(), n), this.className = "DropdownMenu", a.Touch.init(f.a), this._init(), p.Keyboard.register("DropdownMenu", {
              ENTER: "open",
              SPACE: "open",
              ARROW_RIGHT: "next",
              ARROW_UP: "up",
              ARROW_DOWN: "down",
              ARROW_LEFT: "previous",
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            r.Nest.Feather(this.$element, "dropdown");
            var e = this.$element.find("li.is-dropdown-submenu-parent");
            this.$element.children(".is-dropdown-submenu-parent").children(".is-dropdown-submenu").addClass("first-sub"), this.$menuItems = this.$element.find('li[role="none"]'), this.$tabs = this.$element.children('li[role="none"]'), this.$tabs.find("ul.is-dropdown-submenu").addClass(this.options.verticalClass), "auto" === this.options.alignment ? this.$element.hasClass(this.options.rightClass) || Object(u.rtl)() || this.$element.parents(".top-bar-right").is("*") ? (this.options.alignment = "right", e.addClass("opens-left")) : (this.options.alignment = "left", e.addClass("opens-right")) : "right" === this.options.alignment ? e.addClass("opens-left") : e.addClass("opens-right"), this.changed = !1, this._events();
          }
        }, {
          key: "_isVertical",
          value: function () {
            return "block" === this.$tabs.css("display") || "column" === this.$element.css("flex-direction");
          }
        }, {
          key: "_isRtl",
          value: function () {
            return this.$element.hasClass("align-right") || Object(u.rtl)() && !this.$element.hasClass("align-left");
          }
        }, {
          key: "_events",
          value: function () {
            var c = this,
                r = "ontouchstart" in window || void 0 !== window.ontouchstart,
                s = "is-dropdown-submenu-parent";
            (this.options.clickOpen || r) && this.$menuItems.on("click.zf.dropdownMenu touchstart.zf.dropdownMenu", function (e) {
              var n = f()(e.target).parentsUntil("ul", ".".concat(s)),
                  t = n.hasClass(s),
                  o = "true" === n.attr("data-is-click"),
                  i = n.children(".is-dropdown-submenu");
              t && (o ? !c.options.closeOnClick || !c.options.clickOpen && !r || c.options.forceFollow && r || (e.stopImmediatePropagation(), e.preventDefault(), c._hide(n)) : (e.stopImmediatePropagation(), e.preventDefault(), c._show(i), n.add(n.parentsUntil(c.$element, ".".concat(s))).attr("data-is-click", !0)));
            }), c.options.closeOnClickInside && this.$menuItems.on("click.zf.dropdownMenu", function (e) {
              f()(this).hasClass(s) || c._hide();
            }), r && this.options.disableHoverOnTouch && (this.options.disableHover = !0), this.options.disableHover || this.$menuItems.on("mouseenter.zf.dropdownMenu", function (e) {
              var n = f()(this);
              n.hasClass(s) && (clearTimeout(n.data("_delay")), n.data("_delay", setTimeout(function () {
                c._show(n.children(".is-dropdown-submenu"));
              }, c.options.hoverDelay)));
            }).on("mouseleave.zf.dropdownMenu", Object(u.ignoreMousedisappear)(function (e) {
              var n = f()(this);

              if (n.hasClass(s) && c.options.autoclose) {
                if ("true" === n.attr("data-is-click") && c.options.clickOpen) return !1;
                clearTimeout(n.data("_delay")), n.data("_delay", setTimeout(function () {
                  c._hide(n);
                }, c.options.closingTime));
              }
            })), this.$menuItems.on("keydown.zf.dropdownMenu", function (n) {
              var t,
                  o,
                  i = f()(n.target).parentsUntil("ul", '[role="none"]'),
                  e = -1 < c.$tabs.index(i),
                  r = e ? c.$tabs : i.siblings("li").add(i);
              r.each(function (e) {
                f()(this).is(i) && (t = r.eq(e - 1), o = r.eq(e + 1));
              });

              function s() {
                o.children("a:first").focus(), n.preventDefault();
              }

              function u() {
                t.children("a:first").focus(), n.preventDefault();
              }

              function a() {
                var e = i.children("ul.is-dropdown-submenu");
                e.length && (c._show(e), i.find("li > a:first").focus(), n.preventDefault());
              }

              function d() {
                var e = i.parent("ul").parent("li");
                e.children("a:first").focus(), c._hide(e), n.preventDefault();
              }

              var l = {
                open: a,
                close: function () {
                  c._hide(c.$element), c.$menuItems.eq(0).children("a").focus(), n.preventDefault();
                }
              };
              e ? c._isVertical() ? c._isRtl() ? f.a.extend(l, {
                down: s,
                up: u,
                next: d,
                previous: a
              }) : f.a.extend(l, {
                down: s,
                up: u,
                next: a,
                previous: d
              }) : c._isRtl() ? f.a.extend(l, {
                next: u,
                previous: s,
                down: a,
                up: d
              }) : f.a.extend(l, {
                next: s,
                previous: u,
                down: a,
                up: d
              }) : c._isRtl() ? f.a.extend(l, {
                next: d,
                previous: a,
                down: s,
                up: u
              }) : f.a.extend(l, {
                next: a,
                previous: d,
                down: s,
                up: u
              }), p.Keyboard.handleKey(n, "DropdownMenu", l);
            });
          }
        }, {
          key: "_addBodyHandler",
          value: function () {
            var n = this,
                e = f()(document.body);
            this._removeBodyHandler(), e.on("click.zf.dropdownMenu tap.zf.dropdownMenu", function (e) {
              !f()(e.target).closest(n.$element).length && (n._hide(), n._removeBodyHandler());
            });
          }
        }, {
          key: "_removeBodyHandler",
          value: function () {
            f()(document.body).off("click.zf.dropdownMenu tap.zf.dropdownMenu");
          }
        }, {
          key: "_show",
          value: function (t) {
            var e = this.$tabs.index(this.$tabs.filter(function (e, n) {
              return 0 < f()(n).find(t).length;
            })),
                n = t.parent("li.is-dropdown-submenu-parent").siblings("li.is-dropdown-submenu-parent");
            this._hide(n, e), t.css("visibility", "hidden").addClass("js-dropdown-active").parent("li.is-dropdown-submenu-parent").addClass("is-active"), s.Box.ImNotTouchingYou(t, null, !0) || (n = "left" === this.options.alignment ? "-right" : "-left", (e = t.parent(".is-dropdown-submenu-parent")).removeClass("opens".concat(n)).addClass("opens-".concat(this.options.alignment)), s.Box.ImNotTouchingYou(t, null, !0) || e.removeClass("opens-".concat(this.options.alignment)).addClass("opens-inner"), this.changed = !0), t.css("visibility", ""), this.options.closeOnClick && this._addBodyHandler(), this.$element.trigger("show.zf.dropdownMenu", [t]);
          }
        }, {
          key: "_hide",
          value: function (e, t) {
            var n,
                o = e && e.length ? e : void 0 !== t ? this.$tabs.not(function (e, n) {
              return e === t;
            }) : this.$element;
            (o.hasClass("is-active") || 0 < o.find(".is-active").length) && ((n = o.find("li.is-active")).add(o).attr({
              "data-is-click": !1
            }).removeClass("is-active"), o.find("ul.js-dropdown-active").removeClass("js-dropdown-active"), (this.changed || o.find("opens-inner").length) && (e = "left" === this.options.alignment ? "right" : "left", o.find("li.is-dropdown-submenu-parent").add(o).removeClass("opens-inner opens-".concat(this.options.alignment)).addClass("opens-".concat(e)), this.changed = !1), clearTimeout(n.data("_delay")), this._removeBodyHandler(), this.$element.trigger("hide.zf.dropdownMenu", [o]));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$menuItems.off(".zf.dropdownMenu").removeAttr("data-is-click").removeClass("is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner"), f()(document.body).off(".zf.dropdownMenu"), r.Nest.Burn(this.$element, "dropdown");
          }
        }]) && d(e.prototype, n), t && d(e, t), i;
      }();

      o.defaults = {
        disableHover: !1,
        disableHoverOnTouch: !0,
        autoclose: !0,
        hoverDelay: 50,
        clickOpen: !1,
        closingTime: 500,
        alignment: "auto",
        closeOnClick: !0,
        closeOnClickInside: !0,
        verticalClass: "vertical",
        rightClass: "align-right",
        forceFollow: !0
      };
    },
    5: function (e, n, t) {
      e.exports = t("./js/entries/plugins/foundation.dropdownMenu.js");
    },
    jquery: function (e, n) {
      e.exports = u;
    }
  }, l = {}, a.m = d, a.c = l, a.d = function (e, n, t) {
    a.o(e, n) || Object.defineProperty(e, n, {
      enumerable: !0,
      get: t
    });
  }, a.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, a.t = function (n, e) {
    if (1 & e && (n = a(n)), 8 & e) return n;
    if (4 & e && "object" == typeof n && n && n.__esModule) return n;
    var t = Object.create(null);
    if (a.r(t), Object.defineProperty(t, "default", {
      enumerable: !0,
      value: n
    }), 2 & e && "string" != typeof n) for (var o in n) a.d(t, o, function (e) {
      return n[e];
    }.bind(null, o));
    return t;
  }, a.n = function (e) {
    var n = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return a.d(n, "a", n), n;
  }, a.o = function (e, n) {
    return Object.prototype.hasOwnProperty.call(e, n);
  }, a.p = "", a(a.s = 5);

  function a(e) {
    if (l[e]) return l[e].exports;
    var n = l[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return d[e].call(n.exports, n, n.exports, a), n.l = !0, n.exports;
  }

  var d, l;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("./foundation.util.imageLoader"), require("./foundation.util.mediaQuery"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.imageLoader", "./foundation.util.mediaQuery", "jquery"], t) : "object" == typeof exports ? exports["foundation.equalizer"] = t(require("./foundation.core"), require("./foundation.util.imageLoader"), require("./foundation.util.mediaQuery"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.equalizer"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.imageLoader"], e.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], e.jQuery));
}(window, function (i, n, o, r) {
  return a = {
    "./foundation.core": function (e, t) {
      e.exports = i;
    },
    "./foundation.util.imageLoader": function (e, t) {
      e.exports = n;
    },
    "./foundation.util.mediaQuery": function (e, t) {
      e.exports = o;
    },
    "./js/entries/plugins/foundation.equalizer.js": function (e, t, i) {
      "use strict";

      i.r(t);
      var n = i("./foundation.core");
      i.d(t, "Foundation", function () {
        return n.Foundation;
      });
      var o = i("./js/foundation.equalizer.js");
      i.d(t, "Equalizer", function () {
        return o.Equalizer;
      }), n.Foundation.plugin(o.Equalizer, "Equalizer");
    },
    "./js/foundation.equalizer.js": function (e, t, i) {
      "use strict";

      i.r(t), i.d(t, "Equalizer", function () {
        return n;
      });
      var t = i("jquery"),
          f = i.n(t),
          r = i("./foundation.util.mediaQuery"),
          u = i("./foundation.util.imageLoader"),
          a = i("./foundation.core");

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function s(e, t) {
        for (var i = 0; i < t.length; i++) {
          var n = t[i];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
      }

      function l(e, t) {
        return (l = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        })(e, t);
      }

      function c(i) {
        var n = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              t = h(i);
          return function (e, t) {
            {
              if (t && ("object" === o(t) || "function" == typeof t)) return t;
              if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, n ? (e = h(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments));
        };
      }

      function h(e) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var n = function () {
        !function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), t && l(e, t);
        }(o, a["Plugin"]);
        var e,
            t,
            i,
            n = c(o);

        function o() {
          return function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, o), n.apply(this, arguments);
        }

        return e = o, (t = [{
          key: "_setup",
          value: function (e, t) {
            this.$element = e, this.options = f.a.extend({}, o.defaults, this.$element.data(), t), this.className = "Equalizer", this._init();
          }
        }, {
          key: "_init",
          value: function () {
            var e = this.$element.attr("data-equalizer") || "",
                t = this.$element.find('[data-equalizer-watch="'.concat(e, '"]'));
            r.MediaQuery._init(), this.$watched = t.length ? t : this.$element.find("[data-equalizer-watch]"), this.$element.attr("data-resize", e || Object(a.GetYoDigits)(6, "eq")), this.$element.attr("data-mutate", e || Object(a.GetYoDigits)(6, "eq")), this.hasNested = 0 < this.$element.find("[data-equalizer]").length, this.isNested = 0 < this.$element.parentsUntil(document.body, "[data-equalizer]").length, this.isOn = !1, this._bindHandler = {
              onResizeMeBound: this._onResizeMe.bind(this),
              onPostEqualizedBound: this._onPostEqualized.bind(this)
            };
            var i,
                e = this.$element.find("img");
            this.options.equalizeOn ? (i = this._checkMQ(), f()(window).on("changed.zf.mediaquery", this._checkMQ.bind(this))) : this._events(), (void 0 !== i && !1 === i || void 0 === i) && (e.length ? Object(u.onImagesLoaded)(e, this._reflow.bind(this)) : this._reflow());
          }
        }, {
          key: "_pauseEvents",
          value: function () {
            this.isOn = !1, this.$element.off({
              ".zf.equalizer": this._bindHandler.onPostEqualizedBound,
              "resizeme.zf.trigger": this._bindHandler.onResizeMeBound,
              "mutateme.zf.trigger": this._bindHandler.onResizeMeBound
            });
          }
        }, {
          key: "_onResizeMe",
          value: function (e) {
            this._reflow();
          }
        }, {
          key: "_onPostEqualized",
          value: function (e) {
            e.target !== this.$element[0] && this._reflow();
          }
        }, {
          key: "_events",
          value: function () {
            this._pauseEvents(), this.hasNested ? this.$element.on("postequalized.zf.equalizer", this._bindHandler.onPostEqualizedBound) : (this.$element.on("resizeme.zf.trigger", this._bindHandler.onResizeMeBound), this.$element.on("mutateme.zf.trigger", this._bindHandler.onResizeMeBound)), this.isOn = !0;
          }
        }, {
          key: "_checkMQ",
          value: function () {
            var e = !r.MediaQuery.is(this.options.equalizeOn);
            return e ? this.isOn && (this._pauseEvents(), this.$watched.css("height", "auto")) : this.isOn || this._events(), e;
          }
        }, {
          key: "_killswitch",
          value: function () {}
        }, {
          key: "_reflow",
          value: function () {
            if (!this.options.equalizeOnStack && this._isStacked()) return this.$watched.css("height", "auto"), !1;
            this.options.equalizeByRow ? this.getHeightsByRow(this.applyHeightByRow.bind(this)) : this.getHeights(this.applyHeight.bind(this));
          }
        }, {
          key: "_isStacked",
          value: function () {
            return !this.$watched[0] || !this.$watched[1] || this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;
          }
        }, {
          key: "getHeights",
          value: function (e) {
            for (var t = [], i = 0, n = this.$watched.length; i < n; i++) this.$watched[i].style.height = "auto", t.push(this.$watched[i].offsetHeight);

            e(t);
          }
        }, {
          key: "getHeightsByRow",
          value: function (e) {
            var t = this.$watched.length ? this.$watched.first().offset().top : 0,
                i = [],
                n = 0;
            i[n] = [];

            for (var o = 0, r = this.$watched.length; o < r; o++) {
              this.$watched[o].style.height = "auto";
              var u = f()(this.$watched[o]).offset().top;
              u != t && (i[++n] = [], t = u), i[n].push([this.$watched[o], this.$watched[o].offsetHeight]);
            }

            for (var a = 0, s = i.length; a < s; a++) {
              var l = f()(i[a]).map(function () {
                return this[1];
              }).get(),
                  l = Math.max.apply(null, l);
              i[a].push(l);
            }

            e(i);
          }
        }, {
          key: "applyHeight",
          value: function (e) {
            e = Math.max.apply(null, e);
            this.$element.trigger("preequalized.zf.equalizer"), this.$watched.css("height", e), this.$element.trigger("postequalized.zf.equalizer");
          }
        }, {
          key: "applyHeightByRow",
          value: function (e) {
            this.$element.trigger("preequalized.zf.equalizer");

            for (var t = 0, i = e.length; t < i; t++) {
              var n = e[t].length,
                  o = e[t][n - 1];
              if (n <= 2) f()(e[t][0][0]).css({
                height: "auto"
              });else {
                this.$element.trigger("preequalizedrow.zf.equalizer");

                for (var r = 0, u = n - 1; r < u; r++) f()(e[t][r][0]).css({
                  height: o
                });

                this.$element.trigger("postequalizedrow.zf.equalizer");
              }
            }

            this.$element.trigger("postequalized.zf.equalizer");
          }
        }, {
          key: "_destroy",
          value: function () {
            this._pauseEvents(), this.$watched.css("height", "auto");
          }
        }]) && s(e.prototype, t), i && s(e, i), o;
      }();

      n.defaults = {
        equalizeOnStack: !1,
        equalizeByRow: !1,
        equalizeOn: ""
      };
    },
    6: function (e, t, i) {
      e.exports = i("./js/entries/plugins/foundation.equalizer.js");
    },
    jquery: function (e, t) {
      e.exports = r;
    }
  }, s = {}, u.m = a, u.c = s, u.d = function (e, t, i) {
    u.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: i
    });
  }, u.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, u.t = function (t, e) {
    if (1 & e && (t = u(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var i = Object.create(null);
    if (u.r(i), Object.defineProperty(i, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var n in t) u.d(i, n, function (e) {
      return t[e];
    }.bind(null, n));
    return i;
  }, u.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return u.d(t, "a", t), t;
  }, u.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, u.p = "", u(u.s = 6);

  function u(e) {
    if (s[e]) return s[e].exports;
    var t = s[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return a[e].call(t.exports, t, t.exports, u), t.l = !0, t.exports;
  }

  var a, s;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.mediaQuery", "./foundation.util.motion", "jquery"], t) : "object" == typeof exports ? exports["foundation.interchange"] = t(require("./foundation.core"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.interchange"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], e.__FOUNDATION_EXTERNAL__["foundation.util.motion"], e.jQuery));
}(window, function (n, i, r, o) {
  return s = {
    "./foundation.core": function (e, t) {
      e.exports = n;
    },
    "./foundation.util.mediaQuery": function (e, t) {
      e.exports = i;
    },
    "./foundation.util.motion": function (e, t) {
      e.exports = r;
    },
    "./js/entries/plugins/foundation.interchange.js": function (e, t, n) {
      "use strict";

      n.r(t);
      var i = n("./foundation.core");
      n.d(t, "Foundation", function () {
        return i.Foundation;
      });
      var r = n("./js/foundation.interchange.js");
      n.d(t, "Interchange", function () {
        return r.Interchange;
      }), i.Foundation.plugin(r.Interchange, "Interchange");
    },
    "./js/foundation.interchange.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "Interchange", function () {
        return i;
      });
      var t = n("jquery"),
          r = n.n(t),
          o = n("./foundation.util.mediaQuery"),
          s = n("./foundation.core"),
          u = n("./js/foundation.util.triggers.js");

      function a(e) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function c(e, t) {
        for (var n = 0; n < t.length; n++) {
          var i = t[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
      }

      function l(e, t) {
        return (l = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        })(e, t);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              t = d(n);
          return function (e, t) {
            {
              if (t && ("object" === a(t) || "function" == typeof t)) return t;
              if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, i ? (e = d(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments));
        };
      }

      function d(e) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var i = function () {
        !function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), t && l(e, t);
        }(a, s["Plugin"]);
        var e,
            t,
            n,
            i = f(a);

        function a() {
          return function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, a), i.apply(this, arguments);
        }

        return e = a, (t = [{
          key: "_setup",
          value: function (e, t) {
            this.$element = e, this.options = r.a.extend({}, a.defaults, this.$element.data(), t), this.rules = [], this.currentPath = "", this.className = "Interchange", u.Triggers.init(r.a), this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            o.MediaQuery._init();

            var e = this.$element[0].id || Object(s.GetYoDigits)(6, "interchange");
            this.$element.attr({
              "data-resize": e,
              id: e
            }), this._parseOptions(), this._addBreakpoints(), this._generateRules(), this._reflow();
          }
        }, {
          key: "_events",
          value: function () {
            var e = this;
            this.$element.off("resizeme.zf.trigger").on("resizeme.zf.trigger", function () {
              return e._reflow();
            });
          }
        }, {
          key: "_reflow",
          value: function () {
            var e, t, n;

            for (t in this.rules) this.rules.hasOwnProperty(t) && (n = this.rules[t], window.matchMedia(n.query).matches && (e = n));

            e && this.replace(e.path);
          }
        }, {
          key: "_parseOptions",
          value: function () {
            void 0 === this.options.type ? this.options.type = "auto" : -1 === ["auto", "src", "background", "html"].indexOf(this.options.type) && (console.log('Warning: invalid value "'.concat(this.options.type, '" for Interchange option "type"')), this.options.type = "auto");
          }
        }, {
          key: "_addBreakpoints",
          value: function () {
            for (var e in o.MediaQuery.queries) o.MediaQuery.queries.hasOwnProperty(e) && (e = o.MediaQuery.queries[e], a.SPECIAL_QUERIES[e.name] = e.value);
          }
        }, {
          key: "_generateRules",
          value: function (e) {
            var t,
                n,
                i,
                r = [],
                o = this.options.rules || this.$element.data("interchange");

            for (t in o = "string" == typeof o ? o.match(/\[.*?, .*?\]/g) : o) o.hasOwnProperty(t) && (n = (i = o[t].slice(1, -1).split(", ")).slice(0, -1).join(""), i = i[i.length - 1], a.SPECIAL_QUERIES[i] && (i = a.SPECIAL_QUERIES[i]), r.push({
              path: n,
              query: i
            }));

            this.rules = r;
          }
        }, {
          key: "replace",
          value: function (t) {
            var n,
                e,
                i = this;
            this.currentPath !== t && (n = "replaced.zf.interchange", "src" === (e = "auto" === (e = this.options.type) ? "IMG" === this.$element[0].nodeName ? "src" : t.match(/\.(gif|jpe?g|png|svg|tiff)([?#].*)?/i) ? "background" : "html" : e) ? this.$element.attr("src", t).on("load", function () {
              i.currentPath = t;
            }).trigger(n) : "background" === e ? (t = t.replace(/\(/g, "%28").replace(/\)/g, "%29"), this.$element.css({
              "background-image": "url(" + t + ")"
            }).trigger(n)) : "html" === e && r.a.get(t, function (e) {
              i.$element.html(e).trigger(n), r()(e).foundation(), i.currentPath = t;
            }));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off("resizeme.zf.trigger");
          }
        }]) && c(e.prototype, t), n && c(e, n), a;
      }();

      i.defaults = {
        rules: null,
        type: "auto"
      }, i.SPECIAL_QUERIES = {
        landscape: "screen and (orientation: landscape)",
        portrait: "screen and (orientation: portrait)",
        retina: "only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)"
      };
    },
    "./js/foundation.util.triggers.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "Triggers", function () {
        return c;
      });
      var t = n("jquery"),
          o = n.n(t),
          i = n("./foundation.core"),
          r = n("./foundation.util.motion");

      function a(e) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function s(t, n) {
        t.data(n).split(" ").forEach(function (e) {
          o()("#".concat(e))["close" === n ? "trigger" : "triggerHandler"]("".concat(n, ".zf.trigger"), [t]);
        });
      }

      var u = function () {
        for (var e = ["WebKit", "Moz", "O", "Ms", ""], t = 0; t < e.length; t++) if ("".concat(e[t], "MutationObserver") in window) return window["".concat(e[t], "MutationObserver")];

        return !1;
      }(),
          c = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function l(t, e, n) {
        var i,
            r = Array.prototype.slice.call(arguments, 3);
        o()(window).off(e).on(e, function (e) {
          i && clearTimeout(i), i = setTimeout(function () {
            n.apply(null, r);
          }, t || 10);
        });
      }

      c.Listeners.Basic = {
        openListener: function () {
          s(o()(this), "open");
        },
        closeListener: function () {
          o()(this).data("close") ? s(o()(this), "close") : o()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          o()(this).data("toggle") ? s(o()(this), "toggle") : o()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (e) {
          var t = o()(this).data("closable");
          e.stopPropagation(), "" !== t ? r.Motion.animateOut(o()(this), t, function () {
            o()(this).trigger("closed.zf");
          }) : o()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var e = o()(this).data("toggle-focus");
          o()("#".concat(e)).triggerHandler("toggle.zf.trigger", [o()(this)]);
        }
      }, c.Initializers.addOpenListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.openListener), e.on("click.zf.trigger", "[data-open]", c.Listeners.Basic.openListener);
      }, c.Initializers.addCloseListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.closeListener), e.on("click.zf.trigger", "[data-close]", c.Listeners.Basic.closeListener);
      }, c.Initializers.addToggleListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.toggleListener), e.on("click.zf.trigger", "[data-toggle]", c.Listeners.Basic.toggleListener);
      }, c.Initializers.addCloseableListener = function (e) {
        e.off("close.zf.trigger", c.Listeners.Basic.closeableListener), e.on("close.zf.trigger", "[data-closeable], [data-closable]", c.Listeners.Basic.closeableListener);
      }, c.Initializers.addToggleFocusListener = function (e) {
        e.off("focus.zf.trigger blur.zf.trigger", c.Listeners.Basic.toggleFocusListener), e.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", c.Listeners.Basic.toggleFocusListener);
      }, c.Listeners.Global = {
        resizeListener: function (e) {
          u || e.each(function () {
            o()(this).triggerHandler("resizeme.zf.trigger");
          }), e.attr("data-events", "resize");
        },
        scrollListener: function (e) {
          u || e.each(function () {
            o()(this).triggerHandler("scrollme.zf.trigger");
          }), e.attr("data-events", "scroll");
        },
        closeMeListener: function (e, t) {
          e = e.namespace.split(".")[0];
          o()("[data-".concat(e, "]")).not('[data-yeti-box="'.concat(t, '"]')).each(function () {
            var e = o()(this);
            e.triggerHandler("close.zf.trigger", [e]);
          });
        }
      }, c.Initializers.addClosemeListener = function (e) {
        var t = o()("[data-yeti-box]"),
            n = ["dropdown", "tooltip", "reveal"];
        e && ("string" == typeof e ? n.push(e) : "object" === a(e) && "string" == typeof e[0] ? n = n.concat(e) : console.error("Plugin names must be strings")), t.length && (n = n.map(function (e) {
          return "closeme.zf.".concat(e);
        }).join(" "), o()(window).off(n).on(n, c.Listeners.Global.closeMeListener));
      }, c.Initializers.addResizeListener = function (e) {
        var t = o()("[data-resize]");
        t.length && l(e, "resize.zf.trigger", c.Listeners.Global.resizeListener, t);
      }, c.Initializers.addScrollListener = function (e) {
        var t = o()("[data-scroll]");
        t.length && l(e, "scroll.zf.trigger", c.Listeners.Global.scrollListener, t);
      }, c.Initializers.addMutationEventsListener = function (e) {
        if (!u) return !1;

        function t(e) {
          var t = o()(e[0].target);

          switch (e[0].type) {
            case "attributes":
              "scroll" === t.attr("data-events") && "data-events" === e[0].attributeName && t.triggerHandler("scrollme.zf.trigger", [t, window.pageYOffset]), "resize" === t.attr("data-events") && "data-events" === e[0].attributeName && t.triggerHandler("resizeme.zf.trigger", [t]), "style" === e[0].attributeName && (t.closest("[data-mutate]").attr("data-events", "mutate"), t.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [t.closest("[data-mutate]")]));
              break;

            case "childList":
              t.closest("[data-mutate]").attr("data-events", "mutate"), t.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [t.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var n = e.find("[data-resize], [data-scroll], [data-mutate]");
        if (n.length) for (var i = 0; i <= n.length - 1; i++) new u(t).observe(n[i], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, c.Initializers.addSimpleListeners = function () {
        var e = o()(document);
        c.Initializers.addOpenListener(e), c.Initializers.addCloseListener(e), c.Initializers.addToggleListener(e), c.Initializers.addCloseableListener(e), c.Initializers.addToggleFocusListener(e);
      }, c.Initializers.addGlobalListeners = function () {
        var e = o()(document);
        c.Initializers.addMutationEventsListener(e), c.Initializers.addResizeListener(), c.Initializers.addScrollListener(), c.Initializers.addClosemeListener();
      }, c.init = function (e, t) {
        Object(i.onLoad)(e(window), function () {
          !0 !== e.triggersInitialized && (c.Initializers.addSimpleListeners(), c.Initializers.addGlobalListeners(), e.triggersInitialized = !0);
        }), t && (t.Triggers = c, t.IHearYou = c.Initializers.addGlobalListeners);
      };
    },
    7: function (e, t, n) {
      e.exports = n("./js/entries/plugins/foundation.interchange.js");
    },
    jquery: function (e, t) {
      e.exports = o;
    }
  }, u = {}, a.m = s, a.c = u, a.d = function (e, t, n) {
    a.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    });
  }, a.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, a.t = function (t, e) {
    if (1 & e && (t = a(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (a.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var i in t) a.d(n, i, function (e) {
      return t[e];
    }.bind(null, i));
    return n;
  }, a.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return a.d(t, "a", t), t;
  }, a.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, a.p = "", a(a.s = 7);

  function a(e) {
    if (u[e]) return u[e].exports;
    var t = u[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return s[e].call(t.exports, t, t.exports, a), t.l = !0, t.exports;
  }

  var s, u;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.smoothScroll"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.smoothScroll", "./foundation.util.motion", "jquery"], e) : "object" == typeof exports ? exports["foundation.magellan"] = e(require("./foundation.core"), require("./foundation.smoothScroll"), require("./foundation.util.motion"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.magellan"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.smoothScroll"], t.__FOUNDATION_EXTERNAL__["foundation.util.motion"], t.jQuery));
}(window, function (i, n, o, r) {
  return a = {
    "./foundation.core": function (t, e) {
      t.exports = i;
    },
    "./foundation.smoothScroll": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.motion": function (t, e) {
      t.exports = o;
    },
    "./js/entries/plugins/foundation.magellan.js": function (t, e, i) {
      "use strict";

      i.r(e);
      var n = i("./foundation.core");
      i.d(e, "Foundation", function () {
        return n.Foundation;
      });
      var o = i("./js/foundation.magellan.js");
      i.d(e, "Magellan", function () {
        return o.Magellan;
      }), n.Foundation.plugin(o.Magellan, "Magellan");
    },
    "./js/foundation.magellan.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Magellan", function () {
        return n;
      });
      var e = i("jquery"),
          a = i.n(e),
          r = i("./foundation.core"),
          s = i("./foundation.smoothScroll"),
          l = i("./js/foundation.util.triggers.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var i = 0; i < e.length; i++) {
          var n = e[i];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
      }

      function u(t, e) {
        return (u = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(i) {
        var n = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = d(i);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, n ? (t = d(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var n = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && u(t, e);
        }(o, r["Plugin"]);
        var t,
            e,
            i,
            n = f(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), n.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = a.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Magellan", l.Triggers.init(a.a), this._init(), this.calcPoints();
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element[0].id || Object(r.GetYoDigits)(6, "magellan");
            this.$targets = a()("[data-magellan-target]"), this.$links = this.$element.find("a"), this.$element.attr({
              "data-resize": t,
              "data-scroll": t,
              id: t
            }), this.$active = a()(), this.scrollPos = parseInt(window.pageYOffset, 10), this._events();
          }
        }, {
          key: "calcPoints",
          value: function () {
            var i = this,
                t = document.body,
                e = document.documentElement;
            this.points = [], this.winHeight = Math.round(Math.max(window.innerHeight, e.clientHeight)), this.docHeight = Math.round(Math.max(t.scrollHeight, t.offsetHeight, e.clientHeight, e.scrollHeight, e.offsetHeight)), this.$targets.each(function () {
              var t = a()(this),
                  e = Math.round(t.offset().top - i.options.threshold);
              t.targetPoint = e, i.points.push(e);
            });
          }
        }, {
          key: "_events",
          value: function () {
            var e = this;
            a()(window).one("load", function () {
              e.options.deepLinking && location.hash && e.scrollToLoc(location.hash), e.calcPoints(), e._updateActive();
            }), e.onLoadListener = Object(r.onLoad)(a()(window), function () {
              e.$element.on({
                "resizeme.zf.trigger": e.reflow.bind(e),
                "scrollme.zf.trigger": e._updateActive.bind(e)
              }).on("click.zf.magellan", 'a[href^="#"]', function (t) {
                t.preventDefault();
                t = this.getAttribute("href");
                e.scrollToLoc(t);
              });
            }), this._deepLinkScroll = function (t) {
              e.options.deepLinking && e.scrollToLoc(window.location.hash);
            }, a()(window).on("hashchange", this._deepLinkScroll);
          }
        }, {
          key: "scrollToLoc",
          value: function (t) {
            this._inTransition = !0;
            var e = this,
                i = {
              animationEasing: this.options.animationEasing,
              animationDuration: this.options.animationDuration,
              threshold: this.options.threshold,
              offset: this.options.offset
            };
            s.SmoothScroll.scrollToLoc(t, i, function () {
              e._inTransition = !1;
            });
          }
        }, {
          key: "reflow",
          value: function () {
            this.calcPoints(), this._updateActive();
          }
        }, {
          key: "_updateActive",
          value: function () {
            var i,
                n,
                t,
                e,
                o,
                r,
                s = this;
            this._inTransition || (i = parseInt(window.pageYOffset, 10), n = this.scrollPos > i, (this.scrollPos = i) < this.points[0] - this.options.offset - (n ? this.options.threshold : 0) || (r = i + this.winHeight === this.docHeight ? this.points.length - 1 : (o = this.points.filter(function (t, e) {
              return t - s.options.offset - (n ? s.options.threshold : 0) <= i;
            })).length ? o.length - 1 : 0), t = this.$active, e = "", void 0 !== r ? (this.$active = this.$links.filter('[href="#' + this.$targets.eq(r).data("magellan-target") + '"]'), this.$active.length && (e = this.$active[0].getAttribute("href"))) : this.$active = a()(), o = !(!this.$active.length && !t.length || this.$active.is(t)), r = e !== window.location.hash, o && (t.removeClass(this.options.activeClass), this.$active.addClass(this.options.activeClass)), this.options.deepLinking && r && (window.history.pushState ? (r = e || window.location.pathname + window.location.search, this.options.updateHistory ? window.history.pushState({}, "", r) : window.history.replaceState({}, "", r)) : window.location.hash = e), o && this.$element.trigger("update.zf.magellan", [this.$active]));
          }
        }, {
          key: "_destroy",
          value: function () {
            var t;
            this.$element.off(".zf.trigger .zf.magellan").find(".".concat(this.options.activeClass)).removeClass(this.options.activeClass), this.options.deepLinking && (t = this.$active[0].getAttribute("href"), window.location.hash.replace(t, "")), a()(window).off("hashchange", this._deepLinkScroll), this.onLoadListener && a()(window).off(this.onLoadListener);
          }
        }]) && c(t.prototype, e), i && c(t, i), o;
      }();

      n.defaults = {
        animationDuration: 500,
        animationEasing: "linear",
        threshold: 50,
        activeClass: "is-active",
        deepLinking: !1,
        updateHistory: !1,
        offset: 0
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Triggers", function () {
        return c;
      });
      var e = i("jquery"),
          r = i.n(e),
          n = i("./foundation.core"),
          o = i("./foundation.util.motion");

      function s(t) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(e, i) {
        e.data(i).split(" ").forEach(function (t) {
          r()("#".concat(t))["close" === i ? "trigger" : "triggerHandler"]("".concat(i, ".zf.trigger"), [e]);
        });
      }

      var l = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          c = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function u(e, t, i) {
        var n,
            o = Array.prototype.slice.call(arguments, 3);
        r()(window).off(t).on(t, function (t) {
          n && clearTimeout(n), n = setTimeout(function () {
            i.apply(null, o);
          }, e || 10);
        });
      }

      c.Listeners.Basic = {
        openListener: function () {
          a(r()(this), "open");
        },
        closeListener: function () {
          r()(this).data("close") ? a(r()(this), "close") : r()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          r()(this).data("toggle") ? a(r()(this), "toggle") : r()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = r()(this).data("closable");
          t.stopPropagation(), "" !== e ? o.Motion.animateOut(r()(this), e, function () {
            r()(this).trigger("closed.zf");
          }) : r()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = r()(this).data("toggle-focus");
          r()("#".concat(t)).triggerHandler("toggle.zf.trigger", [r()(this)]);
        }
      }, c.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", c.Listeners.Basic.openListener);
      }, c.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", c.Listeners.Basic.closeListener);
      }, c.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", c.Listeners.Basic.toggleListener);
      }, c.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", c.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", c.Listeners.Basic.closeableListener);
      }, c.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", c.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", c.Listeners.Basic.toggleFocusListener);
      }, c.Listeners.Global = {
        resizeListener: function (t) {
          l || t.each(function () {
            r()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          l || t.each(function () {
            r()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          r()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = r()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, c.Initializers.addClosemeListener = function (t) {
        var e = r()("[data-yeti-box]"),
            i = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? i.push(t) : "object" === s(t) && "string" == typeof t[0] ? i = i.concat(t) : console.error("Plugin names must be strings")), e.length && (i = i.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), r()(window).off(i).on(i, c.Listeners.Global.closeMeListener));
      }, c.Initializers.addResizeListener = function (t) {
        var e = r()("[data-resize]");
        e.length && u(t, "resize.zf.trigger", c.Listeners.Global.resizeListener, e);
      }, c.Initializers.addScrollListener = function (t) {
        var e = r()("[data-scroll]");
        e.length && u(t, "scroll.zf.trigger", c.Listeners.Global.scrollListener, e);
      }, c.Initializers.addMutationEventsListener = function (t) {
        if (!l) return !1;

        function e(t) {
          var e = r()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var i = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (i.length) for (var n = 0; n <= i.length - 1; n++) new l(e).observe(i[n], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, c.Initializers.addSimpleListeners = function () {
        var t = r()(document);
        c.Initializers.addOpenListener(t), c.Initializers.addCloseListener(t), c.Initializers.addToggleListener(t), c.Initializers.addCloseableListener(t), c.Initializers.addToggleFocusListener(t);
      }, c.Initializers.addGlobalListeners = function () {
        var t = r()(document);
        c.Initializers.addMutationEventsListener(t), c.Initializers.addResizeListener(), c.Initializers.addScrollListener(), c.Initializers.addClosemeListener();
      }, c.init = function (t, e) {
        Object(n.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (c.Initializers.addSimpleListeners(), c.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = c, e.IHearYou = c.Initializers.addGlobalListeners);
      };
    },
    8: function (t, e, i) {
      t.exports = i("./js/entries/plugins/foundation.magellan.js");
    },
    jquery: function (t, e) {
      t.exports = r;
    }
  }, l = {}, s.m = a, s.c = l, s.d = function (t, e, i) {
    s.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: i
    });
  }, s.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, s.t = function (e, t) {
    if (1 & t && (e = s(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var i = Object.create(null);
    if (s.r(i), Object.defineProperty(i, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var n in e) s.d(i, n, function (t) {
      return e[t];
    }.bind(null, n));
    return i;
  }, s.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return s.d(e, "a", e), e;
  }, s.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, s.p = "", s(s.s = 8);

  function s(t) {
    if (l[t]) return l[t].exports;
    var e = l[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return a[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports;
  }

  var a, l;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.keyboard"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.keyboard", "./foundation.util.mediaQuery", "./foundation.util.motion", "jquery"], e) : "object" == typeof exports ? exports["foundation.offcanvas"] = e(require("./foundation.core"), require("./foundation.util.keyboard"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.offcanvas"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], t.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], t.__FOUNDATION_EXTERNAL__["foundation.util.motion"], t.jQuery));
}(window, function (n, i, o, s, a) {
  return l = {
    "./foundation.core": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.keyboard": function (t, e) {
      t.exports = i;
    },
    "./foundation.util.mediaQuery": function (t, e) {
      t.exports = o;
    },
    "./foundation.util.motion": function (t, e) {
      t.exports = s;
    },
    "./js/entries/plugins/foundation.offcanvas.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var i = n("./foundation.core");
      n.d(e, "Foundation", function () {
        return i.Foundation;
      });
      var o = n("./js/foundation.offcanvas.js");
      n.d(e, "OffCanvas", function () {
        return o.OffCanvas;
      }), i.Foundation.plugin(o.OffCanvas, "OffCanvas");
    },
    "./js/foundation.offcanvas.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "OffCanvas", function () {
        return i;
      });
      var e = n("jquery"),
          s = n.n(e),
          a = n("./foundation.core"),
          r = n("./foundation.util.keyboard"),
          l = n("./foundation.util.mediaQuery"),
          c = n("./js/foundation.util.triggers.js");

      function f(t) {
        return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function d(t, e) {
        return (d = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function h(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = o(n);
          return function (t, e) {
            {
              if (e && ("object" === f(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = o(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function o(t) {
        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && d(t, e);
        }(o, a["Plugin"]);
        var t,
            e,
            n,
            i = h(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            var n = this;
            this.className = "OffCanvas", this.$element = t, this.options = s.a.extend({}, o.defaults, this.$element.data(), e), this.contentClasses = {
              base: [],
              reveal: []
            }, this.$lastTrigger = s()(), this.$triggers = s()(), this.position = "left", this.$content = s()(), this.nested = !!this.options.nested, this.$sticky = s()(), this.isInCanvas = !1, s()(["push", "overlap"]).each(function (t, e) {
              n.contentClasses.base.push("has-transition-" + e);
            }), s()(["left", "right", "top", "bottom"]).each(function (t, e) {
              n.contentClasses.base.push("has-position-" + e), n.contentClasses.reveal.push("has-reveal-" + e);
            }), c.Triggers.init(s.a), l.MediaQuery._init(), this._init(), this._events(), r.Keyboard.register("OffCanvas", {
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t = this.$element.attr("id");
            this.$element.attr("aria-hidden", "true"), this.options.contentId ? this.$content = s()("#" + this.options.contentId) : this.$element.siblings("[data-off-canvas-content]").length ? this.$content = this.$element.siblings("[data-off-canvas-content]").first() : this.$content = this.$element.closest("[data-off-canvas-content]").first(), this.options.contentId ? this.options.contentId && null === this.options.nested && console.warn("Remember to use the nested option if using the content ID option!") : this.nested = 0 === this.$element.siblings("[data-off-canvas-content]").length, !0 === this.nested && (this.options.transition = "overlap", this.$element.removeClass("is-transition-push")), this.$element.addClass("is-transition-".concat(this.options.transition, " is-closed")), this.$triggers = s()(document).find('[data-open="' + t + '"], [data-close="' + t + '"], [data-toggle="' + t + '"]').attr("aria-expanded", "false").attr("aria-controls", t), this.position = this.$element.is(".position-left, .position-top, .position-right, .position-bottom") ? this.$element.attr("class").match(/position\-(left|top|right|bottom)/)[1] : this.position, !0 === this.options.contentOverlay && (t = document.createElement("div"), e = "fixed" === s()(this.$element).css("position") ? "is-overlay-fixed" : "is-overlay-absolute", t.setAttribute("class", "js-off-canvas-overlay " + e), this.$overlay = s()(t), "is-overlay-fixed" == e ? s()(this.$overlay).insertAfter(this.$element) : this.$content.append(this.$overlay));
            var e = new RegExp(Object(a.RegExpEscape)(this.options.revealClass) + "([^\\s]+)", "g").exec(this.$element[0].className);
            e && (this.options.isRevealed = !0, this.options.revealOn = this.options.revealOn || e[1]), !0 === this.options.isRevealed && this.options.revealOn && (this.$element.first().addClass("".concat(this.options.revealClass).concat(this.options.revealOn)), this._setMQChecker()), this.options.transitionTime && this.$element.css("transition-duration", this.options.transitionTime), this.$sticky = this.$content.find("[data-off-canvas-sticky]"), 0 < this.$sticky.length && "push" === this.options.transition && (this.options.contentScroll = !1);
            e = this.$element.attr("class").match(/\bin-canvas-for-(\w+)/);
            e && 2 === e.length ? this.options.inCanvasOn = e[1] : this.options.inCanvasOn && this.$element.addClass("in-canvas-for-".concat(this.options.inCanvasOn)), this.options.inCanvasOn && this._checkInCanvas(), this._removeContentClasses();
          }
        }, {
          key: "_events",
          value: function () {
            var t = this;
            this.$element.off(".zf.trigger .zf.offCanvas").on({
              "open.zf.trigger": this.open.bind(this),
              "close.zf.trigger": this.close.bind(this),
              "toggle.zf.trigger": this.toggle.bind(this),
              "keydown.zf.offCanvas": this._handleKeyboard.bind(this)
            }), !0 === this.options.closeOnClick && (this.options.contentOverlay ? this.$overlay : this.$content).on({
              "click.zf.offCanvas": this.close.bind(this)
            }), this.options.inCanvasOn && s()(window).on("changed.zf.mediaquery", function () {
              t._checkInCanvas();
            });
          }
        }, {
          key: "_setMQChecker",
          value: function () {
            var t = this;
            this.onLoadListener = Object(a.onLoad)(s()(window), function () {
              l.MediaQuery.atLeast(t.options.revealOn) && t.reveal(!0);
            }), s()(window).on("changed.zf.mediaquery", function () {
              l.MediaQuery.atLeast(t.options.revealOn) ? t.reveal(!0) : t.reveal(!1);
            });
          }
        }, {
          key: "_checkInCanvas",
          value: function () {
            this.isInCanvas = l.MediaQuery.atLeast(this.options.inCanvasOn), !0 === this.isInCanvas && this.close();
          }
        }, {
          key: "_removeContentClasses",
          value: function (t) {
            "boolean" != typeof t ? this.$content.removeClass(this.contentClasses.base.join(" ")) : !1 === t && this.$content.removeClass("has-reveal-".concat(this.position));
          }
        }, {
          key: "_addContentClasses",
          value: function (t) {
            this._removeContentClasses(t), "boolean" != typeof t ? this.$content.addClass("has-transition-".concat(this.options.transition, " has-position-").concat(this.position)) : !0 === t && this.$content.addClass("has-reveal-".concat(this.position));
          }
        }, {
          key: "_fixStickyElements",
          value: function () {
            this.$sticky.each(function (t, e) {
              var n = s()(e);
              "fixed" === n.css("position") && (e = parseInt(n.css("top"), 10), n.data("offCanvasSticky", {
                top: e
              }), e = s()(document).scrollTop() + e, n.css({
                top: "".concat(e, "px"),
                width: "100%",
                transition: "none"
              }));
            });
          }
        }, {
          key: "_unfixStickyElements",
          value: function () {
            this.$sticky.each(function (t, e) {
              var n = s()(e),
                  e = n.data("offCanvasSticky");
              "object" === f(e) && (n.css({
                top: "".concat(e.top, "px"),
                width: "",
                transition: ""
              }), n.data("offCanvasSticky", ""));
            });
          }
        }, {
          key: "reveal",
          value: function (t) {
            t ? (this.close(), this.isRevealed = !0, this.$element.attr("aria-hidden", "false"), this.$element.off("open.zf.trigger toggle.zf.trigger"), this.$element.removeClass("is-closed")) : (this.isRevealed = !1, this.$element.attr("aria-hidden", "true"), this.$element.off("open.zf.trigger toggle.zf.trigger").on({
              "open.zf.trigger": this.open.bind(this),
              "toggle.zf.trigger": this.toggle.bind(this)
            }), this.$element.addClass("is-closed")), this._addContentClasses(t);
          }
        }, {
          key: "_stopScrolling",
          value: function (t) {
            return !1;
          }
        }, {
          key: "_recordScrollable",
          value: function (t) {
            this.lastY = t.touches[0].pageY;
          }
        }, {
          key: "_preventDefaultAtEdges",
          value: function (t) {
            var e = t.data,
                n = this.lastY - t.touches[0].pageY;
            this.lastY = t.touches[0].pageY, e._canScroll(n, this) || t.preventDefault();
          }
        }, {
          key: "_scrollboxTouchMoved",
          value: function (t) {
            var e = t.data,
                n = this.closest("[data-off-canvas], [data-off-canvas-scrollbox-outer]"),
                i = this.lastY - t.touches[0].pageY;
            n.lastY = this.lastY = t.touches[0].pageY, t.stopPropagation(), e._canScroll(i, this) || (e._canScroll(i, n) ? n.scrollTop += i : t.preventDefault());
          }
        }, {
          key: "_canScroll",
          value: function (t, e) {
            var n = 0 < e.scrollTop,
                e = e.scrollTop < e.scrollHeight - e.clientHeight;
            return t < 0 && n || 0 < t && e;
          }
        }, {
          key: "open",
          value: function (t, e) {
            var n,
                i = this;
            this.$element.hasClass("is-open") || this.isRevealed || this.isInCanvas || (n = this, e && (this.$lastTrigger = e), "top" === this.options.forceTo ? window.scrollTo(0, 0) : "bottom" === this.options.forceTo && window.scrollTo(0, document.body.scrollHeight), this.options.transitionTime && "overlap" !== this.options.transition ? this.$element.siblings("[data-off-canvas-content]").css("transition-duration", this.options.transitionTime) : this.$element.siblings("[data-off-canvas-content]").css("transition-duration", ""), this.$element.addClass("is-open").removeClass("is-closed"), this.$triggers.attr("aria-expanded", "true"), this.$element.attr("aria-hidden", "false"), this.$content.addClass("is-open-" + this.position), !1 === this.options.contentScroll && (s()("body").addClass("is-off-canvas-open").on("touchmove", this._stopScrolling), this.$element.on("touchstart", this._recordScrollable), this.$element.on("touchmove", this, this._preventDefaultAtEdges), this.$element.on("touchstart", "[data-off-canvas-scrollbox]", this._recordScrollable), this.$element.on("touchmove", "[data-off-canvas-scrollbox]", this, this._scrollboxTouchMoved)), !0 === this.options.contentOverlay && this.$overlay.addClass("is-visible"), !0 === this.options.closeOnClick && !0 === this.options.contentOverlay && this.$overlay.addClass("is-closable"), !0 === this.options.autoFocus && this.$element.one(Object(a.transitionend)(this.$element), function () {
              var t;
              n.$element.hasClass("is-open") && ((t = n.$element.find("[data-autofocus]")).length ? t : n.$element.find("a, button")).eq(0).focus();
            }), !0 === this.options.trapFocus && (this.$content.attr("tabindex", "-1"), r.Keyboard.trapFocus(this.$element)), "push" === this.options.transition && this._fixStickyElements(), this._addContentClasses(), this.$element.trigger("opened.zf.offCanvas"), this.$element.one(Object(a.transitionend)(this.$element), function () {
              i.$element.trigger("openedEnd.zf.offCanvas");
            }));
          }
        }, {
          key: "close",
          value: function (t) {
            var e = this;
            this.$element.hasClass("is-open") && !this.isRevealed && (this.$element.trigger("close.zf.offCanvas"), this.$element.removeClass("is-open"), this.$element.attr("aria-hidden", "true"), this.$content.removeClass("is-open-left is-open-top is-open-right is-open-bottom"), !0 === this.options.contentOverlay && this.$overlay.removeClass("is-visible"), !0 === this.options.closeOnClick && !0 === this.options.contentOverlay && this.$overlay.removeClass("is-closable"), this.$triggers.attr("aria-expanded", "false"), this.$element.one(Object(a.transitionend)(this.$element), function (t) {
              e.$element.addClass("is-closed"), e._removeContentClasses(), "push" === e.options.transition && e._unfixStickyElements(), !1 === e.options.contentScroll && (s()("body").removeClass("is-off-canvas-open").off("touchmove", e._stopScrolling), e.$element.off("touchstart", e._recordScrollable), e.$element.off("touchmove", e._preventDefaultAtEdges), e.$element.off("touchstart", "[data-off-canvas-scrollbox]", e._recordScrollable), e.$element.off("touchmove", "[data-off-canvas-scrollbox]", e._scrollboxTouchMoved)), !0 === e.options.trapFocus && (e.$content.removeAttr("tabindex"), r.Keyboard.releaseFocus(e.$element)), e.$element.trigger("closed.zf.offCanvas");
            }));
          }
        }, {
          key: "toggle",
          value: function (t, e) {
            this.$element.hasClass("is-open") ? this.close(t, e) : this.open(t, e);
          }
        }, {
          key: "_handleKeyboard",
          value: function (t) {
            var e = this;
            r.Keyboard.handleKey(t, "OffCanvas", {
              close: function () {
                return e.close(), e.$lastTrigger.focus(), !0;
              },
              handled: function () {
                t.preventDefault();
              }
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.close(), this.$element.off(".zf.trigger .zf.offCanvas"), this.$overlay.off(".zf.offCanvas"), this.onLoadListener && s()(window).off(this.onLoadListener);
          }
        }]) && u(t.prototype, e), n && u(t, n), o;
      }();

      i.defaults = {
        closeOnClick: !0,
        contentOverlay: !0,
        contentId: null,
        nested: null,
        contentScroll: !0,
        transitionTime: null,
        transition: "push",
        forceTo: null,
        isRevealed: !1,
        revealOn: null,
        inCanvasOn: null,
        autoFocus: !0,
        revealClass: "reveal-for-",
        trapFocus: !1
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Triggers", function () {
        return c;
      });
      var e = n("jquery"),
          s = n.n(e),
          i = n("./foundation.core"),
          o = n("./foundation.util.motion");

      function a(t) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function r(e, n) {
        e.data(n).split(" ").forEach(function (t) {
          s()("#".concat(t))["close" === n ? "trigger" : "triggerHandler"]("".concat(n, ".zf.trigger"), [e]);
        });
      }

      var l = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          c = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function f(e, t, n) {
        var i,
            o = Array.prototype.slice.call(arguments, 3);
        s()(window).off(t).on(t, function (t) {
          i && clearTimeout(i), i = setTimeout(function () {
            n.apply(null, o);
          }, e || 10);
        });
      }

      c.Listeners.Basic = {
        openListener: function () {
          r(s()(this), "open");
        },
        closeListener: function () {
          s()(this).data("close") ? r(s()(this), "close") : s()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          s()(this).data("toggle") ? r(s()(this), "toggle") : s()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = s()(this).data("closable");
          t.stopPropagation(), "" !== e ? o.Motion.animateOut(s()(this), e, function () {
            s()(this).trigger("closed.zf");
          }) : s()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = s()(this).data("toggle-focus");
          s()("#".concat(t)).triggerHandler("toggle.zf.trigger", [s()(this)]);
        }
      }, c.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", c.Listeners.Basic.openListener);
      }, c.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", c.Listeners.Basic.closeListener);
      }, c.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", c.Listeners.Basic.toggleListener);
      }, c.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", c.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", c.Listeners.Basic.closeableListener);
      }, c.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", c.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", c.Listeners.Basic.toggleFocusListener);
      }, c.Listeners.Global = {
        resizeListener: function (t) {
          l || t.each(function () {
            s()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          l || t.each(function () {
            s()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          s()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = s()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, c.Initializers.addClosemeListener = function (t) {
        var e = s()("[data-yeti-box]"),
            n = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? n.push(t) : "object" === a(t) && "string" == typeof t[0] ? n = n.concat(t) : console.error("Plugin names must be strings")), e.length && (n = n.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), s()(window).off(n).on(n, c.Listeners.Global.closeMeListener));
      }, c.Initializers.addResizeListener = function (t) {
        var e = s()("[data-resize]");
        e.length && f(t, "resize.zf.trigger", c.Listeners.Global.resizeListener, e);
      }, c.Initializers.addScrollListener = function (t) {
        var e = s()("[data-scroll]");
        e.length && f(t, "scroll.zf.trigger", c.Listeners.Global.scrollListener, e);
      }, c.Initializers.addMutationEventsListener = function (t) {
        if (!l) return !1;

        function e(t) {
          var e = s()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var n = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (n.length) for (var i = 0; i <= n.length - 1; i++) new l(e).observe(n[i], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, c.Initializers.addSimpleListeners = function () {
        var t = s()(document);
        c.Initializers.addOpenListener(t), c.Initializers.addCloseListener(t), c.Initializers.addToggleListener(t), c.Initializers.addCloseableListener(t), c.Initializers.addToggleFocusListener(t);
      }, c.Initializers.addGlobalListeners = function () {
        var t = s()(document);
        c.Initializers.addMutationEventsListener(t), c.Initializers.addResizeListener(), c.Initializers.addScrollListener(), c.Initializers.addClosemeListener();
      }, c.init = function (t, e) {
        Object(i.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (c.Initializers.addSimpleListeners(), c.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = c, e.IHearYou = c.Initializers.addGlobalListeners);
      };
    },
    9: function (t, e, n) {
      t.exports = n("./js/entries/plugins/foundation.offcanvas.js");
    },
    jquery: function (t, e) {
      t.exports = a;
    }
  }, c = {}, r.m = l, r.c = c, r.d = function (t, e, n) {
    r.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, r.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, r.t = function (e, t) {
    if (1 & t && (e = r(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (r.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var i in e) r.d(n, i, function (t) {
      return e[t];
    }.bind(null, i));
    return n;
  }, r.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return r.d(e, "a", e), e;
  }, r.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, r.p = "", r(r.s = 9);

  function r(t) {
    if (c[t]) return c[t].exports;
    var e = c[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return l[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports;
  }

  var l, c;
});
!function (e, n) {
  "object" == typeof exports && "object" == typeof module ? module.exports = n(require("./foundation.accordionMenu"), require("./foundation.core"), require("./foundation.drilldown"), require("./foundation.dropdownMenu"), require("./foundation.util.mediaQuery"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.accordionMenu", "./foundation.core", "./foundation.drilldown", "./foundation.dropdownMenu", "./foundation.util.mediaQuery", "jquery"], n) : "object" == typeof exports ? exports["foundation.responsiveMenu"] = n(require("./foundation.accordionMenu"), require("./foundation.core"), require("./foundation.drilldown"), require("./foundation.dropdownMenu"), require("./foundation.util.mediaQuery"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.responsiveMenu"] = n(e.__FOUNDATION_EXTERNAL__["foundation.accordionMenu"], e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.drilldown"], e.__FOUNDATION_EXTERNAL__["foundation.dropdownMenu"], e.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], e.jQuery));
}(window, function (t, o, r, u, i, s) {
  return a = {
    "./foundation.accordionMenu": function (e, n) {
      e.exports = t;
    },
    "./foundation.core": function (e, n) {
      e.exports = o;
    },
    "./foundation.drilldown": function (e, n) {
      e.exports = r;
    },
    "./foundation.dropdownMenu": function (e, n) {
      e.exports = u;
    },
    "./foundation.util.mediaQuery": function (e, n) {
      e.exports = i;
    },
    "./js/entries/plugins/foundation.responsiveMenu.js": function (e, n, t) {
      "use strict";

      t.r(n);
      var o = t("./foundation.core");
      t.d(n, "Foundation", function () {
        return o.Foundation;
      });
      var r = t("./js/foundation.responsiveMenu.js");
      t.d(n, "ResponsiveMenu", function () {
        return r.ResponsiveMenu;
      }), o.Foundation.plugin(r.ResponsiveMenu, "ResponsiveMenu");
    },
    "./js/foundation.responsiveMenu.js": function (e, n, t) {
      "use strict";

      t.r(n), t.d(n, "ResponsiveMenu", function () {
        return y;
      });
      var o = t("jquery"),
          u = t.n(o),
          i = t("./foundation.util.mediaQuery"),
          s = t("./foundation.core"),
          r = t("./foundation.dropdownMenu"),
          n = t("./foundation.drilldown"),
          o = t("./foundation.accordionMenu");

      function c(e) {
        return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function a(e, n) {
        for (var t = 0; t < n.length; t++) {
          var o = n[t];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
        }
      }

      function f(e, n) {
        return (f = Object.setPrototypeOf || function (e, n) {
          return e.__proto__ = n, e;
        })(e, n);
      }

      function l(t) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              n = d(t);
          return function (e, n) {
            {
              if (n && ("object" === c(n) || "function" == typeof n)) return n;
              if (void 0 !== n) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, o ? (e = d(this).constructor, Reflect.construct(n, arguments, e)) : n.apply(this, arguments));
        };
      }

      function d(e) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var p = {
        dropdown: {
          cssClass: "dropdown",
          plugin: r.DropdownMenu
        },
        drilldown: {
          cssClass: "drilldown",
          plugin: n.Drilldown
        },
        accordion: {
          cssClass: "accordion-menu",
          plugin: o.AccordionMenu
        }
      },
          y = function () {
        !function (e, n) {
          if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(n && n.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), n && f(e, n);
        }(r, s["Plugin"]);
        var e,
            n,
            t,
            o = l(r);

        function r() {
          return function (e, n) {
            if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function");
          }(this, r), o.apply(this, arguments);
        }

        return e = r, (n = [{
          key: "_setup",
          value: function (e, n) {
            this.$element = u()(e), this.rules = this.$element.data("responsive-menu"), this.currentMq = null, this.currentPlugin = null, this.className = "ResponsiveMenu", this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            if (i.MediaQuery._init(), "string" == typeof this.rules) {
              for (var e = {}, n = this.rules.split(" "), t = 0; t < n.length; t++) {
                var o = n[t].split("-"),
                    r = 1 < o.length ? o[0] : "small",
                    o = 1 < o.length ? o[1] : o[0];
                null !== p[o] && (e[r] = p[o]);
              }

              this.rules = e;
            }

            u.a.isEmptyObject(this.rules) || this._checkMediaQueries(), this.$element.attr("data-mutate", this.$element.attr("data-mutate") || Object(s.GetYoDigits)(6, "responsive-menu"));
          }
        }, {
          key: "_events",
          value: function () {
            var e = this;
            u()(window).on("changed.zf.mediaquery", function () {
              e._checkMediaQueries();
            });
          }
        }, {
          key: "_checkMediaQueries",
          value: function () {
            var n,
                t = this;
            u.a.each(this.rules, function (e) {
              i.MediaQuery.atLeast(e) && (n = e);
            }), n && (this.currentPlugin instanceof this.rules[n].plugin || (u.a.each(p, function (e, n) {
              t.$element.removeClass(n.cssClass);
            }), this.$element.addClass(this.rules[n].cssClass), this.currentPlugin && this.currentPlugin.destroy(), this.currentPlugin = new this.rules[n].plugin(this.$element, {})));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.currentPlugin.destroy(), u()(window).off(".zf.ResponsiveMenu");
          }
        }]) && a(e.prototype, n), t && a(e, t), r;
      }();

      y.defaults = {};
    },
    12: function (e, n, t) {
      e.exports = t("./js/entries/plugins/foundation.responsiveMenu.js");
    },
    jquery: function (e, n) {
      e.exports = s;
    }
  }, f = {}, c.m = a, c.c = f, c.d = function (e, n, t) {
    c.o(e, n) || Object.defineProperty(e, n, {
      enumerable: !0,
      get: t
    });
  }, c.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, c.t = function (n, e) {
    if (1 & e && (n = c(n)), 8 & e) return n;
    if (4 & e && "object" == typeof n && n && n.__esModule) return n;
    var t = Object.create(null);
    if (c.r(t), Object.defineProperty(t, "default", {
      enumerable: !0,
      value: n
    }), 2 & e && "string" != typeof n) for (var o in n) c.d(t, o, function (e) {
      return n[e];
    }.bind(null, o));
    return t;
  }, c.n = function (e) {
    var n = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return c.d(n, "a", n), n;
  }, c.o = function (e, n) {
    return Object.prototype.hasOwnProperty.call(e, n);
  }, c.p = "", c(c.s = 12);

  function c(e) {
    if (f[e]) return f[e].exports;
    var n = f[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return a[e].call(n.exports, n, n.exports, c), n.l = !0, n.exports;
  }

  var a, f;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.mediaQuery", "./foundation.util.motion", "jquery"], t) : "object" == typeof exports ? exports["foundation.responsiveToggle"] = t(require("./foundation.core"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.responsiveToggle"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], e.__FOUNDATION_EXTERNAL__["foundation.util.motion"], e.jQuery));
}(window, function (n, o, i, r) {
  return a = {
    "./foundation.core": function (e, t) {
      e.exports = n;
    },
    "./foundation.util.mediaQuery": function (e, t) {
      e.exports = o;
    },
    "./foundation.util.motion": function (e, t) {
      e.exports = i;
    },
    "./js/entries/plugins/foundation.responsiveToggle.js": function (e, t, n) {
      "use strict";

      n.r(t);
      var o = n("./foundation.core");
      n.d(t, "Foundation", function () {
        return o.Foundation;
      });
      var i = n("./js/foundation.responsiveToggle.js");
      n.d(t, "ResponsiveToggle", function () {
        return i.ResponsiveToggle;
      }), o.Foundation.plugin(i.ResponsiveToggle, "ResponsiveToggle");
    },
    "./js/foundation.responsiveToggle.js": function (e, t, n) {
      "use strict";

      n.r(t), n.d(t, "ResponsiveToggle", function () {
        return o;
      });
      var t = n("jquery"),
          r = n.n(t),
          u = n("./foundation.util.mediaQuery"),
          a = n("./foundation.util.motion"),
          s = n("./foundation.core");

      function i(e) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function f(e, t) {
        for (var n = 0; n < t.length; n++) {
          var o = t[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
        }
      }

      function l(e, t) {
        return (l = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        })(e, t);
      }

      function c(n) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              t = d(n);
          return function (e, t) {
            {
              if (t && ("object" === i(t) || "function" == typeof t)) return t;
              if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, o ? (e = d(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments));
        };
      }

      function d(e) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var o = function () {
        !function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), t && l(e, t);
        }(i, s["Plugin"]);
        var e,
            t,
            n,
            o = c(i);

        function i() {
          return function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, i), o.apply(this, arguments);
        }

        return e = i, (t = [{
          key: "_setup",
          value: function (e, t) {
            this.$element = r()(e), this.options = r.a.extend({}, i.defaults, this.$element.data(), t), this.className = "ResponsiveToggle", this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            u.MediaQuery._init();

            var e,
                t = this.$element.data("responsive-toggle");
            t || console.error("Your tab bar needs an ID of a Menu as the value of data-tab-bar."), this.$targetMenu = r()("#".concat(t)), this.$toggler = this.$element.find("[data-toggle]").filter(function () {
              var e = r()(this).data("toggle");
              return e === t || "" === e;
            }), this.options = r.a.extend({}, this.options, this.$targetMenu.data()), this.options.animate && (e = this.options.animate.split(" "), this.animationIn = e[0], this.animationOut = e[1] || null), this._update();
          }
        }, {
          key: "_events",
          value: function () {
            this._updateMqHandler = this._update.bind(this), r()(window).on("changed.zf.mediaquery", this._updateMqHandler), this.$toggler.on("click.zf.responsiveToggle", this.toggleMenu.bind(this));
          }
        }, {
          key: "_update",
          value: function () {
            u.MediaQuery.atLeast(this.options.hideFor) ? (this.$element.hide(), this.$targetMenu.show()) : (this.$element.show(), this.$targetMenu.hide());
          }
        }, {
          key: "toggleMenu",
          value: function () {
            var e = this;
            u.MediaQuery.atLeast(this.options.hideFor) || (this.options.animate ? this.$targetMenu.is(":hidden") ? a.Motion.animateIn(this.$targetMenu, this.animationIn, function () {
              e.$element.trigger("toggled.zf.responsiveToggle"), e.$targetMenu.find("[data-mutate]").triggerHandler("mutateme.zf.trigger");
            }) : a.Motion.animateOut(this.$targetMenu, this.animationOut, function () {
              e.$element.trigger("toggled.zf.responsiveToggle");
            }) : (this.$targetMenu.toggle(0), this.$targetMenu.find("[data-mutate]").trigger("mutateme.zf.trigger"), this.$element.trigger("toggled.zf.responsiveToggle")));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.responsiveToggle"), this.$toggler.off(".zf.responsiveToggle"), r()(window).off("changed.zf.mediaquery", this._updateMqHandler);
          }
        }]) && f(e.prototype, t), n && f(e, n), i;
      }();

      o.defaults = {
        hideFor: "medium",
        animate: !1
      };
    },
    13: function (e, t, n) {
      e.exports = n("./js/entries/plugins/foundation.responsiveToggle.js");
    },
    jquery: function (e, t) {
      e.exports = r;
    }
  }, s = {}, u.m = a, u.c = s, u.d = function (e, t, n) {
    u.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    });
  }, u.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, u.t = function (t, e) {
    if (1 & e && (t = u(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (u.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var o in t) u.d(n, o, function (e) {
      return t[e];
    }.bind(null, o));
    return n;
  }, u.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return u.d(t, "a", t), t;
  }, u.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, u.p = "", u(u.s = 13);

  function u(e) {
    if (s[e]) return s[e].exports;
    var t = s[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return a[e].call(t.exports, t, t.exports, u), t.l = !0, t.exports;
  }

  var a, s;
});
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t(require("./foundation.core"), require("./foundation.util.keyboard"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("./foundation.util.touch"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.keyboard", "./foundation.util.mediaQuery", "./foundation.util.motion", "./foundation.util.touch", "jquery"], t) : "object" == typeof exports ? exports["foundation.reveal"] = t(require("./foundation.core"), require("./foundation.util.keyboard"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("./foundation.util.touch"), require("jquery")) : (e.__FOUNDATION_EXTERNAL__ = e.__FOUNDATION_EXTERNAL__ || {}, e.__FOUNDATION_EXTERNAL__["foundation.reveal"] = t(e.__FOUNDATION_EXTERNAL__["foundation.core"], e.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], e.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], e.__FOUNDATION_EXTERNAL__["foundation.util.motion"], e.__FOUNDATION_EXTERNAL__["foundation.util.touch"], e.jQuery));
}(window, function (i, o, n, s, r, a) {
  return c = {
    "./foundation.core": function (e, t) {
      e.exports = i;
    },
    "./foundation.util.keyboard": function (e, t) {
      e.exports = o;
    },
    "./foundation.util.mediaQuery": function (e, t) {
      e.exports = n;
    },
    "./foundation.util.motion": function (e, t) {
      e.exports = s;
    },
    "./foundation.util.touch": function (e, t) {
      e.exports = r;
    },
    "./js/entries/plugins/foundation.reveal.js": function (e, t, i) {
      "use strict";

      i.r(t);
      var o = i("./foundation.core");
      i.d(t, "Foundation", function () {
        return o.Foundation;
      });
      var n = i("./js/foundation.reveal.js");
      i.d(t, "Reveal", function () {
        return n.Reveal;
      }), o.Foundation.plugin(n.Reveal, "Reveal");
    },
    "./js/foundation.reveal.js": function (e, t, i) {
      "use strict";

      i.r(t), i.d(t, "Reveal", function () {
        return o;
      });
      var t = i("jquery"),
          s = i.n(t),
          r = i("./foundation.core"),
          a = i("./foundation.util.keyboard"),
          l = i("./foundation.util.mediaQuery"),
          c = i("./foundation.util.motion"),
          u = i("./js/foundation.util.triggers.js"),
          d = i("./foundation.util.touch");

      function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function f(e, t) {
        for (var i = 0; i < t.length; i++) {
          var o = t[i];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
        }
      }

      function h(e, t) {
        return (h = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        })(e, t);
      }

      function p(i) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var e,
              t = g(i);
          return function (e, t) {
            {
              if (t && ("object" === n(t) || "function" == typeof t)) return t;
              if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (e) {
              if (void 0 !== e) return e;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(e);
          }(this, o ? (e = g(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments));
        };
      }

      function g(e) {
        return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      var o = function () {
        !function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), t && h(e, t);
        }(n, r["Plugin"]);
        var e,
            t,
            i,
            o = p(n);

        function n() {
          return function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, n), o.apply(this, arguments);
        }

        return e = n, (t = [{
          key: "_setup",
          value: function (e, t) {
            this.$element = e, this.options = s.a.extend({}, n.defaults, this.$element.data(), t), this.className = "Reveal", this._init(), d.Touch.init(s.a), u.Triggers.init(s.a), a.Keyboard.register("Reveal", {
              ESCAPE: "close"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var e = this;
            l.MediaQuery._init(), this.id = this.$element.attr("id"), this.isActive = !1, this.cached = {
              mq: l.MediaQuery.current
            }, this.$anchor = s()('[data-open="'.concat(this.id, '"]')).length ? s()('[data-open="'.concat(this.id, '"]')) : s()('[data-toggle="'.concat(this.id, '"]')), this.$anchor.attr({
              "aria-controls": this.id,
              "aria-haspopup": "dialog",
              tabindex: 0
            }), (this.options.fullScreen || this.$element.hasClass("full")) && (this.options.fullScreen = !0, this.options.overlay = !1), this.options.overlay && !this.$overlay && (this.$overlay = this._makeOverlay(this.id)), this.$element.attr({
              role: "dialog",
              "aria-hidden": !0,
              "data-yeti-box": this.id,
              "data-resize": this.id
            }), this.$overlay ? this.$element.detach().appendTo(this.$overlay) : (this.$element.detach().appendTo(s()(this.options.appendTo)), this.$element.addClass("without-overlay")), this._events(), this.options.deepLink && window.location.hash === "#".concat(this.id) && (this.onLoadListener = Object(r.onLoad)(s()(window), function () {
              return e.open();
            }));
          }
        }, {
          key: "_makeOverlay",
          value: function () {
            var e = "";
            return this.options.additionalOverlayClasses && (e = " " + this.options.additionalOverlayClasses), s()("<div></div>").addClass("reveal-overlay" + e).appendTo(this.options.appendTo);
          }
        }, {
          key: "_updatePosition",
          value: function () {
            var e = this.$element.outerWidth(),
                t = s()(window).width(),
                i = this.$element.outerHeight(),
                o = s()(window).height(),
                n = null,
                e = "auto" === this.options.hOffset ? parseInt((t - e) / 2, 10) : parseInt(this.options.hOffset, 10);
            "auto" === this.options.vOffset ? n = o < i ? parseInt(Math.min(100, o / 10), 10) : parseInt((o - i) / 4, 10) : null !== this.options.vOffset && (n = parseInt(this.options.vOffset, 10)), null !== n && this.$element.css({
              top: n + "px"
            }), this.$overlay && "auto" === this.options.hOffset || (this.$element.css({
              left: e + "px"
            }), this.$element.css({
              margin: "0px"
            }));
          }
        }, {
          key: "_events",
          value: function () {
            var i = this,
                o = this;
            this.$element.on({
              "open.zf.trigger": this.open.bind(this),
              "close.zf.trigger": function (e, t) {
                if (e.target === o.$element[0] || s()(e.target).parents("[data-closable]")[0] === t) return i.close.apply(i);
              },
              "toggle.zf.trigger": this.toggle.bind(this),
              "resizeme.zf.trigger": function () {
                o._updatePosition();
              }
            }), this.options.closeOnClick && this.options.overlay && this.$overlay.off(".zf.reveal").on("click.zf.dropdown tap.zf.dropdown", function (e) {
              e.target !== o.$element[0] && !s.a.contains(o.$element[0], e.target) && s.a.contains(document, e.target) && o.close();
            }), this.options.deepLink && s()(window).on("hashchange.zf.reveal:".concat(this.id), this._handleState.bind(this));
          }
        }, {
          key: "_handleState",
          value: function (e) {
            window.location.hash !== "#" + this.id || this.isActive ? this.close() : this.open();
          }
        }, {
          key: "_disableScroll",
          value: function (e) {
            e = e || s()(window).scrollTop(), s()(document).height() > s()(window).height() && s()("html").css("top", -e);
          }
        }, {
          key: "_enableScroll",
          value: function (e) {
            e = e || parseInt(s()("html").css("top")), s()(document).height() > s()(window).height() && (s()("html").css("top", ""), s()(window).scrollTop(-e));
          }
        }, {
          key: "open",
          value: function () {
            var e = this,
                t = "#".concat(this.id);
            this.options.deepLink && window.location.hash !== t && (window.history.pushState ? this.options.updateHistory ? window.history.pushState({}, "", t) : window.history.replaceState({}, "", t) : window.location.hash = t), this.$activeAnchor = s()(document.activeElement).is(this.$anchor) ? s()(document.activeElement) : this.$anchor, this.isActive = !0, this.$element.css({
              visibility: "hidden"
            }).show().scrollTop(0), this.options.overlay && this.$overlay.css({
              visibility: "hidden"
            }).show(), this._updatePosition(), this.$element.hide().css({
              visibility: ""
            }), this.$overlay && (this.$overlay.css({
              visibility: ""
            }).hide(), this.$element.hasClass("fast") ? this.$overlay.addClass("fast") : this.$element.hasClass("slow") && this.$overlay.addClass("slow")), this.options.multipleOpened || this.$element.trigger("closeme.zf.reveal", this.id), 0 === s()(".reveal:visible").length && this._disableScroll();
            var i = this;
            this.options.animationIn ? (this.options.overlay && c.Motion.animateIn(this.$overlay, "fade-in"), c.Motion.animateIn(this.$element, this.options.animationIn, function () {
              e.$element && (e.focusableElements = a.Keyboard.findFocusable(e.$element), i.$element.attr({
                "aria-hidden": !1,
                tabindex: -1
              }).focus(), i._addGlobalClasses(), a.Keyboard.trapFocus(i.$element));
            })) : (this.options.overlay && this.$overlay.show(0), this.$element.show(this.options.showDelay)), this.$element.attr({
              "aria-hidden": !1,
              tabindex: -1
            }).focus(), a.Keyboard.trapFocus(this.$element), this._addGlobalClasses(), this._addGlobalListeners(), this.$element.trigger("open.zf.reveal");
          }
        }, {
          key: "_addGlobalClasses",
          value: function () {
            function e() {
              s()("html").toggleClass("zf-has-scroll", !!(s()(document).height() > s()(window).height()));
            }

            this.$element.on("resizeme.zf.trigger.revealScrollbarListener", e), e(), s()("html").addClass("is-reveal-open");
          }
        }, {
          key: "_removeGlobalClasses",
          value: function () {
            this.$element.off("resizeme.zf.trigger.revealScrollbarListener"), s()("html").removeClass("is-reveal-open"), s()("html").removeClass("zf-has-scroll");
          }
        }, {
          key: "_addGlobalListeners",
          value: function () {
            var t = this;
            this.$element && (this.focusableElements = a.Keyboard.findFocusable(this.$element), this.options.overlay || !this.options.closeOnClick || this.options.fullScreen || s()("body").on("click.zf.dropdown tap.zf.dropdown", function (e) {
              e.target !== t.$element[0] && !s.a.contains(t.$element[0], e.target) && s.a.contains(document, e.target) && t.close();
            }), this.options.closeOnEsc && s()(window).on("keydown.zf.reveal", function (e) {
              a.Keyboard.handleKey(e, "Reveal", {
                close: function () {
                  t.options.closeOnEsc && t.close();
                }
              });
            }));
          }
        }, {
          key: "close",
          value: function () {
            if (!this.isActive || !this.$element.is(":visible")) return !1;
            var e,
                t = this;

            function i() {
              var e = parseInt(s()("html").css("top"));
              0 === s()(".reveal:visible").length && t._removeGlobalClasses(), a.Keyboard.releaseFocus(t.$element), t.$element.attr("aria-hidden", !0), 0 === s()(".reveal:visible").length && t._enableScroll(e), t.$element.trigger("closed.zf.reveal");
            }

            this.options.animationOut ? (this.options.overlay && c.Motion.animateOut(this.$overlay, "fade-out"), c.Motion.animateOut(this.$element, this.options.animationOut, i)) : (this.$element.hide(this.options.hideDelay), this.options.overlay ? this.$overlay.hide(0, i) : i()), this.options.closeOnEsc && s()(window).off("keydown.zf.reveal"), !this.options.overlay && this.options.closeOnClick && s()("body").off("click.zf.dropdown tap.zf.dropdown"), this.$element.off("keydown.zf.reveal"), this.options.resetOnClose && this.$element.html(this.$element.html()), this.isActive = !1, t.options.deepLink && window.location.hash === "#".concat(this.id) && (window.history.replaceState ? (e = window.location.pathname + window.location.search, this.options.updateHistory ? window.history.pushState({}, "", e) : window.history.replaceState("", document.title, e)) : window.location.hash = ""), this.$activeAnchor.focus();
          }
        }, {
          key: "toggle",
          value: function () {
            this.isActive ? this.close() : this.open();
          }
        }, {
          key: "_destroy",
          value: function () {
            this.options.overlay && (this.$element.appendTo(s()(this.options.appendTo)), this.$overlay.hide().off().remove()), this.$element.hide().off(), this.$anchor.off(".zf"), s()(window).off(".zf.reveal:".concat(this.id)), this.onLoadListener && s()(window).off(this.onLoadListener), 0 === s()(".reveal:visible").length && this._removeGlobalClasses();
          }
        }]) && f(e.prototype, t), i && f(e, i), n;
      }();

      o.defaults = {
        animationIn: "",
        animationOut: "",
        showDelay: 0,
        hideDelay: 0,
        closeOnClick: !0,
        closeOnEsc: !0,
        multipleOpened: !1,
        vOffset: "auto",
        hOffset: "auto",
        fullScreen: !1,
        overlay: !0,
        resetOnClose: !1,
        deepLink: !1,
        updateHistory: !1,
        appendTo: "body",
        additionalOverlayClasses: ""
      };
    },
    "./js/foundation.util.triggers.js": function (e, t, i) {
      "use strict";

      i.r(t), i.d(t, "Triggers", function () {
        return c;
      });
      var t = i("jquery"),
          s = i.n(t),
          o = i("./foundation.core"),
          n = i("./foundation.util.motion");

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function a(t, i) {
        t.data(i).split(" ").forEach(function (e) {
          s()("#".concat(e))["close" === i ? "trigger" : "triggerHandler"]("".concat(i, ".zf.trigger"), [t]);
        });
      }

      var l = function () {
        for (var e = ["WebKit", "Moz", "O", "Ms", ""], t = 0; t < e.length; t++) if ("".concat(e[t], "MutationObserver") in window) return window["".concat(e[t], "MutationObserver")];

        return !1;
      }(),
          c = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function u(t, e, i) {
        var o,
            n = Array.prototype.slice.call(arguments, 3);
        s()(window).off(e).on(e, function (e) {
          o && clearTimeout(o), o = setTimeout(function () {
            i.apply(null, n);
          }, t || 10);
        });
      }

      c.Listeners.Basic = {
        openListener: function () {
          a(s()(this), "open");
        },
        closeListener: function () {
          s()(this).data("close") ? a(s()(this), "close") : s()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          s()(this).data("toggle") ? a(s()(this), "toggle") : s()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (e) {
          var t = s()(this).data("closable");
          e.stopPropagation(), "" !== t ? n.Motion.animateOut(s()(this), t, function () {
            s()(this).trigger("closed.zf");
          }) : s()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var e = s()(this).data("toggle-focus");
          s()("#".concat(e)).triggerHandler("toggle.zf.trigger", [s()(this)]);
        }
      }, c.Initializers.addOpenListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.openListener), e.on("click.zf.trigger", "[data-open]", c.Listeners.Basic.openListener);
      }, c.Initializers.addCloseListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.closeListener), e.on("click.zf.trigger", "[data-close]", c.Listeners.Basic.closeListener);
      }, c.Initializers.addToggleListener = function (e) {
        e.off("click.zf.trigger", c.Listeners.Basic.toggleListener), e.on("click.zf.trigger", "[data-toggle]", c.Listeners.Basic.toggleListener);
      }, c.Initializers.addCloseableListener = function (e) {
        e.off("close.zf.trigger", c.Listeners.Basic.closeableListener), e.on("close.zf.trigger", "[data-closeable], [data-closable]", c.Listeners.Basic.closeableListener);
      }, c.Initializers.addToggleFocusListener = function (e) {
        e.off("focus.zf.trigger blur.zf.trigger", c.Listeners.Basic.toggleFocusListener), e.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", c.Listeners.Basic.toggleFocusListener);
      }, c.Listeners.Global = {
        resizeListener: function (e) {
          l || e.each(function () {
            s()(this).triggerHandler("resizeme.zf.trigger");
          }), e.attr("data-events", "resize");
        },
        scrollListener: function (e) {
          l || e.each(function () {
            s()(this).triggerHandler("scrollme.zf.trigger");
          }), e.attr("data-events", "scroll");
        },
        closeMeListener: function (e, t) {
          e = e.namespace.split(".")[0];
          s()("[data-".concat(e, "]")).not('[data-yeti-box="'.concat(t, '"]')).each(function () {
            var e = s()(this);
            e.triggerHandler("close.zf.trigger", [e]);
          });
        }
      }, c.Initializers.addClosemeListener = function (e) {
        var t = s()("[data-yeti-box]"),
            i = ["dropdown", "tooltip", "reveal"];
        e && ("string" == typeof e ? i.push(e) : "object" === r(e) && "string" == typeof e[0] ? i = i.concat(e) : console.error("Plugin names must be strings")), t.length && (i = i.map(function (e) {
          return "closeme.zf.".concat(e);
        }).join(" "), s()(window).off(i).on(i, c.Listeners.Global.closeMeListener));
      }, c.Initializers.addResizeListener = function (e) {
        var t = s()("[data-resize]");
        t.length && u(e, "resize.zf.trigger", c.Listeners.Global.resizeListener, t);
      }, c.Initializers.addScrollListener = function (e) {
        var t = s()("[data-scroll]");
        t.length && u(e, "scroll.zf.trigger", c.Listeners.Global.scrollListener, t);
      }, c.Initializers.addMutationEventsListener = function (e) {
        if (!l) return !1;

        function t(e) {
          var t = s()(e[0].target);

          switch (e[0].type) {
            case "attributes":
              "scroll" === t.attr("data-events") && "data-events" === e[0].attributeName && t.triggerHandler("scrollme.zf.trigger", [t, window.pageYOffset]), "resize" === t.attr("data-events") && "data-events" === e[0].attributeName && t.triggerHandler("resizeme.zf.trigger", [t]), "style" === e[0].attributeName && (t.closest("[data-mutate]").attr("data-events", "mutate"), t.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [t.closest("[data-mutate]")]));
              break;

            case "childList":
              t.closest("[data-mutate]").attr("data-events", "mutate"), t.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [t.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var i = e.find("[data-resize], [data-scroll], [data-mutate]");
        if (i.length) for (var o = 0; o <= i.length - 1; o++) new l(t).observe(i[o], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, c.Initializers.addSimpleListeners = function () {
        var e = s()(document);
        c.Initializers.addOpenListener(e), c.Initializers.addCloseListener(e), c.Initializers.addToggleListener(e), c.Initializers.addCloseableListener(e), c.Initializers.addToggleFocusListener(e);
      }, c.Initializers.addGlobalListeners = function () {
        var e = s()(document);
        c.Initializers.addMutationEventsListener(e), c.Initializers.addResizeListener(), c.Initializers.addScrollListener(), c.Initializers.addClosemeListener();
      }, c.init = function (e, t) {
        Object(o.onLoad)(e(window), function () {
          !0 !== e.triggersInitialized && (c.Initializers.addSimpleListeners(), c.Initializers.addGlobalListeners(), e.triggersInitialized = !0);
        }), t && (t.Triggers = c, t.IHearYou = c.Initializers.addGlobalListeners);
      };
    },
    14: function (e, t, i) {
      e.exports = i("./js/entries/plugins/foundation.reveal.js");
    },
    jquery: function (e, t) {
      e.exports = a;
    }
  }, u = {}, l.m = c, l.c = u, l.d = function (e, t, i) {
    l.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: i
    });
  }, l.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, l.t = function (t, e) {
    if (1 & e && (t = l(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var i = Object.create(null);
    if (l.r(i), Object.defineProperty(i, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var o in t) l.d(i, o, function (e) {
      return t[e];
    }.bind(null, o));
    return i;
  }, l.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default;
    } : function () {
      return e;
    };
    return l.d(t, "a", t), t;
  }, l.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, l.p = "", l(l.s = 14);

  function l(e) {
    if (u[e]) return u[e].exports;
    var t = u[e] = {
      i: e,
      l: !1,
      exports: {}
    };
    return c[e].call(t.exports, t, t.exports, l), t.l = !0, t.exports;
  }

  var c, u;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.mediaQuery", "./foundation.util.motion", "jquery"], e) : "object" == typeof exports ? exports["foundation.sticky"] = e(require("./foundation.core"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.sticky"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], t.__FOUNDATION_EXTERNAL__["foundation.util.motion"], t.jQuery));
}(window, function (i, n, o, s) {
  return a = {
    "./foundation.core": function (t, e) {
      t.exports = i;
    },
    "./foundation.util.mediaQuery": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.motion": function (t, e) {
      t.exports = o;
    },
    "./js/entries/plugins/foundation.sticky.js": function (t, e, i) {
      "use strict";

      i.r(e);
      var n = i("./foundation.core");
      i.d(e, "Foundation", function () {
        return n.Foundation;
      });
      var o = i("./js/foundation.sticky.js");
      i.d(e, "Sticky", function () {
        return o.Sticky;
      }), n.Foundation.plugin(o.Sticky, "Sticky");
    },
    "./js/foundation.sticky.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Sticky", function () {
        return n;
      });
      var e = i("jquery"),
          a = i.n(e),
          s = i("./foundation.core"),
          r = i("./foundation.util.mediaQuery"),
          c = i("./js/foundation.util.triggers.js");

      function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var i = 0; i < e.length; i++) {
          var n = e[i];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
      }

      function l(t, e) {
        return (l = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(i) {
        var n = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = d(i);
          return function (t, e) {
            {
              if (e && ("object" === o(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, n ? (t = d(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var n = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && l(t, e);
        }(o, s["Plugin"]);
        var t,
            e,
            i,
            n = f(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), n.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = a.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Sticky", c.Triggers.init(a.a), this._init();
          }
        }, {
          key: "_init",
          value: function () {
            r.MediaQuery._init();

            var t = this.$element.parent("[data-sticky-container]"),
                e = this.$element[0].id || Object(s.GetYoDigits)(6, "sticky"),
                i = this;
            t.length ? this.$container = t : (this.wasWrapped = !0, this.$element.wrap(this.options.container), this.$container = this.$element.parent()), this.$container.addClass(this.options.containerClass), this.$element.addClass(this.options.stickyClass).attr({
              "data-resize": e,
              "data-mutate": e
            }), "" !== this.options.anchor && a()("#" + i.options.anchor).attr({
              "data-mutate": e
            }), this.scrollCount = this.options.checkEvery, this.isStuck = !1, this.onLoadListener = Object(s.onLoad)(a()(window), function () {
              i.containerHeight = "none" == i.$element.css("display") ? 0 : i.$element[0].getBoundingClientRect().height, i.$container.css("height", i.containerHeight), i.elemHeight = i.containerHeight, "" !== i.options.anchor ? i.$anchor = a()("#" + i.options.anchor) : i._parsePoints(), i._setSizes(function () {
                var t = window.pageYOffset;
                i._calc(!1, t), i.isStuck || i._removeSticky(!(t >= i.topPoint));
              }), i._events(e.split("-").reverse().join("-"));
            });
          }
        }, {
          key: "_parsePoints",
          value: function () {
            for (var t, e, i, n = ["" == this.options.topAnchor ? 1 : this.options.topAnchor, "" == this.options.btmAnchor ? document.documentElement.scrollHeight : this.options.btmAnchor], o = {}, s = 0, r = n.length; s < r && n[s]; s++) "number" == typeof n[s] ? i = n[s] : (t = n[s].split(":"), i = (e = a()("#".concat(t[0]))).offset().top, t[1] && "bottom" === t[1].toLowerCase() && (i += e[0].getBoundingClientRect().height)), o[s] = i;

            this.points = o;
          }
        }, {
          key: "_events",
          value: function (i) {
            var n = this,
                t = this.scrollListener = "scroll.zf.".concat(i);
            this.isOn || (this.canStick && (this.isOn = !0, a()(window).off(t).on(t, function (t) {
              0 === n.scrollCount ? (n.scrollCount = n.options.checkEvery, n._setSizes(function () {
                n._calc(!1, window.pageYOffset);
              })) : (n.scrollCount--, n._calc(!1, window.pageYOffset));
            })), this.$element.off("resizeme.zf.trigger").on("resizeme.zf.trigger", function (t, e) {
              n._eventsHandler(i);
            }), this.$element.on("mutateme.zf.trigger", function (t, e) {
              n._eventsHandler(i);
            }), this.$anchor && this.$anchor.on("mutateme.zf.trigger", function (t, e) {
              n._eventsHandler(i);
            }));
          }
        }, {
          key: "_eventsHandler",
          value: function (t) {
            var e = this,
                i = this.scrollListener = "scroll.zf.".concat(t);

            e._setSizes(function () {
              e._calc(!1), e.canStick ? e.isOn || e._events(t) : e.isOn && e._pauseListeners(i);
            });
          }
        }, {
          key: "_pauseListeners",
          value: function (t) {
            this.isOn = !1, a()(window).off(t), this.$element.trigger("pause.zf.sticky");
          }
        }, {
          key: "_calc",
          value: function (t, e) {
            if (t && this._setSizes(), !this.canStick) return this.isStuck && this._removeSticky(!0), !1;
            (e = e || window.pageYOffset) >= this.topPoint ? e <= this.bottomPoint ? this.isStuck || this._setSticky() : this.isStuck && this._removeSticky(!1) : this.isStuck && this._removeSticky(!0);
          }
        }, {
          key: "_setSticky",
          value: function () {
            var t = this,
                e = this.options.stickTo,
                i = "top" === e ? "marginTop" : "marginBottom",
                n = "top" === e ? "bottom" : "top",
                o = {};
            o[i] = "".concat(this.options[i], "em"), o[e] = 0, o[n] = "auto", this.isStuck = !0, this.$element.removeClass("is-anchored is-at-".concat(n)).addClass("is-stuck is-at-".concat(e)).css(o).trigger("sticky.zf.stuckto:".concat(e)), this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function () {
              t._setSizes();
            });
          }
        }, {
          key: "_removeSticky",
          value: function (t) {
            var e = this.options.stickTo,
                i = {},
                n = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,
                o = t ? "top" : "bottom";
            i["top" === e ? "marginTop" : "marginBottom"] = 0, i.bottom = "auto", i.top = t ? 0 : n, this.isStuck = !1, this.$element.removeClass("is-stuck is-at-".concat(e)).addClass("is-anchored is-at-".concat(o)).css(i).trigger("sticky.zf.unstuckfrom:".concat(o));
          }
        }, {
          key: "_setSizes",
          value: function (t) {
            this.canStick = r.MediaQuery.is(this.options.stickyOn), this.canStick || t && "function" == typeof t && t();
            var e,
                i = this.$container[0].getBoundingClientRect().width,
                n = window.getComputedStyle(this.$container[0]),
                o = parseInt(n["padding-left"], 10),
                n = parseInt(n["padding-right"], 10);
            this.$anchor && this.$anchor.length ? this.anchorHeight = this.$anchor[0].getBoundingClientRect().height : this._parsePoints(), this.$element.css({
              "max-width": "".concat(i - o - n, "px")
            }), !this.options.dynamicHeight && this.containerHeight || (e = this.$element[0].getBoundingClientRect().height || this.containerHeight, e = "none" == this.$element.css("display") ? 0 : e, this.$container.css("height", e), this.containerHeight = e), this.elemHeight = this.containerHeight, this.isStuck || this.$element.hasClass("is-at-bottom") && (e = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight, this.$element.css("top", e)), this._setBreakPoints(this.containerHeight, function () {
              t && "function" == typeof t && t();
            });
          }
        }, {
          key: "_setBreakPoints",
          value: function (t, e) {
            if (!this.canStick) {
              if (!e || "function" != typeof e) return !1;
              e();
            }

            var i = h(this.options.marginTop),
                n = h(this.options.marginBottom),
                o = this.points ? this.points[0] : this.$anchor.offset().top,
                s = this.points ? this.points[1] : o + this.anchorHeight,
                r = window.innerHeight;
            "top" === this.options.stickTo ? (o -= i, s -= t + i) : "bottom" === this.options.stickTo && (o -= r - (t + n), s -= r - n), this.topPoint = o, this.bottomPoint = s, e && "function" == typeof e && e();
          }
        }, {
          key: "_destroy",
          value: function () {
            this._removeSticky(!0), this.$element.removeClass("".concat(this.options.stickyClass, " is-anchored is-at-top")).css({
              height: "",
              top: "",
              bottom: "",
              "max-width": ""
            }).off("resizeme.zf.trigger").off("mutateme.zf.trigger"), this.$anchor && this.$anchor.length && this.$anchor.off("change.zf.sticky"), this.scrollListener && a()(window).off(this.scrollListener), this.onLoadListener && a()(window).off(this.onLoadListener), this.wasWrapped ? this.$element.unwrap() : this.$container.removeClass(this.options.containerClass).css({
              height: ""
            });
          }
        }]) && u(t.prototype, e), i && u(t, i), o;
      }();

      function h(t) {
        return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * t;
      }

      n.defaults = {
        container: "<div data-sticky-container></div>",
        stickTo: "top",
        anchor: "",
        topAnchor: "",
        btmAnchor: "",
        marginTop: 1,
        marginBottom: 1,
        stickyOn: "medium",
        stickyClass: "sticky",
        containerClass: "sticky-container",
        dynamicHeight: !0,
        checkEvery: -1
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Triggers", function () {
        return u;
      });
      var e = i("jquery"),
          s = i.n(e),
          n = i("./foundation.core"),
          o = i("./foundation.util.motion");

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(e, i) {
        e.data(i).split(" ").forEach(function (t) {
          s()("#".concat(t))["close" === i ? "trigger" : "triggerHandler"]("".concat(i, ".zf.trigger"), [e]);
        });
      }

      var c = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          u = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function l(e, t, i) {
        var n,
            o = Array.prototype.slice.call(arguments, 3);
        s()(window).off(t).on(t, function (t) {
          n && clearTimeout(n), n = setTimeout(function () {
            i.apply(null, o);
          }, e || 10);
        });
      }

      u.Listeners.Basic = {
        openListener: function () {
          a(s()(this), "open");
        },
        closeListener: function () {
          s()(this).data("close") ? a(s()(this), "close") : s()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          s()(this).data("toggle") ? a(s()(this), "toggle") : s()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = s()(this).data("closable");
          t.stopPropagation(), "" !== e ? o.Motion.animateOut(s()(this), e, function () {
            s()(this).trigger("closed.zf");
          }) : s()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = s()(this).data("toggle-focus");
          s()("#".concat(t)).triggerHandler("toggle.zf.trigger", [s()(this)]);
        }
      }, u.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", u.Listeners.Basic.openListener);
      }, u.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", u.Listeners.Basic.closeListener);
      }, u.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", u.Listeners.Basic.toggleListener);
      }, u.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", u.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", u.Listeners.Basic.closeableListener);
      }, u.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", u.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", u.Listeners.Basic.toggleFocusListener);
      }, u.Listeners.Global = {
        resizeListener: function (t) {
          c || t.each(function () {
            s()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          c || t.each(function () {
            s()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          s()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = s()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, u.Initializers.addClosemeListener = function (t) {
        var e = s()("[data-yeti-box]"),
            i = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? i.push(t) : "object" === r(t) && "string" == typeof t[0] ? i = i.concat(t) : console.error("Plugin names must be strings")), e.length && (i = i.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), s()(window).off(i).on(i, u.Listeners.Global.closeMeListener));
      }, u.Initializers.addResizeListener = function (t) {
        var e = s()("[data-resize]");
        e.length && l(t, "resize.zf.trigger", u.Listeners.Global.resizeListener, e);
      }, u.Initializers.addScrollListener = function (t) {
        var e = s()("[data-scroll]");
        e.length && l(t, "scroll.zf.trigger", u.Listeners.Global.scrollListener, e);
      }, u.Initializers.addMutationEventsListener = function (t) {
        if (!c) return !1;

        function e(t) {
          var e = s()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var i = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (i.length) for (var n = 0; n <= i.length - 1; n++) new c(e).observe(i[n], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, u.Initializers.addSimpleListeners = function () {
        var t = s()(document);
        u.Initializers.addOpenListener(t), u.Initializers.addCloseListener(t), u.Initializers.addToggleListener(t), u.Initializers.addCloseableListener(t), u.Initializers.addToggleFocusListener(t);
      }, u.Initializers.addGlobalListeners = function () {
        var t = s()(document);
        u.Initializers.addMutationEventsListener(t), u.Initializers.addResizeListener(), u.Initializers.addScrollListener(), u.Initializers.addClosemeListener();
      }, u.init = function (t, e) {
        Object(n.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (u.Initializers.addSimpleListeners(), u.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = u, e.IHearYou = u.Initializers.addGlobalListeners);
      };
    },
    17: function (t, e, i) {
      t.exports = i("./js/entries/plugins/foundation.sticky.js");
    },
    jquery: function (t, e) {
      t.exports = s;
    }
  }, c = {}, r.m = a, r.c = c, r.d = function (t, e, i) {
    r.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: i
    });
  }, r.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, r.t = function (e, t) {
    if (1 & t && (e = r(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var i = Object.create(null);
    if (r.r(i), Object.defineProperty(i, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var n in e) r.d(i, n, function (t) {
      return e[t];
    }.bind(null, n));
    return i;
  }, r.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return r.d(e, "a", e), e;
  }, r.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, r.p = "", r(r.s = 17);

  function r(t) {
    if (c[t]) return c[t].exports;
    var e = c[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return a[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports;
  }

  var a, c;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.imageLoader"), require("./foundation.util.keyboard"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.imageLoader", "./foundation.util.keyboard", "jquery"], e) : "object" == typeof exports ? exports["foundation.tabs"] = e(require("./foundation.core"), require("./foundation.util.imageLoader"), require("./foundation.util.keyboard"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.tabs"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.imageLoader"], t.__FOUNDATION_EXTERNAL__["foundation.util.keyboard"], t.jQuery));
}(window, function (n, i, o, a) {
  return r = {
    "./foundation.core": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.imageLoader": function (t, e) {
      t.exports = i;
    },
    "./foundation.util.keyboard": function (t, e) {
      t.exports = o;
    },
    "./js/entries/plugins/foundation.tabs.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var i = n("./foundation.core");
      n.d(e, "Foundation", function () {
        return i.Foundation;
      });
      var o = n("./js/foundation.tabs.js");
      n.d(e, "Tabs", function () {
        return o.Tabs;
      }), i.Foundation.plugin(o.Tabs, "Tabs");
    },
    "./js/foundation.tabs.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Tabs", function () {
        return i;
      });
      var e = n("jquery"),
          r = n.n(e),
          c = n("./foundation.core"),
          s = n("./foundation.util.keyboard"),
          a = n("./foundation.util.imageLoader");

      function l(t) {
        return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function u(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function f(t, e) {
        return (f = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = o(n);
          return function (t, e) {
            {
              if (e && ("object" === l(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = o(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function o(t) {
        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && f(t, e);
        }(o, c["Plugin"]);
        var t,
            e,
            n,
            i = d(o);

        function o() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, o), i.apply(this, arguments);
        }

        return t = o, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = r.a.extend({}, o.defaults, this.$element.data(), e), this.className = "Tabs", this._init(), s.Keyboard.register("Tabs", {
              ENTER: "open",
              SPACE: "open",
              ARROW_RIGHT: "next",
              ARROW_UP: "previous",
              ARROW_DOWN: "next",
              ARROW_LEFT: "previous"
            });
          }
        }, {
          key: "_init",
          value: function () {
            var t,
                i = this,
                s = this;
            this._isInitializing = !0, this.$element.attr({
              role: "tablist"
            }), this.$tabTitles = this.$element.find(".".concat(this.options.linkClass)), this.$tabContent = r()('[data-tabs-content="'.concat(this.$element[0].id, '"]')), this.$tabTitles.each(function () {
              var t = r()(this),
                  e = t.find("a"),
                  n = t.hasClass("".concat(s.options.linkActiveClass)),
                  i = e.attr("data-tabs-target") || e[0].hash.slice(1),
                  o = e[0].id || "".concat(i, "-label"),
                  a = r()("#".concat(i));
              t.attr({
                role: "presentation"
              }), e.attr({
                role: "tab",
                "aria-controls": i,
                "aria-selected": n,
                id: o,
                tabindex: n ? "0" : "-1"
              }), a.attr({
                role: "tabpanel",
                "aria-labelledby": o
              }), n && (s._initialAnchor = "#".concat(i)), n || a.attr("aria-hidden", "true"), n && s.options.autoFocus && (s.onLoadListener = Object(c.onLoad)(r()(window), function () {
                r()("html, body").animate({
                  scrollTop: t.offset().top
                }, s.options.deepLinkSmudgeDelay, function () {
                  e.focus();
                });
              }));
            }), this.options.matchHeight && ((t = this.$tabContent.find("img")).length ? Object(a.onImagesLoaded)(t, this._setHeight.bind(this)) : this._setHeight()), this._checkDeepLink = function () {
              var t = window.location.hash;

              if (!t.length) {
                if (i._isInitializing) return;
                i._initialAnchor && (t = i._initialAnchor);
              }

              var e = 0 <= t.indexOf("#") ? t.slice(1) : t,
                  n = e && r()("#".concat(e)),
                  t = t && i.$element.find('[href$="'.concat(t, '"],[data-tabs-target="').concat(e, '"]')).first();
              !n.length || !t.length || (n && n.length && t && t.length ? i.selectTab(n, !0) : i._collapse(), i.options.deepLinkSmudge && (e = i.$element.offset(), r()("html, body").animate({
                scrollTop: e.top - i.options.deepLinkSmudgeOffset
              }, i.options.deepLinkSmudgeDelay)), i.$element.trigger("deeplink.zf.tabs", [t, n]));
            }, this.options.deepLink && this._checkDeepLink(), this._events(), this._isInitializing = !1;
          }
        }, {
          key: "_events",
          value: function () {
            this._addKeyHandler(), this._addClickHandler(), this._setHeightMqHandler = null, this.options.matchHeight && (this._setHeightMqHandler = this._setHeight.bind(this), r()(window).on("changed.zf.mediaquery", this._setHeightMqHandler)), this.options.deepLink && r()(window).on("hashchange", this._checkDeepLink);
          }
        }, {
          key: "_addClickHandler",
          value: function () {
            var e = this;
            this.$element.off("click.zf.tabs").on("click.zf.tabs", ".".concat(this.options.linkClass), function (t) {
              t.preventDefault(), e._handleTabChange(r()(this));
            });
          }
        }, {
          key: "_addKeyHandler",
          value: function () {
            var a = this;
            this.$tabTitles.off("keydown.zf.tabs").on("keydown.zf.tabs", function (t) {
              var e, n, i, o;
              9 !== t.which && (e = r()(this), (n = e.parent("ul").children("li")).each(function (t) {
                r()(this).is(e) && (o = a.options.wrapOnKeys ? (i = 0 === t ? n.last() : n.eq(t - 1), t === n.length - 1 ? n.first() : n.eq(t + 1)) : (i = n.eq(Math.max(0, t - 1)), n.eq(Math.min(t + 1, n.length - 1))));
              }), s.Keyboard.handleKey(t, "Tabs", {
                open: function () {
                  e.find('[role="tab"]').focus(), a._handleTabChange(e);
                },
                previous: function () {
                  i.find('[role="tab"]').focus(), a._handleTabChange(i);
                },
                next: function () {
                  o.find('[role="tab"]').focus(), a._handleTabChange(o);
                },
                handled: function () {
                  t.preventDefault();
                }
              }));
            });
          }
        }, {
          key: "_handleTabChange",
          value: function (t, e) {
            var n, i, o;
            t.hasClass("".concat(this.options.linkActiveClass)) ? this.options.activeCollapse && this._collapse() : (n = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass)), i = (i = (o = t.find('[role="tab"]')).attr("data-tabs-target")) && i.length ? "#".concat(i) : o[0].hash, o = this.$tabContent.find(i), this._collapseTab(n), this._openTab(t), this.options.deepLink && !e && (this.options.updateHistory ? history.pushState({}, "", i) : history.replaceState({}, "", i)), this.$element.trigger("change.zf.tabs", [t, o]), o.find("[data-mutate]").trigger("mutateme.zf.trigger"));
          }
        }, {
          key: "_openTab",
          value: function (t) {
            var e = t.find('[role="tab"]'),
                n = e.attr("data-tabs-target") || e[0].hash.slice(1),
                n = this.$tabContent.find("#".concat(n));
            t.addClass("".concat(this.options.linkActiveClass)), e.attr({
              "aria-selected": "true",
              tabindex: "0"
            }), n.addClass("".concat(this.options.panelActiveClass)).removeAttr("aria-hidden");
          }
        }, {
          key: "_collapseTab",
          value: function (t) {
            t = t.removeClass("".concat(this.options.linkActiveClass)).find('[role="tab"]').attr({
              "aria-selected": "false",
              tabindex: -1
            });
            r()("#".concat(t.attr("aria-controls"))).removeClass("".concat(this.options.panelActiveClass)).attr({
              "aria-hidden": "true"
            });
          }
        }, {
          key: "_collapse",
          value: function () {
            var t = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass));
            t.length && (this._collapseTab(t), this.$element.trigger("collapse.zf.tabs", [t]));
          }
        }, {
          key: "selectTab",
          value: function (t, e) {
            var n,
                t = "object" === l(t) ? t[0].id : t;
            t.indexOf("#") < 0 ? n = "#".concat(t) : t = (n = t).slice(1);
            t = this.$tabTitles.has('[href$="'.concat(n, '"],[data-tabs-target="').concat(t, '"]')).first();

            this._handleTabChange(t, e);
          }
        }, {
          key: "_setHeight",
          value: function () {
            var i = 0,
                o = this;
            this.$tabContent && this.$tabContent.find(".".concat(this.options.panelClass)).css("height", "").each(function () {
              var t = r()(this),
                  e = t.hasClass("".concat(o.options.panelActiveClass));
              e || t.css({
                visibility: "hidden",
                display: "block"
              });
              var n = this.getBoundingClientRect().height;
              e || t.css({
                visibility: "",
                display: ""
              }), i = i < n ? n : i;
            }).css("height", "".concat(i, "px"));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.find(".".concat(this.options.linkClass)).off(".zf.tabs").hide().end().find(".".concat(this.options.panelClass)).hide(), this.options.matchHeight && null != this._setHeightMqHandler && r()(window).off("changed.zf.mediaquery", this._setHeightMqHandler), this.options.deepLink && r()(window).off("hashchange", this._checkDeepLink), this.onLoadListener && r()(window).off(this.onLoadListener);
          }
        }]) && u(t.prototype, e), n && u(t, n), o;
      }();

      i.defaults = {
        deepLink: !1,
        deepLinkSmudge: !1,
        deepLinkSmudgeDelay: 300,
        deepLinkSmudgeOffset: 0,
        updateHistory: !1,
        autoFocus: !1,
        wrapOnKeys: !0,
        matchHeight: !1,
        activeCollapse: !1,
        linkClass: "tabs-title",
        linkActiveClass: "is-active",
        panelClass: "tabs-panel",
        panelActiveClass: "is-active"
      };
    },
    18: function (t, e, n) {
      t.exports = n("./js/entries/plugins/foundation.tabs.js");
    },
    jquery: function (t, e) {
      t.exports = a;
    }
  }, c = {}, s.m = r, s.c = c, s.d = function (t, e, n) {
    s.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, s.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, s.t = function (e, t) {
    if (1 & t && (e = s(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (s.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var i in e) s.d(n, i, function (t) {
      return e[t];
    }.bind(null, i));
    return n;
  }, s.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return s.d(e, "a", e), e;
  }, s.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, s.p = "", s(s.s = 18);

  function s(t) {
    if (c[t]) return c[t].exports;
    var e = c[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return r[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports;
  }

  var r, c;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.motion", "jquery"], e) : "object" == typeof exports ? exports["foundation.toggler"] = e(require("./foundation.core"), require("./foundation.util.motion"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.toggler"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.motion"], t.jQuery));
}(window, function (n, i, r) {
  return a = {
    "./foundation.core": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.motion": function (t, e) {
      t.exports = i;
    },
    "./js/entries/plugins/foundation.toggler.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var i = n("./foundation.core");
      n.d(e, "Foundation", function () {
        return i.Foundation;
      });
      var r = n("./js/foundation.toggler.js");
      n.d(e, "Toggler", function () {
        return r.Toggler;
      }), i.Foundation.plugin(r.Toggler, "Toggler");
    },
    "./js/foundation.toggler.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Toggler", function () {
        return i;
      });
      var e = n("jquery"),
          o = n.n(e),
          a = n("./foundation.util.motion"),
          s = n("./foundation.core"),
          l = n("./js/foundation.util.triggers.js");

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function c(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function u(t, e) {
        return (u = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function f(n) {
        var i = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = g(n);
          return function (t, e) {
            {
              if (e && ("object" === r(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, i ? (t = g(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function g(t) {
        return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var i = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && u(t, e);
        }(r, s["Plugin"]);
        var t,
            e,
            n,
            i = f(r);

        function r() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, r), i.apply(this, arguments);
        }

        return t = r, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = o.a.extend({}, r.defaults, t.data(), e), this.className = "", this.className = "Toggler", l.Triggers.init(o.a), this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            var t,
                i = this.$element[0].id,
                e = o()('[data-open~="'.concat(i, '"], [data-close~="').concat(i, '"], [data-toggle~="').concat(i, '"]'));
            if (this.options.animate) t = this.options.animate.split(" "), this.animationIn = t[0], this.animationOut = t[1] || null, e.attr("aria-expanded", !this.$element.is(":hidden"));else {
              if ("string" != typeof (t = this.options.toggler) || !t.length) throw new Error("The 'toggler' option containing the target class is required, got \"".concat(t, '"'));
              this.className = "." === t[0] ? t.slice(1) : t, e.attr("aria-expanded", this.$element.hasClass(this.className));
            }
            e.each(function (t, e) {
              var n = o()(e),
                  e = n.attr("aria-controls") || "";
              new RegExp("\\b".concat(Object(s.RegExpEscape)(i), "\\b")).test(e) || n.attr("aria-controls", e ? "".concat(e, " ").concat(i) : i);
            });
          }
        }, {
          key: "_events",
          value: function () {
            this.$element.off("toggle.zf.trigger").on("toggle.zf.trigger", this.toggle.bind(this));
          }
        }, {
          key: "toggle",
          value: function () {
            this[this.options.animate ? "_toggleAnimate" : "_toggleClass"]();
          }
        }, {
          key: "_toggleClass",
          value: function () {
            this.$element.toggleClass(this.className);
            var t = this.$element.hasClass(this.className);
            t ? this.$element.trigger("on.zf.toggler") : this.$element.trigger("off.zf.toggler"), this._updateARIA(t), this.$element.find("[data-mutate]").trigger("mutateme.zf.trigger");
          }
        }, {
          key: "_toggleAnimate",
          value: function () {
            var t = this;
            this.$element.is(":hidden") ? a.Motion.animateIn(this.$element, this.animationIn, function () {
              t._updateARIA(!0), this.trigger("on.zf.toggler"), this.find("[data-mutate]").trigger("mutateme.zf.trigger");
            }) : a.Motion.animateOut(this.$element, this.animationOut, function () {
              t._updateARIA(!1), this.trigger("off.zf.toggler"), this.find("[data-mutate]").trigger("mutateme.zf.trigger");
            });
          }
        }, {
          key: "_updateARIA",
          value: function (t) {
            var e = this.$element[0].id;
            o()('[data-open="'.concat(e, '"], [data-close="').concat(e, '"], [data-toggle="').concat(e, '"]')).attr({
              "aria-expanded": !!t
            });
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.off(".zf.toggler");
          }
        }]) && c(t.prototype, e), n && c(t, n), r;
      }();

      i.defaults = {
        toggler: void 0,
        animate: !1
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "Triggers", function () {
        return c;
      });
      var e = n("jquery"),
          o = n.n(e),
          i = n("./foundation.core"),
          r = n("./foundation.util.motion");

      function a(t) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function s(e, n) {
        e.data(n).split(" ").forEach(function (t) {
          o()("#".concat(t))["close" === n ? "trigger" : "triggerHandler"]("".concat(n, ".zf.trigger"), [e]);
        });
      }

      var l = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          c = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function u(e, t, n) {
        var i,
            r = Array.prototype.slice.call(arguments, 3);
        o()(window).off(t).on(t, function (t) {
          i && clearTimeout(i), i = setTimeout(function () {
            n.apply(null, r);
          }, e || 10);
        });
      }

      c.Listeners.Basic = {
        openListener: function () {
          s(o()(this), "open");
        },
        closeListener: function () {
          o()(this).data("close") ? s(o()(this), "close") : o()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          o()(this).data("toggle") ? s(o()(this), "toggle") : o()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = o()(this).data("closable");
          t.stopPropagation(), "" !== e ? r.Motion.animateOut(o()(this), e, function () {
            o()(this).trigger("closed.zf");
          }) : o()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = o()(this).data("toggle-focus");
          o()("#".concat(t)).triggerHandler("toggle.zf.trigger", [o()(this)]);
        }
      }, c.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", c.Listeners.Basic.openListener);
      }, c.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", c.Listeners.Basic.closeListener);
      }, c.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", c.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", c.Listeners.Basic.toggleListener);
      }, c.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", c.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", c.Listeners.Basic.closeableListener);
      }, c.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", c.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", c.Listeners.Basic.toggleFocusListener);
      }, c.Listeners.Global = {
        resizeListener: function (t) {
          l || t.each(function () {
            o()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          l || t.each(function () {
            o()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          o()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = o()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, c.Initializers.addClosemeListener = function (t) {
        var e = o()("[data-yeti-box]"),
            n = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? n.push(t) : "object" === a(t) && "string" == typeof t[0] ? n = n.concat(t) : console.error("Plugin names must be strings")), e.length && (n = n.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), o()(window).off(n).on(n, c.Listeners.Global.closeMeListener));
      }, c.Initializers.addResizeListener = function (t) {
        var e = o()("[data-resize]");
        e.length && u(t, "resize.zf.trigger", c.Listeners.Global.resizeListener, e);
      }, c.Initializers.addScrollListener = function (t) {
        var e = o()("[data-scroll]");
        e.length && u(t, "scroll.zf.trigger", c.Listeners.Global.scrollListener, e);
      }, c.Initializers.addMutationEventsListener = function (t) {
        if (!l) return !1;

        function e(t) {
          var e = o()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var n = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (n.length) for (var i = 0; i <= n.length - 1; i++) new l(e).observe(n[i], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, c.Initializers.addSimpleListeners = function () {
        var t = o()(document);
        c.Initializers.addOpenListener(t), c.Initializers.addCloseListener(t), c.Initializers.addToggleListener(t), c.Initializers.addCloseableListener(t), c.Initializers.addToggleFocusListener(t);
      }, c.Initializers.addGlobalListeners = function () {
        var t = o()(document);
        c.Initializers.addMutationEventsListener(t), c.Initializers.addResizeListener(), c.Initializers.addScrollListener(), c.Initializers.addClosemeListener();
      }, c.init = function (t, e) {
        Object(i.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (c.Initializers.addSimpleListeners(), c.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = c, e.IHearYou = c.Initializers.addGlobalListeners);
      };
    },
    19: function (t, e, n) {
      t.exports = n("./js/entries/plugins/foundation.toggler.js");
    },
    jquery: function (t, e) {
      t.exports = r;
    }
  }, s = {}, o.m = a, o.c = s, o.d = function (t, e, n) {
    o.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, o.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, o.t = function (e, t) {
    if (1 & t && (e = o(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (o.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var i in e) o.d(n, i, function (t) {
      return e[t];
    }.bind(null, i));
    return n;
  }, o.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return o.d(e, "a", e), e;
  }, o.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, o.p = "", o(o.s = 19);

  function o(t) {
    if (s[t]) return s[t].exports;
    var e = s[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return a[t].call(e.exports, e, e.exports, o), e.l = !0, e.exports;
  }

  var a, s;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.core", "./foundation.util.box", "./foundation.util.mediaQuery", "./foundation.util.motion", "jquery"], e) : "object" == typeof exports ? exports["foundation.tooltip"] = e(require("./foundation.core"), require("./foundation.util.box"), require("./foundation.util.mediaQuery"), require("./foundation.util.motion"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.tooltip"] = e(t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.util.box"], t.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], t.__FOUNDATION_EXTERNAL__["foundation.util.motion"], t.jQuery));
}(window, function (i, o, n, r, s) {
  return l = {
    "./foundation.core": function (t, e) {
      t.exports = i;
    },
    "./foundation.util.box": function (t, e) {
      t.exports = o;
    },
    "./foundation.util.mediaQuery": function (t, e) {
      t.exports = n;
    },
    "./foundation.util.motion": function (t, e) {
      t.exports = r;
    },
    "./js/entries/plugins/foundation.tooltip.js": function (t, e, i) {
      "use strict";

      i.r(e);
      var o = i("./foundation.core");
      i.d(e, "Foundation", function () {
        return o.Foundation;
      });
      var n = i("./js/foundation.tooltip.js");
      i.d(e, "Tooltip", function () {
        return n.Tooltip;
      }), o.Foundation.plugin(n.Tooltip, "Tooltip");
    },
    "./js/foundation.positionable.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Positionable", function () {
        return o;
      });
      var s = i("./foundation.util.box"),
          r = i("./foundation.core");

      function n(t) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(t, e) {
        for (var i = 0; i < e.length; i++) {
          var o = e[i];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      function l(t, e) {
        return (l = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function u(i) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = f(i);
          return function (t, e) {
            {
              if (e && ("object" === n(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, o ? (t = f(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function f(t) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var c = ["left", "right", "top", "bottom"],
          e = ["top", "bottom", "center"],
          i = ["left", "right", "center"],
          p = {
        left: e,
        right: e,
        top: i,
        bottom: i
      };

      function d(t, e) {
        t = e.indexOf(t);
        return t === e.length - 1 ? e[0] : e[t + 1];
      }

      var o = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && l(t, e);
        }(n, r["Plugin"]);
        var t,
            e,
            i,
            o = u(n);

        function n() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, n), o.apply(this, arguments);
        }

        return t = n, (e = [{
          key: "_init",
          value: function () {
            this.triedPositions = {}, this.position = "auto" === this.options.position ? this._getDefaultPosition() : this.options.position, this.alignment = "auto" === this.options.alignment ? this._getDefaultAlignment() : this.options.alignment, this.originalPosition = this.position, this.originalAlignment = this.alignment;
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            return "bottom";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            switch (this.position) {
              case "bottom":
              case "top":
                return Object(r.rtl)() ? "right" : "left";

              case "left":
              case "right":
                return "bottom";
            }
          }
        }, {
          key: "_reposition",
          value: function () {
            this._alignmentsExhausted(this.position) ? (this.position = d(this.position, c), this.alignment = p[this.position][0]) : this._realign();
          }
        }, {
          key: "_realign",
          value: function () {
            this._addTriedPosition(this.position, this.alignment), this.alignment = d(this.alignment, p[this.position]);
          }
        }, {
          key: "_addTriedPosition",
          value: function (t, e) {
            this.triedPositions[t] = this.triedPositions[t] || [], this.triedPositions[t].push(e);
          }
        }, {
          key: "_positionsExhausted",
          value: function () {
            for (var t = !0, e = 0; e < c.length; e++) t = t && this._alignmentsExhausted(c[e]);

            return t;
          }
        }, {
          key: "_alignmentsExhausted",
          value: function (t) {
            return this.triedPositions[t] && this.triedPositions[t].length == p[t].length;
          }
        }, {
          key: "_getVOffset",
          value: function () {
            return this.options.vOffset;
          }
        }, {
          key: "_getHOffset",
          value: function () {
            return this.options.hOffset;
          }
        }, {
          key: "_setPosition",
          value: function (t, e, i) {
            if ("false" === t.attr("aria-expanded")) return !1;

            if (this.options.allowOverlap || (this.position = this.originalPosition, this.alignment = this.originalAlignment), e.offset(s.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset())), !this.options.allowOverlap) {
              for (var o = 1e8, n = {
                position: this.position,
                alignment: this.alignment
              }; !this._positionsExhausted();) {
                var r = s.Box.OverlapArea(e, i, !1, !1, this.options.allowBottomOverlap);
                if (0 === r) return;
                r < o && (o = r, n = {
                  position: this.position,
                  alignment: this.alignment
                }), this._reposition(), e.offset(s.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
              }

              this.position = n.position, this.alignment = n.alignment, e.offset(s.Box.GetExplicitOffsets(e, t, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
            }
          }
        }]) && a(t.prototype, e), i && a(t, i), n;
      }();

      o.defaults = {
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !0,
        vOffset: 0,
        hOffset: 0
      };
    },
    "./js/foundation.tooltip.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Tooltip", function () {
        return o;
      });
      var e = i("jquery"),
          r = i.n(e),
          s = i("./foundation.core"),
          a = i("./foundation.util.mediaQuery"),
          l = i("./js/foundation.util.triggers.js"),
          u = i("./js/foundation.positionable.js");

      function n(t) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function f(t, e) {
        for (var i = 0; i < e.length; i++) {
          var o = e[i];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      function c(t, e, i) {
        return (c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, i) {
          t = function (t, e) {
            for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = h(t)););

            return t;
          }(t, e);

          if (t) {
            e = Object.getOwnPropertyDescriptor(t, e);
            return e.get ? e.get.call(i) : e.value;
          }
        })(t, e, i || t);
      }

      function p(t, e) {
        return (p = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function d(i) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = h(i);
          return function (t, e) {
            {
              if (e && ("object" === n(e) || "function" == typeof e)) return e;
              if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            }
            return function (t) {
              if (void 0 !== t) return t;
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }(t);
          }(this, o ? (t = h(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var o = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && p(t, e);
        }(n, u["Positionable"]);
        var t,
            e,
            i,
            o = d(n);

        function n() {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, n), o.apply(this, arguments);
        }

        return t = n, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = t, this.options = r.a.extend({}, n.defaults, this.$element.data(), e), this.className = "Tooltip", this.isActive = !1, this.isClick = !1, l.Triggers.init(r.a), this._init();
          }
        }, {
          key: "_init",
          value: function () {
            a.MediaQuery._init();

            var t = this.$element.attr("aria-describedby") || Object(s.GetYoDigits)(6, "tooltip");
            this.options.tipText = this.options.tipText || this.$element.attr("title"), this.template = this.options.template ? r()(this.options.template) : this._buildTemplate(t), (this.options.allowHtml ? this.template.appendTo(document.body).html(this.options.tipText) : this.template.appendTo(document.body).text(this.options.tipText)).hide(), this.$element.attr({
              title: "",
              "aria-describedby": t,
              "data-yeti-box": t,
              "data-toggle": t,
              "data-resize": t
            }).addClass(this.options.triggerClass), c(h(n.prototype), "_init", this).call(this), this._events();
          }
        }, {
          key: "_getDefaultPosition",
          value: function () {
            var t = this.$element[0].className,
                t = (t = this.$element[0] instanceof SVGElement ? t.baseVal : t).match(/\b(top|left|right|bottom)\b/g);
            return t ? t[0] : "top";
          }
        }, {
          key: "_getDefaultAlignment",
          value: function () {
            return "center";
          }
        }, {
          key: "_getHOffset",
          value: function () {
            return "left" === this.position || "right" === this.position ? this.options.hOffset + this.options.tooltipWidth : this.options.hOffset;
          }
        }, {
          key: "_getVOffset",
          value: function () {
            return "top" === this.position || "bottom" === this.position ? this.options.vOffset + this.options.tooltipHeight : this.options.vOffset;
          }
        }, {
          key: "_buildTemplate",
          value: function (t) {
            var e = "".concat(this.options.tooltipClass, " ").concat(this.options.templateClasses).trim();
            return r()("<div></div>").addClass(e).attr({
              role: "tooltip",
              "aria-hidden": !0,
              "data-is-active": !1,
              "data-is-focus": !1,
              id: t
            });
          }
        }, {
          key: "_setPosition",
          value: function () {
            c(h(n.prototype), "_setPosition", this).call(this, this.$element, this.template);
          }
        }, {
          key: "show",
          value: function () {
            if ("all" !== this.options.showOn && !a.MediaQuery.is(this.options.showOn)) return !1;
            this.template.css("visibility", "hidden").show(), this._setPosition(), this.template.removeClass("top bottom left right").addClass(this.position), this.template.removeClass("align-top align-bottom align-left align-right align-center").addClass("align-" + this.alignment), this.$element.trigger("closeme.zf.tooltip", this.template.attr("id")), this.template.attr({
              "data-is-active": !0,
              "aria-hidden": !1
            }), this.isActive = !0, this.template.stop().hide().css("visibility", "").fadeIn(this.options.fadeInDuration, function () {}), this.$element.trigger("show.zf.tooltip");
          }
        }, {
          key: "hide",
          value: function () {
            var t = this;
            this.template.stop().attr({
              "aria-hidden": !0,
              "data-is-active": !1
            }).fadeOut(this.options.fadeOutDuration, function () {
              t.isActive = !1, t.isClick = !1;
            }), this.$element.trigger("hide.zf.tooltip");
          }
        }, {
          key: "_events",
          value: function () {
            var e = this,
                t = "ontouchstart" in window || void 0 !== window.ontouchstart,
                i = (this.template, !1);
            t && this.options.disableForTouch || (this.options.disableHover || this.$element.on("mouseenter.zf.tooltip", function (t) {
              e.isActive || (e.timeout = setTimeout(function () {
                e.show();
              }, e.options.hoverDelay));
            }).on("mouseleave.zf.tooltip", Object(s.ignoreMousedisappear)(function (t) {
              clearTimeout(e.timeout), i && (!e.isClick || e.options.clickOpen) || e.hide();
            })), t && this.$element.on("tap.zf.tooltip touchend.zf.tooltip", function (t) {
              e.isActive ? e.hide() : e.show();
            }), this.options.clickOpen ? this.$element.on("mousedown.zf.tooltip", function (t) {
              e.isClick || (e.isClick = !0, !e.options.disableHover && e.$element.attr("tabindex") || e.isActive || e.show());
            }) : this.$element.on("mousedown.zf.tooltip", function (t) {
              e.isClick = !0;
            }), this.$element.on({
              "close.zf.trigger": this.hide.bind(this)
            }), this.$element.on("focus.zf.tooltip", function (t) {
              return i = !0, e.isClick ? (e.options.clickOpen || (i = !1), !1) : void e.show();
            }).on("focusout.zf.tooltip", function (t) {
              i = !1, e.isClick = !1, e.hide();
            }).on("resizeme.zf.trigger", function () {
              e.isActive && e._setPosition();
            }));
          }
        }, {
          key: "toggle",
          value: function () {
            this.isActive ? this.hide() : this.show();
          }
        }, {
          key: "_destroy",
          value: function () {
            this.$element.attr("title", this.template.text()).off(".zf.trigger .zf.tooltip").removeClass(this.options.triggerClass).removeClass("top right left bottom").removeAttr("aria-describedby data-disable-hover data-resize data-toggle data-tooltip data-yeti-box"), this.template.remove();
          }
        }]) && f(t.prototype, e), i && f(t, i), n;
      }();

      o.defaults = {
        hoverDelay: 200,
        fadeInDuration: 150,
        fadeOutDuration: 150,
        disableHover: !1,
        disableForTouch: !1,
        templateClasses: "",
        tooltipClass: "tooltip",
        triggerClass: "has-tip",
        showOn: "small",
        template: "",
        tipText: "",
        touchCloseText: "Tap to close.",
        clickOpen: !0,
        position: "auto",
        alignment: "auto",
        allowOverlap: !1,
        allowBottomOverlap: !1,
        vOffset: 0,
        hOffset: 0,
        tooltipHeight: 14,
        tooltipWidth: 12,
        allowHtml: !1
      };
    },
    "./js/foundation.util.triggers.js": function (t, e, i) {
      "use strict";

      i.r(e), i.d(e, "Triggers", function () {
        return u;
      });
      var e = i("jquery"),
          r = i.n(e),
          o = i("./foundation.core"),
          n = i("./foundation.util.motion");

      function s(t) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(e, i) {
        e.data(i).split(" ").forEach(function (t) {
          r()("#".concat(t))["close" === i ? "trigger" : "triggerHandler"]("".concat(i, ".zf.trigger"), [e]);
        });
      }

      var l = function () {
        for (var t = ["WebKit", "Moz", "O", "Ms", ""], e = 0; e < t.length; e++) if ("".concat(t[e], "MutationObserver") in window) return window["".concat(t[e], "MutationObserver")];

        return !1;
      }(),
          u = {
        Listeners: {
          Basic: {},
          Global: {}
        },
        Initializers: {}
      };

      function f(e, t, i) {
        var o,
            n = Array.prototype.slice.call(arguments, 3);
        r()(window).off(t).on(t, function (t) {
          o && clearTimeout(o), o = setTimeout(function () {
            i.apply(null, n);
          }, e || 10);
        });
      }

      u.Listeners.Basic = {
        openListener: function () {
          a(r()(this), "open");
        },
        closeListener: function () {
          r()(this).data("close") ? a(r()(this), "close") : r()(this).trigger("close.zf.trigger");
        },
        toggleListener: function () {
          r()(this).data("toggle") ? a(r()(this), "toggle") : r()(this).trigger("toggle.zf.trigger");
        },
        closeableListener: function (t) {
          var e = r()(this).data("closable");
          t.stopPropagation(), "" !== e ? n.Motion.animateOut(r()(this), e, function () {
            r()(this).trigger("closed.zf");
          }) : r()(this).fadeOut().trigger("closed.zf");
        },
        toggleFocusListener: function () {
          var t = r()(this).data("toggle-focus");
          r()("#".concat(t)).triggerHandler("toggle.zf.trigger", [r()(this)]);
        }
      }, u.Initializers.addOpenListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.openListener), t.on("click.zf.trigger", "[data-open]", u.Listeners.Basic.openListener);
      }, u.Initializers.addCloseListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.closeListener), t.on("click.zf.trigger", "[data-close]", u.Listeners.Basic.closeListener);
      }, u.Initializers.addToggleListener = function (t) {
        t.off("click.zf.trigger", u.Listeners.Basic.toggleListener), t.on("click.zf.trigger", "[data-toggle]", u.Listeners.Basic.toggleListener);
      }, u.Initializers.addCloseableListener = function (t) {
        t.off("close.zf.trigger", u.Listeners.Basic.closeableListener), t.on("close.zf.trigger", "[data-closeable], [data-closable]", u.Listeners.Basic.closeableListener);
      }, u.Initializers.addToggleFocusListener = function (t) {
        t.off("focus.zf.trigger blur.zf.trigger", u.Listeners.Basic.toggleFocusListener), t.on("focus.zf.trigger blur.zf.trigger", "[data-toggle-focus]", u.Listeners.Basic.toggleFocusListener);
      }, u.Listeners.Global = {
        resizeListener: function (t) {
          l || t.each(function () {
            r()(this).triggerHandler("resizeme.zf.trigger");
          }), t.attr("data-events", "resize");
        },
        scrollListener: function (t) {
          l || t.each(function () {
            r()(this).triggerHandler("scrollme.zf.trigger");
          }), t.attr("data-events", "scroll");
        },
        closeMeListener: function (t, e) {
          t = t.namespace.split(".")[0];
          r()("[data-".concat(t, "]")).not('[data-yeti-box="'.concat(e, '"]')).each(function () {
            var t = r()(this);
            t.triggerHandler("close.zf.trigger", [t]);
          });
        }
      }, u.Initializers.addClosemeListener = function (t) {
        var e = r()("[data-yeti-box]"),
            i = ["dropdown", "tooltip", "reveal"];
        t && ("string" == typeof t ? i.push(t) : "object" === s(t) && "string" == typeof t[0] ? i = i.concat(t) : console.error("Plugin names must be strings")), e.length && (i = i.map(function (t) {
          return "closeme.zf.".concat(t);
        }).join(" "), r()(window).off(i).on(i, u.Listeners.Global.closeMeListener));
      }, u.Initializers.addResizeListener = function (t) {
        var e = r()("[data-resize]");
        e.length && f(t, "resize.zf.trigger", u.Listeners.Global.resizeListener, e);
      }, u.Initializers.addScrollListener = function (t) {
        var e = r()("[data-scroll]");
        e.length && f(t, "scroll.zf.trigger", u.Listeners.Global.scrollListener, e);
      }, u.Initializers.addMutationEventsListener = function (t) {
        if (!l) return !1;

        function e(t) {
          var e = r()(t[0].target);

          switch (t[0].type) {
            case "attributes":
              "scroll" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("scrollme.zf.trigger", [e, window.pageYOffset]), "resize" === e.attr("data-events") && "data-events" === t[0].attributeName && e.triggerHandler("resizeme.zf.trigger", [e]), "style" === t[0].attributeName && (e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]));
              break;

            case "childList":
              e.closest("[data-mutate]").attr("data-events", "mutate"), e.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger", [e.closest("[data-mutate]")]);
              break;

            default:
              return !1;
          }
        }

        var i = t.find("[data-resize], [data-scroll], [data-mutate]");
        if (i.length) for (var o = 0; o <= i.length - 1; o++) new l(e).observe(i[o], {
          attributes: !0,
          childList: !0,
          characterData: !1,
          subtree: !0,
          attributeFilter: ["data-events", "style"]
        });
      }, u.Initializers.addSimpleListeners = function () {
        var t = r()(document);
        u.Initializers.addOpenListener(t), u.Initializers.addCloseListener(t), u.Initializers.addToggleListener(t), u.Initializers.addCloseableListener(t), u.Initializers.addToggleFocusListener(t);
      }, u.Initializers.addGlobalListeners = function () {
        var t = r()(document);
        u.Initializers.addMutationEventsListener(t), u.Initializers.addResizeListener(), u.Initializers.addScrollListener(), u.Initializers.addClosemeListener();
      }, u.init = function (t, e) {
        Object(o.onLoad)(t(window), function () {
          !0 !== t.triggersInitialized && (u.Initializers.addSimpleListeners(), u.Initializers.addGlobalListeners(), t.triggersInitialized = !0);
        }), e && (e.Triggers = u, e.IHearYou = u.Initializers.addGlobalListeners);
      };
    },
    20: function (t, e, i) {
      t.exports = i("./js/entries/plugins/foundation.tooltip.js");
    },
    jquery: function (t, e) {
      t.exports = s;
    }
  }, u = {}, a.m = l, a.c = u, a.d = function (t, e, i) {
    a.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: i
    });
  }, a.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, a.t = function (e, t) {
    if (1 & t && (e = a(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var i = Object.create(null);
    if (a.r(i), Object.defineProperty(i, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var o in e) a.d(i, o, function (t) {
      return e[t];
    }.bind(null, o));
    return i;
  }, a.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return a.d(e, "a", e), e;
  }, a.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, a.p = "", a(a.s = 20);

  function a(t) {
    if (u[t]) return u[t].exports;
    var e = u[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return l[t].call(e.exports, e, e.exports, a), e.l = !0, e.exports;
  }

  var l, u;
});
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e(require("./foundation.accordion"), require("./foundation.core"), require("./foundation.tabs"), require("./foundation.util.mediaQuery"), require("jquery")) : "function" == typeof define && define.amd ? define(["./foundation.accordion", "./foundation.core", "./foundation.tabs", "./foundation.util.mediaQuery", "jquery"], e) : "object" == typeof exports ? exports["foundation.responsiveAccordionTabs"] = e(require("./foundation.accordion"), require("./foundation.core"), require("./foundation.tabs"), require("./foundation.util.mediaQuery"), require("jquery")) : (t.__FOUNDATION_EXTERNAL__ = t.__FOUNDATION_EXTERNAL__ || {}, t.__FOUNDATION_EXTERNAL__["foundation.responsiveAccordionTabs"] = e(t.__FOUNDATION_EXTERNAL__["foundation.accordion"], t.__FOUNDATION_EXTERNAL__["foundation.core"], t.__FOUNDATION_EXTERNAL__["foundation.tabs"], t.__FOUNDATION_EXTERNAL__["foundation.util.mediaQuery"], t.jQuery));
}(window, function (n, o, r, i, a) {
  return u = {
    "./foundation.accordion": function (t, e) {
      t.exports = n;
    },
    "./foundation.core": function (t, e) {
      t.exports = o;
    },
    "./foundation.tabs": function (t, e) {
      t.exports = r;
    },
    "./foundation.util.mediaQuery": function (t, e) {
      t.exports = i;
    },
    "./js/entries/plugins/foundation.responsiveAccordionTabs.js": function (t, e, n) {
      "use strict";

      n.r(e);
      var o = n("./foundation.core");
      n.d(e, "Foundation", function () {
        return o.Foundation;
      });
      var r = n("./js/foundation.responsiveAccordionTabs.js");
      n.d(e, "ResponsiveAccordionTabs", function () {
        return r.ResponsiveAccordionTabs;
      }), o.Foundation.plugin(r.ResponsiveAccordionTabs, "ResponsiveAccordionTabs");
    },
    "./js/foundation.responsiveAccordionTabs.js": function (t, e, n) {
      "use strict";

      n.r(e), n.d(e, "ResponsiveAccordionTabs", function () {
        return y;
      });
      var o = n("jquery"),
          c = n.n(o),
          i = n("./foundation.util.mediaQuery"),
          l = n("./foundation.core"),
          e = n("./foundation.accordion"),
          o = n("./foundation.tabs");

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t;
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        })(t);
      }

      function a(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      function s(t, e) {
        return (s = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function u(n) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        }();

        return function () {
          var t,
              e = p(n);
          return d(this, o ? (t = p(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments));
        };
      }

      function d(t, e) {
        if (e && ("object" === r(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return f(t);
      }

      function f(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t;
      }

      function p(t) {
        return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      var h = {
        tabs: {
          cssClass: "tabs",
          plugin: o.Tabs,
          open: function (t, e) {
            return t.selectTab(e);
          },
          close: null,
          toggle: null
        },
        accordion: {
          cssClass: "accordion",
          plugin: e.Accordion,
          open: function (t, e) {
            return t.down(c()(e));
          },
          close: function (t, e) {
            return t.up(c()(e));
          },
          toggle: function (t, e) {
            return t.toggle(c()(e));
          }
        }
      },
          y = function () {
        !function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && s(t, e);
        }(r, l["Plugin"]);
        var t,
            e,
            n,
            o = u(r);

        function r(t, e) {
          return function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, r), d(e = o.call(this, t, e), e.options.reflow && e.storezfData || f(e));
        }

        return t = r, (e = [{
          key: "_setup",
          value: function (t, e) {
            this.$element = c()(t), this.$element.data("zfPluginBase", this), this.options = c.a.extend({}, r.defaults, this.$element.data(), e), this.rules = this.$element.data("responsive-accordion-tabs"), this.currentMq = null, this.currentRule = null, this.currentPlugin = null, this.className = "ResponsiveAccordionTabs", this.$element.attr("id") || this.$element.attr("id", Object(l.GetYoDigits)(6, "responsiveaccordiontabs")), this._init(), this._events();
          }
        }, {
          key: "_init",
          value: function () {
            if (i.MediaQuery._init(), "string" == typeof this.rules) {
              for (var t = {}, e = this.rules.split(" "), n = 0; n < e.length; n++) {
                var o = e[n].split("-"),
                    r = 1 < o.length ? o[0] : "small",
                    o = 1 < o.length ? o[1] : o[0];
                null !== h[o] && (t[r] = h[o]);
              }

              this.rules = t;
            }

            this._getAllOptions(), c.a.isEmptyObject(this.rules) || this._checkMediaQueries();
          }
        }, {
          key: "_getAllOptions",
          value: function () {
            for (var t in this.allOptions = {}, h) if (h.hasOwnProperty(t)) {
              var e = h[t];

              try {
                var n,
                    o,
                    r = c()("<ul></ul>"),
                    i = new e.plugin(r, this.options);

                for (n in i.options) i.options.hasOwnProperty(n) && "zfPlugin" !== n && (o = i.options[n], this.allOptions[n] = o);

                i.destroy();
              } catch (t) {}
            }
          }
        }, {
          key: "_events",
          value: function () {
            this._changedZfMediaQueryHandler = this._checkMediaQueries.bind(this), c()(window).on("changed.zf.mediaquery", this._changedZfMediaQueryHandler);
          }
        }, {
          key: "_checkMediaQueries",
          value: function () {
            var e,
                n = this;
            c.a.each(this.rules, function (t) {
              i.MediaQuery.atLeast(t) && (e = t);
            }), e && (this.currentPlugin instanceof this.rules[e].plugin || (c.a.each(h, function (t, e) {
              n.$element.removeClass(e.cssClass);
            }), this.$element.addClass(this.rules[e].cssClass), this.currentPlugin && (!this.currentPlugin.$element.data("zfPlugin") && this.storezfData && this.currentPlugin.$element.data("zfPlugin", this.storezfData), this.currentPlugin.destroy()), this._handleMarkup(this.rules[e].cssClass), this.currentRule = this.rules[e], this.currentPlugin = new this.currentRule.plugin(this.$element, this.options), this.storezfData = this.currentPlugin.$element.data("zfPlugin")));
          }
        }, {
          key: "_handleMarkup",
          value: function (t) {
            var e,
                i,
                a,
                s,
                u,
                n = this,
                o = "accordion",
                r = c()("[data-tabs-content=" + this.$element.attr("id") + "]");
            (o = r.length ? "tabs" : o) !== t && (e = n.allOptions.linkClass || "tabs-title", i = n.allOptions.panelClass || "tabs-panel", this.$element.removeAttr("role"), a = this.$element.children("." + e + ",[data-accordion-item]").removeClass(e).removeClass("accordion-item").removeAttr("data-accordion-item"), s = a.children("a").removeClass("accordion-title"), "tabs" === o ? (r = r.children("." + i).removeClass(i).removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby")).children("a").removeAttr("role").removeAttr("aria-controls").removeAttr("aria-selected") : r = a.children("[data-tab-content]").removeClass("accordion-content"), r.css({
              display: "",
              visibility: ""
            }), a.css({
              display: "",
              visibility: ""
            }), "accordion" === t ? r.each(function (t, e) {
              c()(e).appendTo(a.get(t)).addClass("accordion-content").attr("data-tab-content", "").removeClass("is-active").css({
                height: ""
              }), c()("[data-tabs-content=" + n.$element.attr("id") + "]").after('<div id="tabs-placeholder-' + n.$element.attr("id") + '"></div>').detach(), a.addClass("accordion-item").attr("data-accordion-item", ""), s.addClass("accordion-title");
            }) : "tabs" === t && (u = c()("[data-tabs-content=" + n.$element.attr("id") + "]"), (t = c()("#tabs-placeholder-" + n.$element.attr("id"))).length ? (u = c()('<div class="tabs-content"></div>').insertAfter(t).attr("data-tabs-content", n.$element.attr("id")), t.remove()) : u = c()('<div class="tabs-content"></div>').insertAfter(n.$element).attr("data-tabs-content", n.$element.attr("id")), r.each(function (t, e) {
              var n = c()(e).appendTo(u).addClass(i),
                  o = s.get(t).hash.slice(1),
                  r = c()(e).attr("id") || Object(l.GetYoDigits)(6, "accordion");
              o !== r && ("" !== o ? c()(e).attr("id", o) : (o = r, c()(e).attr("id", o), c()(s.get(t)).attr("href", c()(s.get(t)).attr("href").replace("#", "") + "#" + o))), c()(a.get(t)).hasClass("is-active") && n.addClass("is-active");
            }), a.addClass(e)));
          }
        }, {
          key: "open",
          value: function (t) {
            var e;
            if (this.currentRule && "function" == typeof this.currentRule.open) return (e = this.currentRule).open.apply(e, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
          }
        }, {
          key: "close",
          value: function (t) {
            var e;
            if (this.currentRule && "function" == typeof this.currentRule.close) return (e = this.currentRule).close.apply(e, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
          }
        }, {
          key: "toggle",
          value: function (t) {
            var e;
            if (this.currentRule && "function" == typeof this.currentRule.toggle) return (e = this.currentRule).toggle.apply(e, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
          }
        }, {
          key: "_destroy",
          value: function () {
            this.currentPlugin && this.currentPlugin.destroy(), c()(window).off("changed.zf.mediaquery", this._changedZfMediaQueryHandler);
          }
        }]) && a(t.prototype, e), n && a(t, n), r;
      }();

      y.defaults = {};
    },
    11: function (t, e, n) {
      t.exports = n("./js/entries/plugins/foundation.responsiveAccordionTabs.js");
    },
    jquery: function (t, e) {
      t.exports = a;
    }
  }, c = {}, s.m = u, s.c = c, s.d = function (t, e, n) {
    s.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: n
    });
  }, s.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, s.t = function (e, t) {
    if (1 & t && (e = s(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (s.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var o in e) s.d(n, o, function (t) {
      return e[t];
    }.bind(null, o));
    return n;
  }, s.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return s.d(e, "a", e), e;
  }, s.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, s.p = "", s(s.s = 11);

  function s(t) {
    if (c[t]) return c[t].exports;
    var e = c[t] = {
      i: t,
      l: !1,
      exports: {}
    };
    return u[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports;
  }

  var u, c;
});
;

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('jquery'));
  } else {
    root.MotionUI = factory(root.jQuery);
  }
})(this, function ($) {
  'use strict'; // Polyfill for requestAnimationFrame

  (function () {
    if (!Date.now) Date.now = function () {
      return new Date().getTime();
    };
    var vendors = ['webkit', 'moz'];

    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
    }

    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
      var lastTime = 0;

      window.requestAnimationFrame = function (callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function () {
          callback(lastTime = nextTime);
        }, nextTime - now);
      };

      window.cancelAnimationFrame = clearTimeout;
    }
  })();

  var initClasses = ['mui-enter', 'mui-leave'];
  var activeClasses = ['mui-enter-active', 'mui-leave-active']; // Find the right "transitionend" event for this browser

  var endEvent = function () {
    var transitions = {
      'transition': 'transitionend',
      'WebkitTransition': 'webkitTransitionEnd',
      'MozTransition': 'transitionend',
      'OTransition': 'otransitionend'
    };
    var elem = window.document.createElement('div');

    for (var t in transitions) {
      if (typeof elem.style[t] !== 'undefined') {
        return transitions[t];
      }
    }

    return null;
  }();

  function animate(isIn, element, animation, cb) {
    element = $(element).eq(0);
    if (!element.length) return;

    if (endEvent === null) {
      isIn ? element.show() : element.hide();
      cb();
      return;
    }

    var initClass = isIn ? initClasses[0] : initClasses[1];
    var activeClass = isIn ? activeClasses[0] : activeClasses[1]; // Set up the animation

    reset();
    element.addClass(animation);
    element.css('transition', 'none');
    requestAnimationFrame(function () {
      element.addClass(initClass);
      if (isIn) element.show();
    }); // Start the animation

    requestAnimationFrame(function () {
      element[0].offsetWidth;
      element.css('transition', '');
      element.addClass(activeClass);
    }); // Clean up the animation when it finishes

    element.one('transitionend', finish); // Hides the element (for out animations), resets the element, and runs a callback

    function finish() {
      if (!isIn) element.hide();
      reset();
      if (cb) cb.apply(element);
    } // Resets transitions and removes motion-specific classes


    function reset() {
      element[0].style.transitionDuration = 0;
      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
    }
  }

  var MotionUI = {
    animateIn: function (element, animation, cb) {
      animate(true, element, animation, cb);
    },
    animateOut: function (element, animation, cb) {
      animate(false, element, animation, cb);
    }
  };
  return MotionUI;
});
(function (window, factory) {
  var lazySizes = factory(window, window.document, Date);
  window.lazySizes = lazySizes;

  if (typeof module == 'object' && module.exports) {
    module.exports = lazySizes;
  }
})(typeof window != 'undefined' ? window : {},
/**
 * import("./types/global")
 * @typedef { import("./types/lazysizes-config").LazySizesConfigPartial } LazySizesConfigPartial
 */
function l(window, document, Date) {
  // Pass in the window Date function also for SSR because the Date class can be lost
  'use strict';
  /*jshint eqnull:true */

  var lazysizes,
  /**
   * @type { LazySizesConfigPartial }
   */
  lazySizesCfg;

  (function () {
    var prop;
    var lazySizesDefaults = {
      lazyClass: 'lazyload',
      loadedClass: 'lazyloaded',
      loadingClass: 'lazyloading',
      preloadClass: 'lazypreload',
      errorClass: 'lazyerror',
      //strictClass: 'lazystrict',
      autosizesClass: 'lazyautosizes',
      fastLoadedClass: 'ls-is-cached',
      iframeLoadMode: 0,
      srcAttr: 'data-src',
      srcsetAttr: 'data-srcset',
      sizesAttr: 'data-sizes',
      //preloadAfterLoad: false,
      minSize: 40,
      customMedia: {},
      init: true,
      expFactor: 1.5,
      hFac: 0.8,
      loadMode: 2,
      loadHidden: true,
      ricTimeout: 0,
      throttleDelay: 125
    };
    lazySizesCfg = window.lazySizesConfig || window.lazysizesConfig || {};

    for (prop in lazySizesDefaults) {
      if (!(prop in lazySizesCfg)) {
        lazySizesCfg[prop] = lazySizesDefaults[prop];
      }
    }
  })();

  if (!document || !document.getElementsByClassName) {
    return {
      init: function () {},

      /**
       * @type { LazySizesConfigPartial }
       */
      cfg: lazySizesCfg,

      /**
       * @type { true }
       */
      noSupport: true
    };
  }

  var docElem = document.documentElement;
  var supportPicture = window.HTMLPictureElement;
  var _addEventListener = 'addEventListener';
  var _getAttribute = 'getAttribute';
  /**
   * Update to bind to window because 'this' becomes null during SSR
   * builds.
   */

  var addEventListener = window[_addEventListener].bind(window);

  var setTimeout = window.setTimeout;
  var requestAnimationFrame = window.requestAnimationFrame || setTimeout;
  var requestIdleCallback = window.requestIdleCallback;
  var regPicture = /^picture$/i;
  var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];
  var regClassCache = {};
  var forEach = Array.prototype.forEach;
  /**
   * @param ele {Element}
   * @param cls {string}
   */

  var hasClass = function (ele, cls) {
    if (!regClassCache[cls]) {
      regClassCache[cls] = new RegExp('(\\s|^)' + cls + '(\\s|$)');
    }

    return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
  };
  /**
   * @param ele {Element}
   * @param cls {string}
   */


  var addClass = function (ele, cls) {
    if (!hasClass(ele, cls)) {
      ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
    }
  };
  /**
   * @param ele {Element}
   * @param cls {string}
   */


  var removeClass = function (ele, cls) {
    var reg;

    if (reg = hasClass(ele, cls)) {
      ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
    }
  };

  var addRemoveLoadEvents = function (dom, fn, add) {
    var action = add ? _addEventListener : 'removeEventListener';

    if (add) {
      addRemoveLoadEvents(dom, fn);
    }

    loadEvents.forEach(function (evt) {
      dom[action](evt, fn);
    });
  };
  /**
   * @param elem { Element }
   * @param name { string }
   * @param detail { any }
   * @param noBubbles { boolean }
   * @param noCancelable { boolean }
   * @returns { CustomEvent }
   */


  var triggerEvent = function (elem, name, detail, noBubbles, noCancelable) {
    var event = document.createEvent('Event');

    if (!detail) {
      detail = {};
    }

    detail.instance = lazysizes;
    event.initEvent(name, !noBubbles, !noCancelable);
    event.detail = detail;
    elem.dispatchEvent(event);
    return event;
  };

  var updatePolyfill = function (el, full) {
    var polyfill;

    if (!supportPicture && (polyfill = window.picturefill || lazySizesCfg.pf)) {
      if (full && full.src && !el[_getAttribute]('srcset')) {
        el.setAttribute('srcset', full.src);
      }

      polyfill({
        reevaluate: true,
        elements: [el]
      });
    } else if (full && full.src) {
      el.src = full.src;
    }
  };

  var getCSS = function (elem, style) {
    return (getComputedStyle(elem, null) || {})[style];
  };
  /**
   *
   * @param elem { Element }
   * @param parent { Element }
   * @param [width] {number}
   * @returns {number}
   */


  var getWidth = function (elem, parent, width) {
    width = width || elem.offsetWidth;

    while (width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth) {
      width = parent.offsetWidth;
      parent = parent.parentNode;
    }

    return width;
  };

  var rAF = function () {
    var running, waiting;
    var firstFns = [];
    var secondFns = [];
    var fns = firstFns;

    var run = function () {
      var runFns = fns;
      fns = firstFns.length ? secondFns : firstFns;
      running = true;
      waiting = false;

      while (runFns.length) {
        runFns.shift()();
      }

      running = false;
    };

    var rafBatch = function (fn, queue) {
      if (running && !queue) {
        fn.apply(this, arguments);
      } else {
        fns.push(fn);

        if (!waiting) {
          waiting = true;
          (document.hidden ? setTimeout : requestAnimationFrame)(run);
        }
      }
    };

    rafBatch._lsFlush = run;
    return rafBatch;
  }();

  var rAFIt = function (fn, simple) {
    return simple ? function () {
      rAF(fn);
    } : function () {
      var that = this;
      var args = arguments;
      rAF(function () {
        fn.apply(that, args);
      });
    };
  };

  var throttle = function (fn) {
    var running;
    var lastTime = 0;
    var gDelay = lazySizesCfg.throttleDelay;
    var rICTimeout = lazySizesCfg.ricTimeout;

    var run = function () {
      running = false;
      lastTime = Date.now();
      fn();
    };

    var idleCallback = requestIdleCallback && rICTimeout > 49 ? function () {
      requestIdleCallback(run, {
        timeout: rICTimeout
      });

      if (rICTimeout !== lazySizesCfg.ricTimeout) {
        rICTimeout = lazySizesCfg.ricTimeout;
      }
    } : rAFIt(function () {
      setTimeout(run);
    }, true);
    return function (isPriority) {
      var delay;

      if (isPriority = isPriority === true) {
        rICTimeout = 33;
      }

      if (running) {
        return;
      }

      running = true;
      delay = gDelay - (Date.now() - lastTime);

      if (delay < 0) {
        delay = 0;
      }

      if (isPriority || delay < 9) {
        idleCallback();
      } else {
        setTimeout(idleCallback, delay);
      }
    };
  }; //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html


  var debounce = function (func) {
    var timeout, timestamp;
    var wait = 99;

    var run = function () {
      timeout = null;
      func();
    };

    var later = function () {
      var last = Date.now() - timestamp;

      if (last < wait) {
        setTimeout(later, wait - last);
      } else {
        (requestIdleCallback || run)(run);
      }
    };

    return function () {
      timestamp = Date.now();

      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
    };
  };

  var loader = function () {
    var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;
    var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;
    var regImg = /^img$/i;
    var regIframe = /^iframe$/i;
    var supportScroll = 'onscroll' in window && !/(gle|ing)bot/.test(navigator.userAgent);
    var shrinkExpand = 0;
    var currentExpand = 0;
    var isLoading = 0;
    var lowRuns = -1;

    var resetPreloading = function (e) {
      isLoading--;

      if (!e || isLoading < 0 || !e.target) {
        isLoading = 0;
      }
    };

    var isVisible = function (elem) {
      if (isBodyHidden == null) {
        isBodyHidden = getCSS(document.body, 'visibility') == 'hidden';
      }

      return isBodyHidden || !(getCSS(elem.parentNode, 'visibility') == 'hidden' && getCSS(elem, 'visibility') == 'hidden');
    };

    var isNestedVisible = function (elem, elemExpand) {
      var outerRect;
      var parent = elem;
      var visible = isVisible(elem);
      eLtop -= elemExpand;
      eLbottom += elemExpand;
      eLleft -= elemExpand;
      eLright += elemExpand;

      while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {
        visible = (getCSS(parent, 'opacity') || 1) > 0;

        if (visible && getCSS(parent, 'overflow') != 'visible') {
          outerRect = parent.getBoundingClientRect();
          visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;
        }
      }

      return visible;
    };

    var checkElements = function () {
      var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal, defaultExpand, preloadExpand, hFac;
      var lazyloadElems = lazysizes.elements;

      if ((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
        i = 0;
        lowRuns++;

        for (; i < eLlen; i++) {
          if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
            continue;
          }

          if (!supportScroll || lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i])) {
            unveilElement(lazyloadElems[i]);
            continue;
          }

          if (!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)) {
            elemExpand = currentExpand;
          }

          if (!defaultExpand) {
            defaultExpand = !lazySizesCfg.expand || lazySizesCfg.expand < 1 ? docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 : lazySizesCfg.expand;
            lazysizes._defEx = defaultExpand;
            preloadExpand = defaultExpand * lazySizesCfg.expFactor;
            hFac = lazySizesCfg.hFac;
            isBodyHidden = null;

            if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden) {
              currentExpand = preloadExpand;
              lowRuns = 0;
            } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
              currentExpand = defaultExpand;
            } else {
              currentExpand = shrinkExpand;
            }
          }

          if (beforeExpandVal !== elemExpand) {
            eLvW = innerWidth + elemExpand * hFac;
            elvH = innerHeight + elemExpand;
            elemNegativeExpand = elemExpand * -1;
            beforeExpandVal = elemExpand;
          }

          rect = lazyloadElems[i].getBoundingClientRect();

          if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesCfg.loadHidden || isVisible(lazyloadElems[i])) && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i], elemExpand))) {
            unveilElement(lazyloadElems[i]);
            loadedSomething = true;

            if (isLoading > 9) {
              break;
            }
          } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesCfg.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || lazyloadElems[i][_getAttribute](lazySizesCfg.sizesAttr) != 'auto'))) {
            autoLoadElem = preloadElems[0] || lazyloadElems[i];
          }
        }

        if (autoLoadElem && !loadedSomething) {
          unveilElement(autoLoadElem);
        }
      }
    };

    var throttledCheckElements = throttle(checkElements);

    var switchLoadingClass = function (e) {
      var elem = e.target;

      if (elem._lazyCache) {
        delete elem._lazyCache;
        return;
      }

      resetPreloading(e);
      addClass(elem, lazySizesCfg.loadedClass);
      removeClass(elem, lazySizesCfg.loadingClass);
      addRemoveLoadEvents(elem, rafSwitchLoadingClass);
      triggerEvent(elem, 'lazyloaded');
    };

    var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);

    var rafSwitchLoadingClass = function (e) {
      rafedSwitchLoadingClass({
        target: e.target
      });
    };

    var changeIframeSrc = function (elem, src) {
      var loadMode = elem.getAttribute('data-load-mode') || lazySizesCfg.iframeLoadMode; // loadMode can be also a string!

      if (loadMode == 0) {
        elem.contentWindow.location.replace(src);
      } else if (loadMode == 1) {
        elem.src = src;
      }
    };

    var handleSources = function (source) {
      var customMedia;

      var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);

      if (customMedia = lazySizesCfg.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) {
        source.setAttribute('media', customMedia);
      }

      if (sourceSrcset) {
        source.setAttribute('srcset', sourceSrcset);
      }
    };

    var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg) {
      var src, srcset, parent, isPicture, event, firesLoad;

      if (!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented) {
        if (sizes) {
          if (isAuto) {
            addClass(elem, lazySizesCfg.autosizesClass);
          } else {
            elem.setAttribute('sizes', sizes);
          }
        }

        srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);
        src = elem[_getAttribute](lazySizesCfg.srcAttr);

        if (isImg) {
          parent = elem.parentNode;
          isPicture = parent && regPicture.test(parent.nodeName || '');
        }

        firesLoad = detail.firesLoad || 'src' in elem && (srcset || src || isPicture);
        event = {
          target: elem
        };
        addClass(elem, lazySizesCfg.loadingClass);

        if (firesLoad) {
          clearTimeout(resetPreloadingTimer);
          resetPreloadingTimer = setTimeout(resetPreloading, 2500);
          addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
        }

        if (isPicture) {
          forEach.call(parent.getElementsByTagName('source'), handleSources);
        }

        if (srcset) {
          elem.setAttribute('srcset', srcset);
        } else if (src && !isPicture) {
          if (regIframe.test(elem.nodeName)) {
            changeIframeSrc(elem, src);
          } else {
            elem.src = src;
          }
        }

        if (isImg && (srcset || isPicture)) {
          updatePolyfill(elem, {
            src: src
          });
        }
      }

      if (elem._lazyRace) {
        delete elem._lazyRace;
      }

      removeClass(elem, lazySizesCfg.lazyClass);
      rAF(function () {
        // Part of this can be removed as soon as this fix is older: https://bugs.chromium.org/p/chromium/issues/detail?id=7731 (2015)
        var isLoaded = elem.complete && elem.naturalWidth > 1;

        if (!firesLoad || isLoaded) {
          if (isLoaded) {
            addClass(elem, lazySizesCfg.fastLoadedClass);
          }

          switchLoadingClass(event);
          elem._lazyCache = true;
          setTimeout(function () {
            if ('_lazyCache' in elem) {
              delete elem._lazyCache;
            }
          }, 9);
        }

        if (elem.loading == 'lazy') {
          isLoading--;
        }
      }, true);
    });
    /**
     *
     * @param elem { Element }
     */

    var unveilElement = function (elem) {
      if (elem._lazyRace) {
        return;
      }

      var detail;
      var isImg = regImg.test(elem.nodeName); //allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")

      var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]('sizes'));

      var isAuto = sizes == 'auto';

      if ((isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesCfg.errorClass) && hasClass(elem, lazySizesCfg.lazyClass)) {
        return;
      }

      detail = triggerEvent(elem, 'lazyunveilread').detail;

      if (isAuto) {
        autoSizer.updateElem(elem, true, elem.offsetWidth);
      }

      elem._lazyRace = true;
      isLoading++;
      lazyUnveil(elem, detail, isAuto, sizes, isImg);
    };

    var afterScroll = debounce(function () {
      lazySizesCfg.loadMode = 3;
      throttledCheckElements();
    });

    var altLoadmodeScrollListner = function () {
      if (lazySizesCfg.loadMode == 3) {
        lazySizesCfg.loadMode = 2;
      }

      afterScroll();
    };

    var onload = function () {
      if (isCompleted) {
        return;
      }

      if (Date.now() - started < 999) {
        setTimeout(onload, 999);
        return;
      }

      isCompleted = true;
      lazySizesCfg.loadMode = 3;
      throttledCheckElements();
      addEventListener('scroll', altLoadmodeScrollListner, true);
    };

    return {
      _: function () {
        started = Date.now();
        lazysizes.elements = document.getElementsByClassName(lazySizesCfg.lazyClass);
        preloadElems = document.getElementsByClassName(lazySizesCfg.lazyClass + ' ' + lazySizesCfg.preloadClass);
        addEventListener('scroll', throttledCheckElements, true);
        addEventListener('resize', throttledCheckElements, true);
        addEventListener('pageshow', function (e) {
          if (e.persisted) {
            var loadingElements = document.querySelectorAll('.' + lazySizesCfg.loadingClass);

            if (loadingElements.length && loadingElements.forEach) {
              requestAnimationFrame(function () {
                loadingElements.forEach(function (img) {
                  if (img.complete) {
                    unveilElement(img);
                  }
                });
              });
            }
          }
        });

        if (window.MutationObserver) {
          new MutationObserver(throttledCheckElements).observe(docElem, {
            childList: true,
            subtree: true,
            attributes: true
          });
        } else {
          docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);

          docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);

          setInterval(throttledCheckElements, 999);
        }

        addEventListener('hashchange', throttledCheckElements, true); //, 'fullscreenchange'

        ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend'].forEach(function (name) {
          document[_addEventListener](name, throttledCheckElements, true);
        });

        if (/d$|^c/.test(document.readyState)) {
          onload();
        } else {
          addEventListener('load', onload);

          document[_addEventListener]('DOMContentLoaded', throttledCheckElements);

          setTimeout(onload, 20000);
        }

        if (lazysizes.elements.length) {
          checkElements();

          rAF._lsFlush();
        } else {
          throttledCheckElements();
        }
      },
      checkElems: throttledCheckElements,
      unveil: unveilElement,
      _aLSL: altLoadmodeScrollListner
    };
  }();

  var autoSizer = function () {
    var autosizesElems;
    var sizeElement = rAFIt(function (elem, parent, event, width) {
      var sources, i, len;
      elem._lazysizesWidth = width;
      width += 'px';
      elem.setAttribute('sizes', width);

      if (regPicture.test(parent.nodeName || '')) {
        sources = parent.getElementsByTagName('source');

        for (i = 0, len = sources.length; i < len; i++) {
          sources[i].setAttribute('sizes', width);
        }
      }

      if (!event.detail.dataAttr) {
        updatePolyfill(elem, event.detail);
      }
    });
    /**
     *
     * @param elem {Element}
     * @param dataAttr
     * @param [width] { number }
     */

    var getSizeElement = function (elem, dataAttr, width) {
      var event;
      var parent = elem.parentNode;

      if (parent) {
        width = getWidth(elem, parent, width);
        event = triggerEvent(elem, 'lazybeforesizes', {
          width: width,
          dataAttr: !!dataAttr
        });

        if (!event.defaultPrevented) {
          width = event.detail.width;

          if (width && width !== elem._lazysizesWidth) {
            sizeElement(elem, parent, event, width);
          }
        }
      }
    };

    var updateElementsSizes = function () {
      var i;
      var len = autosizesElems.length;

      if (len) {
        i = 0;

        for (; i < len; i++) {
          getSizeElement(autosizesElems[i]);
        }
      }
    };

    var debouncedUpdateElementsSizes = debounce(updateElementsSizes);
    return {
      _: function () {
        autosizesElems = document.getElementsByClassName(lazySizesCfg.autosizesClass);
        addEventListener('resize', debouncedUpdateElementsSizes);
      },
      checkElems: debouncedUpdateElementsSizes,
      updateElem: getSizeElement
    };
  }();

  var init = function () {
    if (!init.i && document.getElementsByClassName) {
      init.i = true;

      autoSizer._();

      loader._();
    }
  };

  setTimeout(function () {
    if (lazySizesCfg.init) {
      init();
    }
  });
  lazysizes = {
    /**
     * @type { LazySizesConfigPartial }
     */
    cfg: lazySizesCfg,
    autoSizer: autoSizer,
    loader: loader,
    init: init,
    uP: updatePolyfill,
    aC: addClass,
    rC: removeClass,
    hC: hasClass,
    fire: triggerEvent,
    gW: getWidth,
    rAF: rAF
  };
  return lazysizes;
});
/*
This plugin extends lazySizes to lazyLoad:
background images, videos/posters and scripts

Background-Image:
For background images, use data-bg attribute:
<div class="lazyload" data-bg="bg-img.jpg"></div>

 Video:
 For video/audio use data-poster and preload="none":
 <video class="lazyload" preload="none" data-poster="poster.jpg" src="src.mp4">
 <!-- sources -->
 </video>

 For video that plays automatically if in view:
 <video
	class="lazyload"
	preload="none"
	muted=""
	data-autoplay=""
	data-poster="poster.jpg"
	src="src.mp4">
</video>

 Scripts:
 For scripts use data-script:
 <div class="lazyload" data-script="module-name.js"></div>


 Script modules using require:
 For modules using require use data-require:
 <div class="lazyload" data-require="module-name"></div>
*/
(function (window, factory) {
  var globalInstall = function () {
    factory(window.lazySizes);
    window.removeEventListener('lazyunveilread', globalInstall, true);
  };

  factory = factory.bind(null, window, window.document);

  if (typeof module == 'object' && module.exports) {
    factory(require('lazysizes'));
  } else if (typeof define == 'function' && define.amd) {
    define(['lazysizes'], factory);
  } else if (window.lazySizes) {
    globalInstall();
  } else {
    window.addEventListener('lazyunveilread', globalInstall, true);
  }
})(window, function (window, document, lazySizes) {
  /*jshint eqnull:true */
  'use strict';

  var bgLoad, regBgUrlEscape;
  var uniqueUrls = {};

  if (document.addEventListener) {
    regBgUrlEscape = /\(|\)|\s|'/;

    bgLoad = function (url, cb) {
      var img = document.createElement('img');

      img.onload = function () {
        img.onload = null;
        img.onerror = null;
        img = null;
        cb();
      };

      img.onerror = img.onload;
      img.src = url;

      if (img && img.complete && img.onload) {
        img.onload();
      }
    };

    addEventListener('lazybeforeunveil', function (e) {
      if (e.detail.instance != lazySizes) {
        return;
      }

      var tmp, load, bg, poster;

      if (!e.defaultPrevented) {
        var target = e.target;

        if (target.preload == 'none') {
          target.preload = target.getAttribute('data-preload') || 'auto';
        }

        if (target.getAttribute('data-autoplay') != null) {
          if (target.getAttribute('data-expand') && !target.autoplay) {
            try {
              target.play();
            } catch (er) {}
          } else {
            requestAnimationFrame(function () {
              target.setAttribute('data-expand', '-10');
              lazySizes.aC(target, lazySizes.cfg.lazyClass);
            });
          }
        }

        tmp = target.getAttribute('data-link');

        if (tmp) {
          addStyleScript(tmp, true);
        } // handle data-script


        tmp = target.getAttribute('data-script');

        if (tmp) {
          e.detail.firesLoad = true;

          load = function () {
            e.detail.firesLoad = false;
            lazySizes.fire(target, '_lazyloaded', {}, true, true);
          };

          addStyleScript(tmp, null, load);
        } // handle data-require


        tmp = target.getAttribute('data-require');

        if (tmp) {
          if (lazySizes.cfg.requireJs) {
            lazySizes.cfg.requireJs([tmp]);
          } else {
            addStyleScript(tmp);
          }
        } // handle data-bg


        bg = target.getAttribute('data-bg');

        if (bg) {
          e.detail.firesLoad = true;

          load = function () {
            target.style.backgroundImage = 'url(' + (regBgUrlEscape.test(bg) ? JSON.stringify(bg) : bg) + ')';
            e.detail.firesLoad = false;
            lazySizes.fire(target, '_lazyloaded', {}, true, true);
          };

          bgLoad(bg, load);
        } // handle data-poster


        poster = target.getAttribute('data-poster');

        if (poster) {
          e.detail.firesLoad = true;

          load = function () {
            target.poster = poster;
            e.detail.firesLoad = false;
            lazySizes.fire(target, '_lazyloaded', {}, true, true);
          };

          bgLoad(poster, load);
        }
      }
    }, false);
  }

  function addStyleScript(src, style, cb) {
    if (uniqueUrls[src]) {
      return;
    }

    var elem = document.createElement(style ? 'link' : 'script');
    var insertElem = document.getElementsByTagName('script')[0];

    if (style) {
      elem.rel = 'stylesheet';
      elem.href = src;
    } else {
      elem.onload = function () {
        elem.onerror = null;
        elem.onload = null;
        cb();
      };

      elem.onerror = elem.onload;
      elem.src = src;
    }

    uniqueUrls[src] = true;
    uniqueUrls[elem.src || elem.href] = true;
    insertElem.parentNode.insertBefore(elem, insertElem);
  }
});
/**
 * Swiper 7.0.9
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2021 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: October 18, 2021
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());
})(this, function () {
  'use strict';
  /**
   * SSR Window 4.0.0
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2021, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: August 25, 2021
   */

  /* eslint-disable no-param-reassign */

  function isObject$1(obj) {
    return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
  }

  function extend$1(target = {}, src = {}) {
    Object.keys(src).forEach(key => {
      if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
        extend$1(target[key], src[key]);
      }
    });
  }

  const ssrDocument = {
    body: {},

    addEventListener() {},

    removeEventListener() {},

    activeElement: {
      blur() {},

      nodeName: ''
    },

    querySelector() {
      return null;
    },

    querySelectorAll() {
      return [];
    },

    getElementById() {
      return null;
    },

    createEvent() {
      return {
        initEvent() {}

      };
    },

    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},

        setAttribute() {},

        getElementsByTagName() {
          return [];
        }

      };
    },

    createElementNS() {
      return {};
    },

    importNode() {
      return null;
    },

    location: {
      hash: '',
      host: '',
      hostname: '',
      href: '',
      origin: '',
      pathname: '',
      protocol: '',
      search: ''
    }
  };

  function getDocument() {
    const doc = typeof document !== 'undefined' ? document : {};
    extend$1(doc, ssrDocument);
    return doc;
  }

  const ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ''
    },
    location: {
      hash: '',
      host: '',
      hostname: '',
      href: '',
      origin: '',
      pathname: '',
      protocol: '',
      search: ''
    },
    history: {
      replaceState() {},

      pushState() {},

      go() {},

      back() {}

    },
    CustomEvent: function CustomEvent() {
      return this;
    },

    addEventListener() {},

    removeEventListener() {},

    getComputedStyle() {
      return {
        getPropertyValue() {
          return '';
        }

      };
    },

    Image() {},

    Date() {},

    screen: {},

    setTimeout() {},

    clearTimeout() {},

    matchMedia() {
      return {};
    },

    requestAnimationFrame(callback) {
      if (typeof setTimeout === 'undefined') {
        callback();
        return null;
      }

      return setTimeout(callback, 0);
    },

    cancelAnimationFrame(id) {
      if (typeof setTimeout === 'undefined') {
        return;
      }

      clearTimeout(id);
    }

  };

  function getWindow() {
    const win = typeof window !== 'undefined' ? window : {};
    extend$1(win, ssrWindow);
    return win;
  }
  /**
   * Dom7 4.0.0
   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
   * https://framework7.io/docs/dom7.html
   *
   * Copyright 2021, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: August 25, 2021
   */

  /* eslint-disable no-proto */


  function makeReactive(obj) {
    const proto = obj.__proto__;
    Object.defineProperty(obj, '__proto__', {
      get() {
        return proto;
      },

      set(value) {
        proto.__proto__ = value;
      }

    });
  }

  class Dom7 extends Array {
    constructor(items) {
      super(...(items || []));
      makeReactive(this);
    }

  }

  function arrayFlat(arr = []) {
    const res = [];
    arr.forEach(el => {
      if (Array.isArray(el)) {
        res.push(...arrayFlat(el));
      } else {
        res.push(el);
      }
    });
    return res;
  }

  function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
  }

  function arrayUnique(arr) {
    const uniqueArray = [];

    for (let i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
    }

    return uniqueArray;
  }

  function qsa(selector, context) {
    if (typeof selector !== 'string') {
      return [selector];
    }

    const a = [];
    const res = context.querySelectorAll(selector);

    for (let i = 0; i < res.length; i += 1) {
      a.push(res[i]);
    }

    return a;
  }

  function $(selector, context) {
    const window = getWindow();
    const document = getDocument();
    let arr = [];

    if (!context && selector instanceof Dom7) {
      return selector;
    }

    if (!selector) {
      return new Dom7(arr);
    }

    if (typeof selector === 'string') {
      const html = selector.trim();

      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        const tempParent = document.createElement(toCreate);
        tempParent.innerHTML = html;

        for (let i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        arr = qsa(selector.trim(), context || document);
      } // arr = qsa(selector, document);

    } else if (selector.nodeType || selector === window || selector === document) {
      arr.push(selector);
    } else if (Array.isArray(selector)) {
      if (selector instanceof Dom7) return selector;
      arr = selector;
    }

    return new Dom7(arrayUnique(arr));
  }

  $.fn = Dom7.prototype; // eslint-disable-next-line

  function addClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    this.forEach(el => {
      el.classList.add(...classNames);
    });
    return this;
  }

  function removeClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    this.forEach(el => {
      el.classList.remove(...classNames);
    });
    return this;
  }

  function toggleClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    this.forEach(el => {
      classNames.forEach(className => {
        el.classList.toggle(className);
      });
    });
  }

  function hasClass(...classes) {
    const classNames = arrayFlat(classes.map(c => c.split(' ')));
    return arrayFilter(this, el => {
      return classNames.filter(className => el.classList.contains(className)).length > 0;
    }).length > 0;
  }

  function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === 'string') {
      // Get attr
      if (this[0]) return this[0].getAttribute(attrs);
      return undefined;
    } // Set attrs


    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i].setAttribute(attrs, value);
      } else {
        // Object
        for (const attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }

    return this;
  }

  function removeAttr(attr) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr);
    }

    return this;
  }

  function transform(transform) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transform = transform;
    }

    return this;
  }

  function transition$1(duration) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
    }

    return this;
  }

  function on(...args) {
    let [eventType, targetSelector, listener, capture] = args;

    if (typeof args[1] === 'function') {
      [eventType, listener, capture] = args;
      targetSelector = undefined;
    }

    if (!capture) capture = false;

    function handleLiveEvent(e) {
      const target = e.target;
      if (!target) return;
      const eventData = e.target.dom7EventData || [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
        const parents = $(target).parents(); // eslint-disable-line

        for (let k = 0; k < parents.length; k += 1) {
          if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
        }
      }
    }

    function handleEvent(e) {
      const eventData = e && e.target ? e.target.dom7EventData || [] : [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      listener.apply(this, eventData);
    }

    const events = eventType.split(' ');
    let j;

    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];

      if (!targetSelector) {
        for (j = 0; j < events.length; j += 1) {
          const event = events[j];
          if (!el.dom7Listeners) el.dom7Listeners = {};
          if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
          el.dom7Listeners[event].push({
            listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event, handleEvent, capture);
        }
      } else {
        // Live events
        for (j = 0; j < events.length; j += 1) {
          const event = events[j];
          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
          el.dom7LiveListeners[event].push({
            listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event, handleLiveEvent, capture);
        }
      }
    }

    return this;
  }

  function off(...args) {
    let [eventType, targetSelector, listener, capture] = args;

    if (typeof args[1] === 'function') {
      [eventType, listener, capture] = args;
      targetSelector = undefined;
    }

    if (!capture) capture = false;
    const events = eventType.split(' ');

    for (let i = 0; i < events.length; i += 1) {
      const event = events[i];

      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        let handlers;

        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event];
        }

        if (handlers && handlers.length) {
          for (let k = handlers.length - 1; k >= 0; k -= 1) {
            const handler = handlers[k];

            if (listener && handler.listener === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }

    return this;
  }

  function trigger(...args) {
    const window = getWindow();
    const events = args[0].split(' ');
    const eventData = args[1];

    for (let i = 0; i < events.length; i += 1) {
      const event = events[i];

      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];

        if (window.CustomEvent) {
          const evt = new window.CustomEvent(event, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
          el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
    }

    return this;
  }

  function transitionEnd$1(callback) {
    const dom = this;

    function fireCallBack(e) {
      if (e.target !== this) return;
      callback.call(this, e);
      dom.off('transitionend', fireCallBack);
    }

    if (callback) {
      dom.on('transitionend', fireCallBack);
    }

    return this;
  }

  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles = this.styles();
        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
      }

      return this[0].offsetWidth;
    }

    return null;
  }

  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles = this.styles();
        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
      }

      return this[0].offsetHeight;
    }

    return null;
  }

  function offset() {
    if (this.length > 0) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      const box = el.getBoundingClientRect();
      const body = document.body;
      const clientTop = el.clientTop || body.clientTop || 0;
      const clientLeft = el.clientLeft || body.clientLeft || 0;
      const scrollTop = el === window ? window.scrollY : el.scrollTop;
      const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }

    return null;
  }

  function styles() {
    const window = getWindow();
    if (this[0]) return window.getComputedStyle(this[0], null);
    return {};
  }

  function css(props, value) {
    const window = getWindow();
    let i;

    if (arguments.length === 1) {
      if (typeof props === 'string') {
        // .css('width')
        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        // .css({ width: '100px' })
        for (i = 0; i < this.length; i += 1) {
          for (const prop in props) {
            this[i].style[prop] = props[prop];
          }
        }

        return this;
      }
    }

    if (arguments.length === 2 && typeof props === 'string') {
      // .css('width', '100px')
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }

      return this;
    }

    return this;
  }

  function each(callback) {
    if (!callback) return this;
    this.forEach((el, index) => {
      callback.apply(el, [el, index]);
    });
    return this;
  }

  function filter(callback) {
    const result = arrayFilter(this, callback);
    return $(result);
  }

  function html(html) {
    if (typeof html === 'undefined') {
      return this[0] ? this[0].innerHTML : null;
    }

    for (let i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html;
    }

    return this;
  }

  function text(text) {
    if (typeof text === 'undefined') {
      return this[0] ? this[0].textContent.trim() : null;
    }

    for (let i = 0; i < this.length; i += 1) {
      this[i].textContent = text;
    }

    return this;
  }

  function is(selector) {
    const window = getWindow();
    const document = getDocument();
    const el = this[0];
    let compareWith;
    let i;
    if (!el || typeof selector === 'undefined') return false;

    if (typeof selector === 'string') {
      if (el.matches) return el.matches(selector);
      if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
      if (el.msMatchesSelector) return el.msMatchesSelector(selector);
      compareWith = $(selector);

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }

      return false;
    }

    if (selector === document) {
      return el === document;
    }

    if (selector === window) {
      return el === window;
    }

    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }

      return false;
    }

    return false;
  }

  function index() {
    let child = this[0];
    let i;

    if (child) {
      i = 0; // eslint-disable-next-line

      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i += 1;
      }

      return i;
    }

    return undefined;
  }

  function eq(index) {
    if (typeof index === 'undefined') return this;
    const length = this.length;

    if (index > length - 1) {
      return $([]);
    }

    if (index < 0) {
      const returnIndex = length + index;
      if (returnIndex < 0) return $([]);
      return $([this[returnIndex]]);
    }

    return $([this[index]]);
  }

  function append(...els) {
    let newChild;
    const document = getDocument();

    for (let k = 0; k < els.length; k += 1) {
      newChild = els[k];

      for (let i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (let j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }

    return this;
  }

  function prepend(newChild) {
    const document = getDocument();
    let i;
    let j;

    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }

    return this;
  }

  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return $([this[0].nextElementSibling]);
        }

        return $([]);
      }

      if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
      return $([]);
    }

    return $([]);
  }

  function nextAll(selector) {
    const nextEls = [];
    let el = this[0];
    if (!el) return $([]);

    while (el.nextElementSibling) {
      const next = el.nextElementSibling; // eslint-disable-line

      if (selector) {
        if ($(next).is(selector)) nextEls.push(next);
      } else nextEls.push(next);

      el = next;
    }

    return $(nextEls);
  }

  function prev(selector) {
    if (this.length > 0) {
      const el = this[0];

      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return $([el.previousElementSibling]);
        }

        return $([]);
      }

      if (el.previousElementSibling) return $([el.previousElementSibling]);
      return $([]);
    }

    return $([]);
  }

  function prevAll(selector) {
    const prevEls = [];
    let el = this[0];
    if (!el) return $([]);

    while (el.previousElementSibling) {
      const prev = el.previousElementSibling; // eslint-disable-line

      if (selector) {
        if ($(prev).is(selector)) prevEls.push(prev);
      } else prevEls.push(prev);

      el = prev;
    }

    return $(prevEls);
  }

  function parent(selector) {
    const parents = []; // eslint-disable-line

    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
        } else {
          parents.push(this[i].parentNode);
        }
      }
    }

    return $(parents);
  }

  function parents(selector) {
    const parents = []; // eslint-disable-line

    for (let i = 0; i < this.length; i += 1) {
      let parent = this[i].parentNode; // eslint-disable-line

      while (parent) {
        if (selector) {
          if ($(parent).is(selector)) parents.push(parent);
        } else {
          parents.push(parent);
        }

        parent = parent.parentNode;
      }
    }

    return $(parents);
  }

  function closest(selector) {
    let closest = this; // eslint-disable-line

    if (typeof selector === 'undefined') {
      return $([]);
    }

    if (!closest.is(selector)) {
      closest = closest.parents(selector).eq(0);
    }

    return closest;
  }

  function find(selector) {
    const foundElements = [];

    for (let i = 0; i < this.length; i += 1) {
      const found = this[i].querySelectorAll(selector);

      for (let j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }

    return $(foundElements);
  }

  function children(selector) {
    const children = []; // eslint-disable-line

    for (let i = 0; i < this.length; i += 1) {
      const childNodes = this[i].children;

      for (let j = 0; j < childNodes.length; j += 1) {
        if (!selector || $(childNodes[j]).is(selector)) {
          children.push(childNodes[j]);
        }
      }
    }

    return $(children);
  }

  function remove() {
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
    }

    return this;
  }

  const Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition: transition$1,
    on,
    off,
    trigger,
    transitionEnd: transitionEnd$1,
    outerWidth,
    outerHeight,
    styles,
    offset,
    css,
    each,
    html,
    text,
    is,
    index,
    eq,
    append,
    prepend,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find,
    children,
    filter,
    remove
  };
  Object.keys(Methods).forEach(methodName => {
    Object.defineProperty($.fn, methodName, {
      value: Methods[methodName],
      writable: true
    });
  });

  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach(key => {
      try {
        object[key] = null;
      } catch (e) {// no getter for object
      }

      try {
        delete object[key];
      } catch (e) {// something got wrong
      }
    });
  }

  function nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  }

  function now() {
    return Date.now();
  }

  function getComputedStyle$1(el) {
    const window = getWindow();
    let style;

    if (window.getComputedStyle) {
      style = window.getComputedStyle(el, null);
    }

    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }

    if (!style) {
      style = el.style;
    }

    return style;
  }

  function getTranslate(el, axis = 'x') {
    const window = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle$1(el);

    if (window.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;

      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      } // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case


      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }

    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }

    return curTransform || 0;
  }

  function isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
  }

  function isNode(node) {
    // eslint-disable-next-line
    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
      return node instanceof HTMLElement;
    }

    return node && (node.nodeType === 1 || node.nodeType === 11);
  }

  function extend(...args) {
    const to = Object(args[0]);
    const noExtend = ['__proto__', 'constructor', 'prototype'];

    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];

      if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

          if (desc !== undefined && desc.enumerable) {
            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
              to[nextKey] = {};

              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }

    return to;
  }

  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }

  function animateCSSModeScroll({
    swiper,
    targetPosition,
    side
  }) {
    const window = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = 'none';
    window.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? 'next' : 'prev';

    const isOutOfBound = (current, target) => {
      return dir === 'next' && current >= target || dir === 'prev' && current <= target;
    };

    const animate = () => {
      time = new Date().getTime();

      if (startTime === null) {
        startTime = time;
      }

      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }

      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });

      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = 'hidden';
        swiper.wrapperEl.style.scrollSnapType = '';
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = '';
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }

      swiper.cssModeFrameID = window.requestAnimationFrame(animate);
    };

    animate();
  }

  let support;

  function calcSupport() {
    const window = getWindow();
    const document = getDocument();
    return {
      smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
      passiveListener: function checkPassiveListener() {
        let supportsPassive = false;

        try {
          const opts = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line
            get() {
              supportsPassive = true;
            }

          });
          window.addEventListener('testPassiveListener', null, opts);
        } catch (e) {// No support
        }

        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return 'ongesturestart' in window;
      }()
    };
  }

  function getSupport() {
    if (!support) {
      support = calcSupport();
    }

    return support;
  }

  let deviceCached;

  function calcDevice({
    userAgent
  } = {}) {
    const support = getSupport();
    const window = getWindow();
    const platform = window.navigator.platform;
    const ua = userAgent || window.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === 'Win32';
    let macos = platform === 'MacIntel'; // iPadOs 13 fix

    const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, '13_0_0'];
      macos = false;
    } // Android


    if (android && !windows) {
      device.os = 'android';
      device.android = true;
    }

    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    } // Export object


    return device;
  }

  function getDevice(overrides = {}) {
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }

    return deviceCached;
  }

  let browser;

  function calcBrowser() {
    const window = getWindow();

    function isSafari() {
      const ua = window.navigator.userAgent.toLowerCase();
      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }

    return {
      isSafari: isSafari(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
    };
  }

  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }

    return browser;
  }

  function Resize({
    swiper,
    on,
    emit
  }) {
    const window = getWindow();
    let observer = null;

    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit('beforeResize');
      emit('resize');
    };

    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      observer = new ResizeObserver(entries => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });

        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
      observer.observe(swiper.el);
    };

    const removeObserver = () => {
      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };

    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit('orientationchange');
    };

    on('init', () => {
      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
        createObserver();
        return;
      }

      window.addEventListener('resize', resizeHandler);
      window.addEventListener('orientationchange', orientationChangeHandler);
    });
    on('destroy', () => {
      removeObserver();
      window.removeEventListener('resize', resizeHandler);
      window.removeEventListener('orientationchange', orientationChangeHandler);
    });
  }

  function Observer({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const observers = [];
    const window = getWindow();

    const attach = (target, options = {}) => {
      const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
      const observer = new ObserverFunc(mutations => {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (mutations.length === 1) {
          emit('observerUpdate', mutations[0]);
          return;
        }

        const observerUpdate = function observerUpdate() {
          emit('observerUpdate', mutations[0]);
        };

        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(observerUpdate);
        } else {
          window.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData
      });
      observers.push(observer);
    };

    const init = () => {
      if (!swiper.params.observer) return;

      if (swiper.params.observeParents) {
        const containerParents = swiper.$el.parents();

        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      } // Observe container


      attach(swiper.$el[0], {
        childList: swiper.params.observeSlideChildren
      }); // Observe wrapper

      attach(swiper.$wrapperEl[0], {
        attributes: false
      });
    };

    const destroy = () => {
      observers.forEach(observer => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };

    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on('init', init);
    on('destroy', destroy);
  }
  /* eslint-disable no-underscore-dangle */


  var eventsEmitter = {
    on(events, handler, priority) {
      const self = this;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';
      events.split(' ').forEach(event => {
        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
        self.eventsListeners[event][method](handler);
      });
      return self;
    },

    once(events, handler, priority) {
      const self = this;
      if (typeof handler !== 'function') return self;

      function onceHandler(...args) {
        self.off(events, onceHandler);

        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }

        handler.apply(self, args);
      }

      onceHandler.__emitterProxy = handler;
      return self.on(events, onceHandler, priority);
    },

    onAny(handler, priority) {
      const self = this;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';

      if (self.eventsAnyListeners.indexOf(handler) < 0) {
        self.eventsAnyListeners[method](handler);
      }

      return self;
    },

    offAny(handler) {
      const self = this;
      if (!self.eventsAnyListeners) return self;
      const index = self.eventsAnyListeners.indexOf(handler);

      if (index >= 0) {
        self.eventsAnyListeners.splice(index, 1);
      }

      return self;
    },

    off(events, handler) {
      const self = this;
      if (!self.eventsListeners) return self;
      events.split(' ').forEach(event => {
        if (typeof handler === 'undefined') {
          self.eventsListeners[event] = [];
        } else if (self.eventsListeners[event]) {
          self.eventsListeners[event].forEach((eventHandler, index) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self.eventsListeners[event].splice(index, 1);
            }
          });
        }
      });
      return self;
    },

    emit(...args) {
      const self = this;
      if (!self.eventsListeners) return self;
      let events;
      let data;
      let context;

      if (typeof args[0] === 'string' || Array.isArray(args[0])) {
        events = args[0];
        data = args.slice(1, args.length);
        context = self;
      } else {
        events = args[0].events;
        data = args[0].data;
        context = args[0].context || self;
      }

      data.unshift(context);
      const eventsArray = Array.isArray(events) ? events : events.split(' ');
      eventsArray.forEach(event => {
        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
          self.eventsAnyListeners.forEach(eventHandler => {
            eventHandler.apply(context, [event, ...data]);
          });
        }

        if (self.eventsListeners && self.eventsListeners[event]) {
          self.eventsListeners[event].forEach(eventHandler => {
            eventHandler.apply(context, data);
          });
        }
      });
      return self;
    }

  };

  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const $el = swiper.$el;

    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }

    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }

    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    } // Subtract paddings


    width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
    height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  function updateSlides() {
    const swiper = this;

    function getDirectionLabel(property) {
      if (swiper.isHorizontal()) {
        return property;
      } // prettier-ignore


      return {
        'width': 'height',
        'margin-top': 'margin-left',
        'margin-bottom ': 'margin-right',
        'margin-left': 'margin-top',
        'margin-right': 'margin-bottom',
        'padding-left': 'padding-top',
        'padding-right': 'padding-bottom',
        'marginRight': 'marginBottom'
      }[property];
    }

    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }

    const params = swiper.params;
    const {
      $wrapperEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;

    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }

    let offsetAfter = params.slidesOffsetAfter;

    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }

    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;

    if (typeof swiperSize === 'undefined') {
      return;
    }

    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    }

    swiper.virtualSize = -spaceBetween; // reset margins

    if (rtl) slides.css({
      marginLeft: '',
      marginBottom: '',
      marginTop: ''
    });else slides.css({
      marginRight: '',
      marginBottom: '',
      marginTop: ''
    }); // reset cssMode offsets

    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
    }

    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

    if (gridEnabled) {
      swiper.grid.initSlides(slidesLength);
    } // Calc slides


    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
      return typeof params.breakpoints[key].slidesPerView !== 'undefined';
    }).length > 0;

    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      const slide = slides.eq(i);

      if (gridEnabled) {
        swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
      }

      if (slide.css('display') === 'none') continue; // eslint-disable-line

      if (params.slidesPerView === 'auto') {
        if (shouldResetSlideSize) {
          slides[i].style[getDirectionLabel('width')] = ``;
        }

        const slideStyles = getComputedStyle(slide[0]);
        const currentTransform = slide[0].style.transform;
        const currentWebKitTransform = slide[0].style.webkitTransform;

        if (currentTransform) {
          slide[0].style.transform = 'none';
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = 'none';
        }

        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          // eslint-disable-next-line
          const width = getDirectionPropertyValue(slideStyles, 'width');
          const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
          const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
          const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
          const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
          const boxSizing = slideStyles.getPropertyValue('box-sizing');

          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide[0];
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }

        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }

        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);

        if (slides[i]) {
          slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
        }
      }

      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }

      slidesSizesGrid.push(slideSize);

      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }

      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }

    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      $wrapperEl.css({
        width: `${swiper.virtualSize + params.spaceBetween}px`
      });
    }

    if (params.setWrapperSize) {
      $wrapperEl.css({
        [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
      });
    }

    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
    } // Remove last grid elements depending on width


    if (!params.centeredSlides) {
      const newSlidesGrid = [];

      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }

      snapGrid = newSlidesGrid;

      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }

    if (snapGrid.length === 0) snapGrid = [0];

    if (params.spaceBetween !== 0) {
      const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
      slides.filter((_, slideIndex) => {
        if (!params.cssMode) return true;

        if (slideIndex === slides.length - 1) {
          return false;
        }

        return true;
      }).css({
        [key]: `${spaceBetween}px`
      });
    }

    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach(slideSizeValue => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map(snap => {
        if (snap < 0) return -offsetBefore;
        if (snap > maxSnap) return maxSnap + offsetAfter;
        return snap;
      });
    }

    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach(slideSizeValue => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;

      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }

    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });

    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
    }

    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }

    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit('snapGridLengthChange');
    }

    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }

    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
  }

  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i;

    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }

    const getSlideByIndex = index => {
      if (isVirtual) {
        return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
      }

      return swiper.slides.eq(index)[0];
    }; // Find slides currently in view


    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        swiper.visibleSlides.each(slide => {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          const index = swiper.activeIndex + i;
          if (index > swiper.slides.length && !isVirtual) break;
          activeSlides.push(getSlideByIndex(index));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    } // Find new height from highest slide in view


    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    } // Update Height


    if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
  }

  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;

    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  function updateSlidesProgress(translate = this && this.translate || 0) {
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate; // Visible Slides

    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];

    for (let i = 0; i < slides.length; i += 1) {
      const slide = slides[i];
      let slideOffset = slide.swiperSlideOffset;

      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }

      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }

      slide.progress = rtl ? -slideProgress : slideProgress;
      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }

    swiper.visibleSlides = $(swiper.visibleSlides);
  }

  function updateProgress(translate) {
    const swiper = this;

    if (typeof translate === 'undefined') {
      const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }

    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;

    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }

    Object.assign(swiper, {
      progress,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }

    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }

    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit('fromEdge');
    }

    swiper.emit('progress', progress);
  }

  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      $wrapperEl,
      activeIndex,
      realIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
    let activeSlide;

    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
    } else {
      activeSlide = slides.eq(activeIndex);
    } // Active classes


    activeSlide.addClass(params.slideActiveClass);

    if (params.loop) {
      // Duplicate to all looped slides
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      }
    } // Next Slide


    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    } // Prev Slide


    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }

    if (params.loop) {
      // Duplicate to all looped slides
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
      }

      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
      }
    }

    swiper.emitSlidesClasses();
  }

  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      slidesGrid,
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;

    if (typeof activeIndex === 'undefined') {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      } // Normalize slideIndex


      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
      }
    }

    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }

    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }

      return;
    } // Get real index


    const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
    Object.assign(swiper, {
      snapIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');

    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }

    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit('slideChange');
    }
  }

  function updateClickedSlide(e) {
    const swiper = this;
    const params = swiper.params;
    const slide = $(e.target).closest(`.${params.slideClass}`)[0];
    let slideFound = false;
    let slideIndex;

    if (slide) {
      for (let i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }

    if (slide && slideFound) {
      swiper.clickedSlide = slide;

      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }

    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };

  function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate,
      $wrapperEl
    } = swiper;

    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }

    if (params.cssMode) {
      return translate;
    }

    let currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  function setTranslate(translate, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      $wrapperEl,
      wrapperEl,
      progress
    } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;

    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }

    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }

    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    }

    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }

    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate() {
    return -this.snapGrid[0];
  }

  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    const minTranslate = swiper.minTranslate();
    const maxTranslate = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

    swiper.updateProgress(newTranslate);

    if (params.cssMode) {
      const isH = swiper.isHorizontal();

      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? 'left' : 'top'
          });
          return true;
        }

        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: -newTranslate,
          behavior: 'smooth'
        });
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionEnd');
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionStart');
      }

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;

            if (runCallbacks) {
              swiper.emit('transitionEnd');
            }
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
      }
    }

    return true;
  }

  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };

  function setTransition(duration, byController) {
    const swiper = this;

    if (!swiper.params.cssMode) {
      swiper.$wrapperEl.transition(duration);
    }

    swiper.emit('setTransition', duration, byController);
  }

  function transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step
  }) {
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
    }

    swiper.emit(`transition${step}`);

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }

      swiper.emit(`slideChangeTransition${step}`);

      if (dir === 'next') {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }

  function transitionStart(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode) return;

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: 'Start'
    });
  }

  function transitionEnd(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: 'End'
    });
  }

  var transition = {
    setTransition,
    transitionStart,
    transitionEnd
  };

  function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
    if (typeof index !== 'number' && typeof index !== 'string') {
      throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
    }

    if (typeof index === 'string') {
      /**
       * The `index` argument converted from `string` to `number`.
       * @type {number}
       */
      const indexAsNumber = parseInt(index, 10);
      /**
       * Determines whether the `index` argument is a valid `number`
       * after being converted from the `string` type.
       * @type {boolean}
       */

      const isValidNumber = isFinite(indexAsNumber);

      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
      } // Knowing that the converted `index` is a valid number,
      // we can update the original argument's value.


      index = indexAsNumber;
    }

    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;

    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }

    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    }

    const translate = -snapGrid[snapIndex]; // Update progress

    swiper.updateProgress(translate); // Normalize slideIndex

    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    } // Directions locks


    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }

      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) return false;
      }
    }

    let direction;
    if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex); // Update Height

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      swiper.updateSlidesClasses();

      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }

      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }

      return false;
    }

    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t = rtl ? translate : -translate;

      if (speed === 0) {
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = 'none';
          swiper._immediateVirtual = true;
        }

        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = '';
            swiper._swiperImmediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t,
            side: isH ? 'left' : 'top'
          });
          return true;
        }

        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: t,
          behavior: 'smooth'
        });
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }
    }

    return true;
  }

  function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    let newIndex = index;

    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }

    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      animating,
      enabled,
      params
    } = swiper;
    if (!enabled) return swiper;
    let perGroup = params.slidesPerGroup;

    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
    }

    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      params,
      animating,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return swiper;

    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    const translate = rtlTranslate ? swiper.translate : -swiper.translate;

    function normalize(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }

    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map(val => normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

    if (typeof prevSnap === 'undefined' && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap, snapIndex) => {
        if (normalizedTranslate >= snap) {
          // prevSnap = snap;
          prevSnapIndex = snapIndex;
        }
      });

      if (typeof prevSnapIndex !== 'undefined') {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }

    let prevIndex = 0;

    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }

    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper = this;
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    if (translate >= swiper.snapGrid[snapIndex]) {
      // The current translate is on or after the current snap index, so the choice
      // is between the current index and the one after it.
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];

      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      // The current translate is before the current snap index, so the choice
      // is between the current index and the one before it.
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];

      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }

    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide() {
    const swiper = this;
    const {
      params,
      $wrapperEl
    } = swiper;
    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;

    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };

  function loopCreate() {
    const swiper = this;
    const document = getDocument();
    const {
      params,
      $wrapperEl
    } = swiper; // Remove duplicated slides

    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
    let slides = $wrapperEl.children(`.${params.slideClass}`);

    if (params.loopFillGroupWithBlank) {
      const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

      if (blankSlidesNum !== params.slidesPerGroup) {
        for (let i = 0; i < blankSlidesNum; i += 1) {
          const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
          $wrapperEl.append(blankNode);
        }

        slides = $wrapperEl.children(`.${params.slideClass}`);
      }
    }

    if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;

    if (swiper.loopedSlides > slides.length) {
      swiper.loopedSlides = slides.length;
    }

    const prependSlides = [];
    const appendSlides = [];
    slides.each((el, index) => {
      const slide = $(el);

      if (index < swiper.loopedSlides) {
        appendSlides.push(el);
      }

      if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
        prependSlides.push(el);
      }

      slide.attr('data-swiper-slide-index', index);
    });

    for (let i = 0; i < appendSlides.length; i += 1) {
      $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }

    for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
      $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  function loopFix() {
    const swiper = this;
    swiper.emit('beforeLoopFix');
    const {
      activeIndex,
      slides,
      loopedSlides,
      allowSlidePrev,
      allowSlideNext,
      snapGrid,
      rtlTranslate: rtl
    } = swiper;
    let newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    const snapTranslate = -snapGrid[activeIndex];
    const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      // Fix For Positive Oversliding
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }

    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
  }

  function loopDestroy() {
    const swiper = this;
    const {
      $wrapperEl,
      params,
      slides
    } = swiper;
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
    slides.removeAttr('data-swiper-slide-index');
  }

  var loop = {
    loopCreate,
    loopFix,
    loopDestroy
  };

  function setGrabCursor(moving) {
    const swiper = this;
    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
    el.style.cursor = 'move';
    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
    el.style.cursor = moving ? 'grabbing' : 'grab';
  }

  function unsetGrabCursor() {
    const swiper = this;

    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }

    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  }

  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };

  function closestElement(selector, base = this) {
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow()) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      const found = el.closest(selector);
      return found || __closestFrom(el.getRootNode().host);
    }

    return __closestFrom(base);
  }

  function onTouchStart(event) {
    const swiper = this;
    const document = getDocument();
    const window = getWindow();
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled) return;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }

    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }

    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    let $targetEl = $(e.target);

    if (params.touchEventsTarget === 'wrapper') {
      if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }

    data.isTouchEvent = e.type === 'touchstart';
    if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
    if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return; // change target el for shadow root component

    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

    if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
      $targetEl = $(event.path[0]);
    }

    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
      swiper.allowClick = true;
      return;
    }

    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }

    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === 'prevent') {
        event.preventDefault();
      } else {
        return;
      }
    }

    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;
    if (params.threshold > 0) data.allowThresholdMove = false;

    if (e.type !== 'touchstart') {
      let preventDefault = true;
      if ($targetEl.is(data.focusableElements)) preventDefault = false;

      if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
        document.activeElement.blur();
      }

      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
        e.preventDefault();
      }
    }

    swiper.emit('touchStart', e);
  }

  function onTouchMove(event) {
    const document = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled) return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;

    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      return;
    }

    if (data.isTouchEvent && e.type !== 'touchmove') return;
    const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }

    if (!swiper.allowTouchMove) {
      // isMoved = true;
      swiper.allowClick = false;

      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }

      return;
    }

    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }

    if (data.isTouchEvent && document.activeElement) {
      if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }

    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

    if (typeof data.isScrolling === 'undefined') {
      let touchAngle;

      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }

    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }

    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }

    if (!data.startMoving) {
      return;
    }

    swiper.allowClick = false;

    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }

    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }

    if (!data.isMoved) {
      if (params.loop && !params.cssMode) {
        swiper.loopFix();
      }

      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);

      if (swiper.animating) {
        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
      }

      data.allowMomentumBounce = false; // Grab Cursor

      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }

      swiper.emit('sliderFirstMove', e);
    }

    swiper.emit('sliderMove', e);
    data.isMoved = true;
    let diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;

    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }

    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
    }

    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    } // Directions locks


    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    } // Threshold


    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }

    if (!params.followFinger || params.cssMode) return; // Update active index in free mode

    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    } // Update progress


    swiper.updateProgress(data.currentTranslate); // Update translate

    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd(event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled) return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;

    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }

    data.allowTouchCallbacks = false;

    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }

      data.isMoved = false;
      data.startMoving = false;
      return;
    } // Return Grab Cursor


    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    } // Time diff


    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

    if (swiper.allowClick) {
      swiper.updateClickedSlide(e);
      swiper.emit('tap click', e);

      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit('doubleTap doubleClick', e);
      }
    }

    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed) swiper.allowClick = true;
    });

    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }

    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;

    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }

    if (params.cssMode) {
      return;
    }

    if (swiper.params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    } // Find current slide


    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];

    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (typeof slidesGrid[i + increment] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    } // Find current slide size


    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
      }

      if (swiper.swipeDirection === 'prev') {
        if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === 'next') {
          swiper.slideTo(stopIndex + increment);
        }

        if (swiper.swipeDirection === 'prev') {
          swiper.slideTo(stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0) return; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    } // Save locks


    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper; // Disable locks on resize

    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();

    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }

    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      swiper.autoplay.run();
    } // Return locks after resize


    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick(e) {
    const swiper = this;
    if (!swiper.enabled) return;

    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e.preventDefault();

      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;

    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    } // eslint-disable-next-line


    if (swiper.translate === -0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }

    swiper.emit('setTranslate', swiper.translate, false);
  }

  let dummyEventAttached = false;

  function dummyEventListener() {}

  const events = (swiper, method) => {
    const document = getDocument();
    const {
      params,
      touchEvents,
      el,
      wrapperEl,
      device,
      support
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    const swiperMethod = method; // Touch Events

    if (!support.touch) {
      el[domMethod](touchEvents.start, swiper.onTouchStart, false);
      document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
      document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
    } else {
      const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
      el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture
      } : capture);
      el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    } // Prevent Links Clicks


    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl[domMethod]('scroll', swiper.onScroll);
    } // Resize handler


    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
    } else {
      swiper[swiperMethod]('observerUpdate', onResize, true);
    }
  };

  function attachEvents() {
    const swiper = this;
    const document = getDocument();
    const {
      params,
      support
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);

    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }

    swiper.onClick = onClick.bind(swiper);

    if (support.touch && !dummyEventAttached) {
      document.addEventListener('touchstart', dummyEventListener);
      dummyEventAttached = true;
    }

    events(swiper, 'on');
  }

  function detachEvents() {
    const swiper = this;
    events(swiper, 'off');
  }

  var events$1 = {
    attachEvents,
    detachEvents
  };

  const isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };

  function setBreakpoint() {
    const swiper = this;
    const {
      activeIndex,
      initialized,
      loopedSlides = 0,
      params,
      $el
    } = swiper;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasEnabled = params.enabled;

    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}grid`);

      if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
        $el.addClass(`${params.containerModifierClass}grid-column`);
      }

      swiper.emitContainerClasses();
    }

    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    extend(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });

    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }

    swiper.currentBreakpoint = breakpoint;
    swiper.emit('_beforeBreakpoint', breakpointParams);

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }

  function getBreakpoint(breakpoints, base = 'window', containerEl) {
    if (!breakpoints || base === 'container' && !containerEl) return undefined;
    let breakpoint = false;
    const window = getWindow();
    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map(point => {
      if (typeof point === 'string' && point.indexOf('@') === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }

      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value
      } = points[i];

      if (base === 'window') {
        if (window.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }

    return breakpoint || 'max';
  }

  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };

  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach(item => {
      if (typeof item === 'object') {
        Object.keys(item).forEach(classNames => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === 'string') {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }

  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      $el,
      device,
      support
    } = swiper; // prettier-ignore

    const suffixes = prepareClasses(['initialized', params.direction, {
      'pointer-events': !support.touch
    }, {
      'free-mode': swiper.params.freeMode && params.freeMode.enabled
    }, {
      'autoheight': params.autoHeight
    }, {
      'rtl': rtl
    }, {
      'grid': params.grid && params.grid.rows > 1
    }, {
      'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
    }, {
      'android': device.android
    }, {
      'ios': device.ios
    }, {
      'css-mode': params.cssMode
    }, {
      'centered': params.cssMode && params.centeredSlides
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    $el.addClass([...classNames].join(' '));
    swiper.emitContainerClasses();
  }

  function removeClasses() {
    const swiper = this;
    const {
      $el,
      classNames
    } = swiper;
    $el.removeClass(classNames.join(' '));
    swiper.emitContainerClasses();
  }

  var classes = {
    addClasses,
    removeClasses
  };

  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    const window = getWindow();
    let image;

    function onReady() {
      if (callback) callback();
    }

    const isPicture = $(imageEl).parent('picture')[0];

    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
      if (src) {
        image = new window.Image();
        image.onload = onReady;
        image.onerror = onReady;

        if (sizes) {
          image.sizes = sizes;
        }

        if (srcset) {
          image.srcset = srcset;
        }

        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      // image already loaded...
      onReady();
    }
  }

  function preloadImages() {
    const swiper = this;
    swiper.imagesToLoad = swiper.$el.find('img');

    function onReady() {
      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
      if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) swiper.update();
        swiper.emit('imagesReady');
      }
    }

    for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
      const imageEl = swiper.imagesToLoad[i];
      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
    }
  }

  var images = {
    loadImage,
    preloadImages
  };

  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;

    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }

    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }

    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }

    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }

    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
    }
  }

  var checkOverflow$1 = {
    checkOverflow
  };
  var defaults = {
    init: true,
    direction: 'horizontal',
    touchEventsTarget: 'wrapper',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: 'input, select, option, textarea, button, video, label',
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: undefined,
    breakpointsBase: 'window',
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    // NS
    containerModifierClass: 'swiper-',
    // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };

  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj = {}) {
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];

      if (typeof moduleParams !== 'object' || moduleParams === null) {
        extend(allModulesParams, obj);
        return;
      }

      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
        params[moduleParamName] = {
          auto: true
        };
      }

      if (!(moduleParamName in params && 'enabled' in moduleParams)) {
        extend(allModulesParams, obj);
        return;
      }

      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }

      if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }

      if (!params[moduleParamName]) params[moduleParamName] = {
        enabled: false
      };
      extend(allModulesParams, obj);
    };
  }
  /* eslint no-param-reassign: "off" */


  const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes,
    images
  };
  const extendedDefaults = {};

  class Swiper {
    constructor(...args) {
      let el;
      let params;

      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
        params = args[0];
      } else {
        [el, params] = args;
      }

      if (!params) params = {};
      params = extend({}, params);
      if (el && !params.el) params.el = el;

      if (params.el && $(params.el).length > 1) {
        const swipers = [];
        $(params.el).each(containerEl => {
          const newParams = extend({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      } // Swiper Instance


      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];

      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }

      const allModulesParams = {};
      swiper.modules.forEach(mod => {
        mod({
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      }); // Extend defaults with modules params

      const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params

      swiper.params = extend({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend({}, swiper.params);
      swiper.passedParams = extend({}, params); // add event listeners

      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach(eventName => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }

      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      } // Save Dom lib


      swiper.$ = $; // Extend Swiper

      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: $(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],

        // isDirection
        isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },

        isVertical() {
          return swiper.params.direction === 'vertical';
        },

        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
          const desktop = ['pointerdown', 'pointermove', 'pointerup'];
          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3]
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: now(),
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          isTouchEvent: undefined,
          startMoving: undefined
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit('_swiper'); // Init

      if (swiper.params.init) {
        swiper.init();
      } // Return app instance


      return swiper;
    }

    enable() {
      const swiper = this;
      if (swiper.enabled) return;
      swiper.enabled = true;

      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      swiper.emit('enable');
    }

    disable() {
      const swiper = this;
      if (!swiper.enabled) return;
      swiper.enabled = false;

      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }

      swiper.emit('disable');
    }

    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const cls = swiper.el.className.split(' ').filter(className => {
        return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit('_containerClasses', cls.join(' '));
    }

    getSlideClasses(slideEl) {
      const swiper = this;
      return slideEl.className.split(' ').filter(className => {
        return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(' ');
    }

    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const updates = [];
      swiper.slides.each(slideEl => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit('_slideClass', slideEl, classNames);
      });
      swiper.emit('_slideClasses', updates);
    }

    slidesPerViewDynamic(view = 'current', exact = false) {
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;

      if (params.centeredSlides) {
        let slideSize = slides[activeIndex].swiperSlideSize;
        let breakLoop;

        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }

        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        // eslint-disable-next-line
        if (view === 'current') {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          // previous
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

            if (slideInView) {
              spv += 1;
            }
          }
        }
      }

      return spv;
    }

    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed) return;
      const {
        snapGrid,
        params
      } = swiper; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      let translated;

      if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
        setTranslate();

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (!translated) {
          setTranslate();
        }
      }

      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }

      swiper.emit('update');
    }

    changeDirection(newDirection, needUpdate = true) {
      const swiper = this;
      const currentDirection = swiper.params.direction;

      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }

      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
        return swiper;
      }

      swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.each(slideEl => {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });
      swiper.emit('changeDirection');
      if (needUpdate) swiper.update();
      return swiper;
    }

    mount(el) {
      const swiper = this;
      if (swiper.mounted) return true; // Find el

      const $el = $(el || swiper.params.el);
      el = $el[0];

      if (!el) {
        return false;
      }

      el.swiper = swiper;

      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
      };

      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

          res.children = options => $el.children(options);

          return res;
        }

        return $el.children(getWrapperSelector());
      }; // Find Wrapper


      let $wrapperEl = getWrapper();

      if ($wrapperEl.length === 0 && swiper.params.createElements) {
        const document = getDocument();
        const wrapper = document.createElement('div');
        $wrapperEl = $(wrapper);
        wrapper.className = swiper.params.wrapperClass;
        $el.append(wrapper);
        $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
          $wrapperEl.append(slideEl);
        });
      }

      Object.assign(swiper, {
        $el,
        el,
        $wrapperEl,
        wrapperEl: $wrapperEl[0],
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box'
      });
      return true;
    }

    init(el) {
      const swiper = this;
      if (swiper.initialized) return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false) return swiper;
      swiper.emit('beforeInit'); // Set breakpoint

      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      } // Add Classes


      swiper.addClasses(); // Create loop

      if (swiper.params.loop) {
        swiper.loopCreate();
      } // Update size


      swiper.updateSize(); // Update slides

      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      } // Set Grab Cursor


      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      } // Slide To Initial Slide


      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      } // Attach events


      swiper.attachEvents(); // Init Flag

      swiper.initialized = true; // Emit

      swiper.emit('init');
      swiper.emit('afterInit');
      return swiper;
    }

    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper = this;
      const {
        params,
        $el,
        $wrapperEl,
        slides
      } = swiper;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy'); // Init Flag

      swiper.initialized = false; // Detach events

      swiper.detachEvents(); // Destroy loop

      if (params.loop) {
        swiper.loopDestroy();
      } // Cleanup styles


      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');

        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
        }
      }

      swiper.emit('destroy'); // Detach emitter events

      Object.keys(swiper.eventsListeners).forEach(eventName => {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        deleteProps(swiper);
      }

      swiper.destroyed = true;
      return null;
    }

    static extendDefaults(newDefaults) {
      extend(extendedDefaults, newDefaults);
    }

    static get extendedDefaults() {
      return extendedDefaults;
    }

    static get defaults() {
      return defaults;
    }

    static installModule(mod) {
      if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
      const modules = Swiper.prototype.__modules__;

      if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }

    static use(module) {
      if (Array.isArray(module)) {
        module.forEach(m => Swiper.installModule(m));
        return Swiper;
      }

      Swiper.installModule(module);
      return Swiper;
    }

  }

  Object.keys(prototypes).forEach(prototypeGroup => {
    Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);

  function Virtual({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: true,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    });
    let cssModeTimeout;
    swiper.virtual = {
      cache: {},
      from: undefined,
      to: undefined,
      slides: [],
      offset: 0,
      slidesGrid: []
    };

    function renderSlide(slide, index) {
      const params = swiper.params.virtual;

      if (params.cache && swiper.virtual.cache[index]) {
        return swiper.virtual.cache[index];
      }

      const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
      if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
      if (params.cache) swiper.virtual.cache[index] = $slideEl;
      return $slideEl;
    }

    function update(force) {
      const {
        slidesPerView,
        slidesPerGroup,
        centeredSlides
      } = swiper.params;
      const {
        addSlidesBefore,
        addSlidesAfter
      } = swiper.params.virtual;
      const {
        from: previousFrom,
        to: previousTo,
        slides,
        slidesGrid: previousSlidesGrid,
        offset: previousOffset
      } = swiper.virtual;

      if (!swiper.params.cssMode) {
        swiper.updateActiveIndex();
      }

      const activeIndex = swiper.activeIndex || 0;
      let offsetProp;
      if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
      let slidesAfter;
      let slidesBefore;

      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
        slidesBefore = slidesPerGroup + addSlidesBefore;
      }

      const from = Math.max((activeIndex || 0) - slidesBefore, 0);
      const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
      const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
      Object.assign(swiper.virtual, {
        from,
        to,
        offset,
        slidesGrid: swiper.slidesGrid
      });

      function onRendered() {
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        if (swiper.lazy && swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      }

      if (previousFrom === from && previousTo === to && !force) {
        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
          swiper.slides.css(offsetProp, `${offset}px`);
        }

        swiper.updateProgress();
        return;
      }

      if (swiper.params.virtual.renderExternal) {
        swiper.params.virtual.renderExternal.call(swiper, {
          offset,
          from,
          to,
          slides: function getSlides() {
            const slidesToRender = [];

            for (let i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }

            return slidesToRender;
          }()
        });

        if (swiper.params.virtual.renderExternalUpdate) {
          onRendered();
        }

        return;
      }

      const prependIndexes = [];
      const appendIndexes = [];

      if (force) {
        swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
      } else {
        for (let i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
          }
        }
      }

      for (let i = 0; i < slides.length; i += 1) {
        if (i >= from && i <= to) {
          if (typeof previousTo === 'undefined' || force) {
            appendIndexes.push(i);
          } else {
            if (i > previousTo) appendIndexes.push(i);
            if (i < previousFrom) prependIndexes.push(i);
          }
        }
      }

      appendIndexes.forEach(index => {
        swiper.$wrapperEl.append(renderSlide(slides[index], index));
      });
      prependIndexes.sort((a, b) => b - a).forEach(index => {
        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
      });
      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
      onRendered();
    }

    function appendSlide(slides) {
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) swiper.virtual.slides.push(slides[i]);
        }
      } else {
        swiper.virtual.slides.push(slides);
      }

      update(true);
    }

    function prependSlide(slides) {
      const activeIndex = swiper.activeIndex;
      let newActiveIndex = activeIndex + 1;
      let numberOfNewSlides = 1;

      if (Array.isArray(slides)) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
        numberOfNewSlides = slides.length;
      } else {
        swiper.virtual.slides.unshift(slides);
      }

      if (swiper.params.virtual.cache) {
        const cache = swiper.virtual.cache;
        const newCache = {};
        Object.keys(cache).forEach(cachedIndex => {
          const $cachedEl = cache[cachedIndex];
          const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

          if (cachedElIndex) {
            $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
          }

          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
        });
        swiper.virtual.cache = newCache;
      }

      update(true);
      swiper.slideTo(newActiveIndex, 0);
    }

    function removeSlide(slidesIndexes) {
      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
      let activeIndex = swiper.activeIndex;

      if (Array.isArray(slidesIndexes)) {
        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
          swiper.virtual.slides.splice(slidesIndexes[i], 1);

          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes[i]];
          }

          if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
      } else {
        swiper.virtual.slides.splice(slidesIndexes, 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes];
        }

        if (slidesIndexes < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }

      update(true);
      swiper.slideTo(activeIndex, 0);
    }

    function removeAllSlides() {
      swiper.virtual.slides = [];

      if (swiper.params.virtual.cache) {
        swiper.virtual.cache = {};
      }

      update(true);
      swiper.slideTo(0, 0);
    }

    on('beforeInit', () => {
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.slides = swiper.params.virtual.slides;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;

      if (!swiper.params.initialSlide) {
        update();
      }
    });
    on('setTranslate', () => {
      if (!swiper.params.virtual.enabled) return;

      if (swiper.params.cssMode && !swiper._immediateVirtual) {
        clearTimeout(cssModeTimeout);
        cssModeTimeout = setTimeout(() => {
          update();
        }, 100);
      } else {
        update();
      }
    });
    on('init update resize', () => {
      if (!swiper.params.virtual.enabled) return;

      if (swiper.params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
      }
    });
    Object.assign(swiper.virtual, {
      appendSlide,
      prependSlide,
      removeSlide,
      removeAllSlides,
      update
    });
  }
  /* eslint-disable consistent-return */


  function Keyboard({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const document = getDocument();
    const window = getWindow();
    swiper.keyboard = {
      enabled: false
    };
    extendParams({
      keyboard: {
        enabled: false,
        onlyInViewport: true,
        pageUpDown: true
      }
    });

    function handle(event) {
      if (!swiper.enabled) return;
      const {
        rtlTranslate: rtl
      } = swiper;
      let e = event;
      if (e.originalEvent) e = e.originalEvent; // jquery fix

      const kc = e.keyCode || e.charCode;
      const pageUpDown = swiper.params.keyboard.pageUpDown;
      const isPageUp = pageUpDown && kc === 33;
      const isPageDown = pageUpDown && kc === 34;
      const isArrowLeft = kc === 37;
      const isArrowRight = kc === 39;
      const isArrowUp = kc === 38;
      const isArrowDown = kc === 40; // Directions locks

      if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
        return false;
      }

      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
        return false;
      }

      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return undefined;
      }

      if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
        return undefined;
      }

      if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
        let inView = false; // Check that swiper should be inside of visible area of window

        if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
          return undefined;
        }

        const $el = swiper.$el;
        const swiperWidth = $el[0].clientWidth;
        const swiperHeight = $el[0].clientHeight;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const swiperOffset = swiper.$el.offset();
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];

        for (let i = 0; i < swiperCoord.length; i += 1) {
          const point = swiperCoord[i];

          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

            inView = true;
          }
        }

        if (!inView) return undefined;
      }

      if (swiper.isHorizontal()) {
        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
          if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        }

        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
      } else {
        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
          if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        }

        if (isPageDown || isArrowDown) swiper.slideNext();
        if (isPageUp || isArrowUp) swiper.slidePrev();
      }

      emit('keyPress', kc);
      return undefined;
    }

    function enable() {
      if (swiper.keyboard.enabled) return;
      $(document).on('keydown', handle);
      swiper.keyboard.enabled = true;
    }

    function disable() {
      if (!swiper.keyboard.enabled) return;
      $(document).off('keydown', handle);
      swiper.keyboard.enabled = false;
    }

    on('init', () => {
      if (swiper.params.keyboard.enabled) {
        enable();
      }
    });
    on('destroy', () => {
      if (swiper.keyboard.enabled) {
        disable();
      }
    });
    Object.assign(swiper.keyboard, {
      enable,
      disable
    });
  }
  /* eslint-disable consistent-return */


  function Mousewheel({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const window = getWindow();
    extendParams({
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarget: 'container',
        thresholdDelta: null,
        thresholdTime: null
      }
    });
    swiper.mousewheel = {
      enabled: false
    };
    let timeout;
    let lastScrollTime = now();
    let lastEventBeforeSnap;
    const recentWheelEvents = [];

    function normalize(e) {
      // Reasonable defaults
      const PIXEL_STEP = 10;
      const LINE_HEIGHT = 40;
      const PAGE_HEIGHT = 800;
      let sX = 0;
      let sY = 0; // spinX, spinY

      let pX = 0;
      let pY = 0; // pixelX, pixelY
      // Legacy

      if ('detail' in e) {
        sY = e.detail;
      }

      if ('wheelDelta' in e) {
        sY = -e.wheelDelta / 120;
      }

      if ('wheelDeltaY' in e) {
        sY = -e.wheelDeltaY / 120;
      }

      if ('wheelDeltaX' in e) {
        sX = -e.wheelDeltaX / 120;
      } // side scrolling on FF with DOMMouseScroll


      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }

      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;

      if ('deltaY' in e) {
        pY = e.deltaY;
      }

      if ('deltaX' in e) {
        pX = e.deltaX;
      }

      if (e.shiftKey && !pX) {
        // if user scrolls with shift he wants horizontal scroll
        pX = pY;
        pY = 0;
      }

      if ((pX || pY) && e.deltaMode) {
        if (e.deltaMode === 1) {
          // delta in LINE units
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          // delta in PAGE units
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      } // Fall-back if spin cannot be determined


      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }

      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }

      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    }

    function handleMouseEnter() {
      if (!swiper.enabled) return;
      swiper.mouseEntered = true;
    }

    function handleMouseLeave() {
      if (!swiper.enabled) return;
      swiper.mouseEntered = false;
    }

    function animateSlider(newEvent) {
      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
        // Prevent if delta of wheel scroll delta is below configured threshold
        return false;
      }

      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
        // Prevent if time between scrolls is below configured threshold
        return false;
      } // If the movement is NOT big enough and
      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
      //   Don't go any further (avoid insignificant scroll movement).


      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
        // Return false as a default
        return true;
      } // If user is scrolling towards the end:
      //   If the slider hasn't hit the latest slide or
      //   if the slider is a loop and
      //   if the slider isn't moving right now:
      //     Go to next slide and
      //     emit a scroll event.
      // Else (the user is scrolling towards the beginning) and
      // if the slider hasn't hit the first slide or
      // if the slider is a loop and
      // if the slider isn't moving right now:
      //   Go to prev slide and
      //   emit a scroll event.


      if (newEvent.direction < 0) {
        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
          swiper.slideNext();
          emit('scroll', newEvent.raw);
        }
      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
        swiper.slidePrev();
        emit('scroll', newEvent.raw);
      } // If you got here is because an animation has been triggered so store the current time


      lastScrollTime = new window.Date().getTime(); // Return false as a default

      return false;
    }

    function releaseScroll(newEvent) {
      const params = swiper.params.mousewheel;

      if (newEvent.direction < 0) {
        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }

      return false;
    }

    function handle(event) {
      let e = event;
      let disableParentSwiper = true;
      if (!swiper.enabled) return;
      const params = swiper.params.mousewheel;

      if (swiper.params.cssMode) {
        e.preventDefault();
      }

      let target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarget !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarget);
      }

      if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
      if (e.originalEvent) e = e.originalEvent; // jquery fix

      let delta = 0;
      const rtlFactor = swiper.rtlTranslate ? -1 : 1;
      const data = normalize(e);

      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }

      if (delta === 0) return true;
      if (params.invert) delta = -delta; // Get the scroll positions

      let positions = swiper.getTranslate() + delta * params.sensitivity;
      if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
      if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
      //     the disableParentSwiper will be true.
      // When loop is false:
      //     if the scroll positions is not on edge,
      //     then the disableParentSwiper will be true.
      //     if the scroll on edge positions,
      //     then the disableParentSwiper will be false.

      disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
      if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
        // Register the new event in a variable which stores the relevant data
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event
        }; // Keep the most recent events

        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift(); // only store the last N events
        }

        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
        recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
        //   If direction has changed or
        //   if the scroll is quicker than the previous one:
        //     Animate the slider.
        // Else (this is the first time the wheel is moved):
        //     Animate the slider.

        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
            animateSlider(newEvent);
          }
        } else {
          animateSlider(newEvent);
        } // If it's time to release the scroll:
        //   Return now so you don't hit the preventDefault.


        if (releaseScroll(newEvent)) {
          return true;
        }
      } else {
        // Freemode or scrollContainer:
        // If we recently snapped after a momentum scroll, then ignore wheel events
        // to give time for the deceleration to finish. Stop ignoring after 500 msecs
        // or if it's a new scroll (larger delta or inverse sign as last event before
        // an end-of-momentum snap).
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta)
        };
        const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;

        if (!ignoreWheelEvents) {
          lastEventBeforeSnap = undefined;

          if (swiper.params.loop) {
            swiper.loopFix();
          }

          let position = swiper.getTranslate() + delta * params.sensitivity;
          const wasBeginning = swiper.isBeginning;
          const wasEnd = swiper.isEnd;
          if (position >= swiper.minTranslate()) position = swiper.minTranslate();
          if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
          swiper.setTransition(0);
          swiper.setTranslate(position);
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();

          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
            swiper.updateSlidesClasses();
          }

          if (swiper.params.freeMode.sticky) {
            // When wheel scrolling starts with sticky (aka snap) enabled, then detect
            // the end of a momentum scroll by storing recent (N=15?) wheel events.
            // 1. do all N events have decreasing or same (absolute value) delta?
            // 2. did all N events arrive in the last M (M=500?) msecs?
            // 3. does the earliest event have an (absolute value) delta that's
            //    at least P (P=1?) larger than the most recent event's delta?
            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
            // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
            // Snap immediately and ignore remaining wheel events in this scroll.
            // See comment above for "remaining wheel events in this scroll" determination.
            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
            clearTimeout(timeout);
            timeout = undefined;

            if (recentWheelEvents.length >= 15) {
              recentWheelEvents.shift(); // only store the last N events
            }

            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
            const firstEvent = recentWheelEvents[0];
            recentWheelEvents.push(newEvent);

            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
              recentWheelEvents.splice(0);
            } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
              // We're at the end of the deceleration of a momentum scroll, so there's no need
              // to wait for more events. Snap ASAP on the next tick.
              // Also, because there's some remaining momentum we'll bias the snap in the
              // direction of the ongoing scroll because it's better UX for the scroll to snap
              // in the same direction as the scroll instead of reversing to snap.  Therefore,
              // if it's already scrolled more than 20% in the current direction, keep going.
              const snapToThreshold = delta > 0 ? 0.8 : 0.2;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              timeout = nextTick(() => {
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 0); // no delay; move on next tick
            }

            if (!timeout) {
              // if we get here, then we haven't detected the end of a momentum scroll, so
              // we'll consider a scroll "complete" when there haven't been any wheel events
              // for 500ms.
              timeout = nextTick(() => {
                const snapToThreshold = 0.5;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 500);
            }
          } // Emit event


          if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
        }
      }

      if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      return false;
    }

    function events(method) {
      let target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarget !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarget);
      }

      target[method]('mouseenter', handleMouseEnter);
      target[method]('mouseleave', handleMouseLeave);
      target[method]('wheel', handle);
    }

    function enable() {
      if (swiper.params.cssMode) {
        swiper.wrapperEl.removeEventListener('wheel', handle);
        return true;
      }

      if (swiper.mousewheel.enabled) return false;
      events('on');
      swiper.mousewheel.enabled = true;
      return true;
    }

    function disable() {
      if (swiper.params.cssMode) {
        swiper.wrapperEl.addEventListener(event, handle);
        return true;
      }

      if (!swiper.mousewheel.enabled) return false;
      events('off');
      swiper.mousewheel.enabled = false;
      return true;
    }

    on('init', () => {
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        disable();
      }

      if (swiper.params.mousewheel.enabled) enable();
    });
    on('destroy', () => {
      if (swiper.params.cssMode) {
        enable();
      }

      if (swiper.mousewheel.enabled) disable();
    });
    Object.assign(swiper.mousewheel, {
      enable,
      disable
    });
  }

  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    const document = getDocument();

    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach(key => {
        if (!params[key] && params.auto === true) {
          let element = swiper.$el.children(`.${checkProps[key]}`)[0];

          if (!element) {
            element = document.createElement('div');
            element.className = checkProps[key];
            swiper.$el.append(element);
          }

          params[key] = element;
          originalParams[key] = element;
        }
      });
    }

    return params;
  }

  function Navigation({
    swiper,
    extendParams,
    on,
    emit
  }) {
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock'
      }
    });
    swiper.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    };

    function getEl(el) {
      let $el;

      if (el) {
        $el = $(el);

        if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
          $el = swiper.$el.find(el);
        }
      }

      return $el;
    }

    function toggleEl($el, disabled) {
      const params = swiper.params.navigation;

      if ($el && $el.length > 0) {
        $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
        if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }
    }

    function update() {
      // Update Navigation Buttons
      if (swiper.params.loop) return;
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      toggleEl($prevEl, swiper.isBeginning);
      toggleEl($nextEl, swiper.isEnd);
    }

    function onPrevClick(e) {
      e.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop) return;
      swiper.slidePrev();
    }

    function onNextClick(e) {
      e.preventDefault();
      if (swiper.isEnd && !swiper.params.loop) return;
      swiper.slideNext();
    }

    function init() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: 'swiper-button-next',
        prevEl: 'swiper-button-prev'
      });
      if (!(params.nextEl || params.prevEl)) return;
      const $nextEl = getEl(params.nextEl);
      const $prevEl = getEl(params.prevEl);

      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on('click', onNextClick);
      }

      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on('click', onPrevClick);
      }

      Object.assign(swiper.navigation, {
        $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });

      if (!swiper.enabled) {
        if ($nextEl) $nextEl.addClass(params.lockClass);
        if ($prevEl) $prevEl.addClass(params.lockClass);
      }
    }

    function destroy() {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;

      if ($nextEl && $nextEl.length) {
        $nextEl.off('click', onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }

      if ($prevEl && $prevEl.length) {
        $prevEl.off('click', onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    }

    on('init', () => {
      init();
      update();
    });
    on('toEdge fromEdge lock unlock', () => {
      update();
    });
    on('destroy', () => {
      destroy();
    });
    on('enable disable', () => {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;

      if ($nextEl) {
        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }

      if ($prevEl) {
        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }
    });
    on('click', (_s, e) => {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      const targetEl = e.target;

      if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        let isHidden;

        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }

        if (isHidden === true) {
          emit('navigationShow');
        } else {
          emit('navigationHide');
        }

        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }

        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    });
    Object.assign(swiper.navigation, {
      update,
      init,
      destroy
    });
  }

  function classesToSelector(classes = '') {
    return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
    .replace(/ /g, '.')}`;
  }

  function Pagination({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const pfx = 'swiper-pagination';
    extendParams({
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets',
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: number => number,
        formatFractionTotal: number => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`
      }
    });
    swiper.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;

    function isPaginationDisabled() {
      return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
    }

    function setSideBullets($bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper.params.pagination;
      $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
    }

    function update() {
      // Render || Update Pagination bullets/items
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el; // Current/Total

      let current;
      const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
          current -= slidesLength - swiper.loopedSlides * 2;
        }

        if (current > total - 1) current -= total;
        if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      } // Types


      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;

        if (params.dynamicBullets) {
          bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
          $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
            dynamicBulletIndex += current - swiper.previousIndex;

            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }

          firstIndex = current - dynamicBulletIndex;
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }

        bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

        if ($el.length > 1) {
          bullets.each(bullet => {
            const $bullet = $(bullet);
            const bulletIndex = $bullet.index();

            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }

            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(`${params.bulletActiveClass}-main`);
              }

              if (bulletIndex === firstIndex) {
                setSideBullets($bullet, 'prev');
              }

              if (bulletIndex === lastIndex) {
                setSideBullets($bullet, 'next');
              }
            }
          });
        } else {
          const $bullet = bullets.eq(current);
          const bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);

          if (params.dynamicBullets) {
            const $firstDisplayedBullet = bullets.eq(firstIndex);
            const $lastDisplayedBullet = bullets.eq(lastIndex);

            for (let i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
            }

            if (swiper.params.loop) {
              if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                  bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                }

                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            } else {
              setSideBullets($firstDisplayedBullet, 'prev');
              setSideBullets($lastDisplayedBullet, 'next');
            }
          }
        }

        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? 'right' : 'left';
          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
        }
      }

      if (params.type === 'fraction') {
        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
      }

      if (params.type === 'progressbar') {
        let progressbarDirection;

        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }

        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;

        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }

        $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
      }

      if (params.type === 'custom' && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        emit('paginationRender', $el[0]);
      } else {
        emit('paginationUpdate', $el[0]);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }

    function render() {
      // Render Container
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el;
      let paginationHTML = '';

      if (params.type === 'bullets') {
        let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }

        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }

        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
      }

      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
        }

        $el.html(paginationHTML);
      }

      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }

        $el.html(paginationHTML);
      }

      if (params.type !== 'custom') {
        emit('paginationRender', swiper.pagination.$el[0]);
      }
    }

    function init() {
      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
        el: 'swiper-pagination'
      });
      const params = swiper.params.pagination;
      if (!params.el) return;
      let $el = $(params.el);
      if ($el.length === 0) return;

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
        $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

        if ($el.length > 1) {
          $el = $el.filter(el => {
            if ($(el).parents('.swiper')[0] !== swiper.el) return false;
            return true;
          });
        }
      }

      if (params.type === 'bullets' && params.clickable) {
        $el.addClass(params.clickableClass);
      }

      $el.addClass(params.modifierClass + params.type);
      $el.addClass(params.modifierClass + swiper.params.direction);

      if (params.type === 'bullets' && params.dynamicBullets) {
        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;

        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }

      if (params.type === 'progressbar' && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }

      if (params.clickable) {
        $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
          e.preventDefault();
          let index = $(this).index() * swiper.params.slidesPerGroup;
          if (swiper.params.loop) index += swiper.loopedSlides;
          swiper.slideTo(index);
        });
      }

      Object.assign(swiper.pagination, {
        $el,
        el: $el[0]
      });

      if (!swiper.enabled) {
        $el.addClass(params.lockClass);
      }
    }

    function destroy() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const $el = swiper.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      $el.removeClass(params.modifierClass + swiper.params.direction);
      if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

      if (params.clickable) {
        $el.off('click', classesToSelector(params.bulletClass));
      }
    }

    on('init', () => {
      init();
      render();
      update();
    });
    on('activeIndexChange', () => {
      if (swiper.params.loop) {
        update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        update();
      }
    });
    on('snapIndexChange', () => {
      if (!swiper.params.loop) {
        update();
      }
    });
    on('slidesLengthChange', () => {
      if (swiper.params.loop) {
        render();
        update();
      }
    });
    on('snapGridLengthChange', () => {
      if (!swiper.params.loop) {
        render();
        update();
      }
    });
    on('destroy', () => {
      destroy();
    });
    on('enable disable', () => {
      const {
        $el
      } = swiper.pagination;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
      }
    });
    on('lock unlock', () => {
      update();
    });
    on('click', (_s, e) => {
      const targetEl = e.target;
      const {
        $el
      } = swiper.pagination;

      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

        if (isHidden === true) {
          emit('paginationShow');
        } else {
          emit('paginationHide');
        }

        $el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    });
    Object.assign(swiper.pagination, {
      render,
      update,
      init,
      destroy
    });
  }

  function Scrollbar({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const document = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag'
      }
    });
    swiper.scrollbar = {
      el: null,
      dragEl: null,
      $el: null,
      $dragEl: null
    };

    function setTranslate() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const {
        scrollbar,
        rtlTranslate: rtl,
        progress
      } = swiper;
      const {
        $dragEl,
        $el
      } = scrollbar;
      const params = swiper.params.scrollbar;
      let newSize = dragSize;
      let newPos = (trackSize - dragSize) * progress;

      if (rtl) {
        newPos = -newPos;

        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }

      if (swiper.isHorizontal()) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
        $dragEl[0].style.width = `${newSize}px`;
      } else {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
        $dragEl[0].style.height = `${newSize}px`;
      }

      if (params.hide) {
        clearTimeout(timeout);
        $el[0].style.opacity = 1;
        timeout = setTimeout(() => {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1000);
      }
    }

    function setTransition(duration) {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      swiper.scrollbar.$dragEl.transition(duration);
    }

    function updateSize() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const {
        scrollbar
      } = swiper;
      const {
        $dragEl,
        $el
      } = scrollbar;
      $dragEl[0].style.width = '';
      $dragEl[0].style.height = '';
      trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }

      if (swiper.isHorizontal()) {
        $dragEl[0].style.width = `${dragSize}px`;
      } else {
        $dragEl[0].style.height = `${dragSize}px`;
      }

      if (divider >= 1) {
        $el[0].style.display = 'none';
      } else {
        $el[0].style.display = '';
      }

      if (swiper.params.scrollbar.hide) {
        $el[0].style.opacity = 0;
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
      }
    }

    function getPointerPosition(e) {
      if (swiper.isHorizontal()) {
        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
      }

      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
    }

    function setDragPosition(e) {
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper;
      const {
        $el
      } = scrollbar;
      let positionRatio;
      positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);

      if (rtl) {
        positionRatio = 1 - positionRatio;
      }

      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    function onDragStart(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        $wrapperEl
      } = swiper;
      const {
        $el,
        $dragEl
      } = scrollbar;
      isTouched = true;
      dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
      e.preventDefault();
      e.stopPropagation();
      $wrapperEl.transition(100);
      $dragEl.transition(100);
      setDragPosition(e);
      clearTimeout(dragTimeout);
      $el.transition(0);

      if (params.hide) {
        $el.css('opacity', 1);
      }

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', 'none');
      }

      emit('scrollbarDragStart', e);
    }

    function onDragMove(e) {
      const {
        scrollbar,
        $wrapperEl
      } = swiper;
      const {
        $el,
        $dragEl
      } = scrollbar;
      if (!isTouched) return;
      if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      setDragPosition(e);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      emit('scrollbarDragMove', e);
    }

    function onDragEnd(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        $wrapperEl
      } = swiper;
      const {
        $el
      } = scrollbar;
      if (!isTouched) return;
      isTouched = false;

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', '');
        $wrapperEl.transition('');
      }

      if (params.hide) {
        clearTimeout(dragTimeout);
        dragTimeout = nextTick(() => {
          $el.css('opacity', 0);
          $el.transition(400);
        }, 1000);
      }

      emit('scrollbarDragEnd', e);

      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    }

    function events(method) {
      const {
        scrollbar,
        touchEventsTouch,
        touchEventsDesktop,
        params,
        support
      } = swiper;
      const $el = scrollbar.$el;
      const target = $el[0];
      const activeListener = support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      const passiveListener = support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (!target) return;
      const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

      if (!support.touch) {
        target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
        document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
        document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
      } else {
        target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
        target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
        target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
      }
    }

    function enableDraggable() {
      if (!swiper.params.scrollbar.el) return;
      events('on');
    }

    function disableDraggable() {
      if (!swiper.params.scrollbar.el) return;
      events('off');
    }

    function init() {
      const {
        scrollbar,
        $el: $swiperEl
      } = swiper;
      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
        el: 'swiper-scrollbar'
      });
      const params = swiper.params.scrollbar;
      if (!params.el) return;
      let $el = $(params.el);

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }

      let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

      if ($dragEl.length === 0) {
        $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
        $el.append($dragEl);
      }

      Object.assign(scrollbar, {
        $el,
        el: $el[0],
        $dragEl,
        dragEl: $dragEl[0]
      });

      if (params.draggable) {
        enableDraggable();
      }

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
      }
    }

    function destroy() {
      disableDraggable();
    }

    on('init', () => {
      init();
      updateSize();
      setTranslate();
    });
    on('update resize observerUpdate lock unlock', () => {
      updateSize();
    });
    on('setTranslate', () => {
      setTranslate();
    });
    on('setTransition', (_s, duration) => {
      setTransition(duration);
    });
    on('enable disable', () => {
      const {
        $el
      } = swiper.scrollbar;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
      }
    });
    on('destroy', () => {
      destroy();
    });
    Object.assign(swiper.scrollbar, {
      updateSize,
      setTranslate,
      init,
      destroy
    });
  }

  function Parallax({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      parallax: {
        enabled: false
      }
    });

    const setTransform = (el, progress) => {
      const {
        rtl
      } = swiper;
      const $el = $(el);
      const rtlFactor = rtl ? -1 : 1;
      const p = $el.attr('data-swiper-parallax') || '0';
      let x = $el.attr('data-swiper-parallax-x');
      let y = $el.attr('data-swiper-parallax-y');
      const scale = $el.attr('data-swiper-parallax-scale');
      const opacity = $el.attr('data-swiper-parallax-opacity');

      if (x || y) {
        x = x || '0';
        y = y || '0';
      } else if (swiper.isHorizontal()) {
        x = p;
        y = '0';
      } else {
        y = p;
        x = '0';
      }

      if (x.indexOf('%') >= 0) {
        x = `${parseInt(x, 10) * progress * rtlFactor}%`;
      } else {
        x = `${x * progress * rtlFactor}px`;
      }

      if (y.indexOf('%') >= 0) {
        y = `${parseInt(y, 10) * progress}%`;
      } else {
        y = `${y * progress}px`;
      }

      if (typeof opacity !== 'undefined' && opacity !== null) {
        const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
        $el[0].style.opacity = currentOpacity;
      }

      if (typeof scale === 'undefined' || scale === null) {
        $el.transform(`translate3d(${x}, ${y}, 0px)`);
      } else {
        const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
        $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
      }
    };

    const setTranslate = () => {
      const {
        $el,
        slides,
        progress,
        snapGrid
      } = swiper;
      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
        setTransform(el, progress);
      });
      slides.each((slideEl, slideIndex) => {
        let slideProgress = slideEl.progress;

        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
        }

        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
          setTransform(el, slideProgress);
        });
      });
    };

    const setTransition = (duration = swiper.params.speed) => {
      const {
        $el
      } = swiper;
      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
        const $parallaxEl = $(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
    };

    on('beforeInit', () => {
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    });
    on('init', () => {
      if (!swiper.params.parallax.enabled) return;
      setTranslate();
    });
    on('setTranslate', () => {
      if (!swiper.params.parallax.enabled) return;
      setTranslate();
    });
    on('setTransition', (_swiper, duration) => {
      if (!swiper.params.parallax.enabled) return;
      setTransition(duration);
    });
  }

  function Zoom({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const window = getWindow();
    extendParams({
      zoom: {
        enabled: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: 'swiper-zoom-container',
        zoomedSlideClass: 'swiper-slide-zoomed'
      }
    });
    swiper.zoom = {
      enabled: false
    };
    let currentScale = 1;
    let isScaling = false;
    let gesturesEnabled;
    let fakeGestureTouched;
    let fakeGestureMoved;
    const gesture = {
      $slideEl: undefined,
      slideWidth: undefined,
      slideHeight: undefined,
      $imageEl: undefined,
      $imageWrapEl: undefined,
      maxRatio: 3
    };
    const image = {
      isTouched: undefined,
      isMoved: undefined,
      currentX: undefined,
      currentY: undefined,
      minX: undefined,
      minY: undefined,
      maxX: undefined,
      maxY: undefined,
      width: undefined,
      height: undefined,
      startX: undefined,
      startY: undefined,
      touchesStart: {},
      touchesCurrent: {}
    };
    const velocity = {
      x: undefined,
      y: undefined,
      prevPositionX: undefined,
      prevPositionY: undefined,
      prevTime: undefined
    };
    let scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get() {
        return scale;
      },

      set(value) {
        if (scale !== value) {
          const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
          const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
          emit('zoomChange', value, imageEl, slideEl);
        }

        scale = value;
      }

    });

    function getDistanceBetweenTouches(e) {
      if (e.targetTouches.length < 2) return 1;
      const x1 = e.targetTouches[0].pageX;
      const y1 = e.targetTouches[0].pageY;
      const x2 = e.targetTouches[1].pageX;
      const y2 = e.targetTouches[1].pageY;
      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      return distance;
    } // Events


    function onGestureStart(e) {
      const support = swiper.support;
      const params = swiper.params.zoom;
      fakeGestureTouched = false;
      fakeGestureMoved = false;

      if (!support.gestures) {
        if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
          return;
        }

        fakeGestureTouched = true;
        gesture.scaleStart = getDistanceBetweenTouches(e);
      }

      if (!gesture.$slideEl || !gesture.$slideEl.length) {
        gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
        if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

        if (gesture.$imageWrapEl.length === 0) {
          gesture.$imageEl = undefined;
          return;
        }
      }

      if (gesture.$imageEl) {
        gesture.$imageEl.transition(0);
      }

      isScaling = true;
    }

    function onGestureChange(e) {
      const support = swiper.support;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;

      if (!support.gestures) {
        if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
          return;
        }

        fakeGestureMoved = true;
        gesture.scaleMove = getDistanceBetweenTouches(e);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        if (e.type === 'gesturechange') onGestureStart(e);
        return;
      }

      if (support.gestures) {
        zoom.scale = e.scale * currentScale;
      } else {
        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
      }

      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
      }

      if (zoom.scale < params.minRatio) {
        zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
      }

      gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    }

    function onGestureEnd(e) {
      const device = swiper.device;
      const support = swiper.support;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;

      if (!support.gestures) {
        if (!fakeGestureTouched || !fakeGestureMoved) {
          return;
        }

        if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
          return;
        }

        fakeGestureTouched = false;
        fakeGestureMoved = false;
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      currentScale = zoom.scale;
      isScaling = false;
      if (zoom.scale === 1) gesture.$slideEl = undefined;
    }

    function onTouchStart(e) {
      const device = swiper.device;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      if (image.isTouched) return;
      if (device.android && e.cancelable) e.preventDefault();
      image.isTouched = true;
      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }

    function onTouchMove(e) {
      const zoom = swiper.zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      swiper.allowClick = false;
      if (!image.isTouched || !gesture.$slideEl) return;

      if (!image.isMoved) {
        image.width = gesture.$imageEl[0].offsetWidth;
        image.height = gesture.$imageEl[0].offsetHeight;
        image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
        image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
        gesture.$imageWrapEl.transition(0);
      } // Define if we need image drag


      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (!image.isMoved && !isScaling) {
        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
          image.isTouched = false;
          return;
        }

        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
          image.isTouched = false;
          return;
        }
      }

      if (e.cancelable) {
        e.preventDefault();
      }

      e.stopPropagation();
      image.isMoved = true;
      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

      if (image.currentX < image.minX) {
        image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
      }

      if (image.currentX > image.maxX) {
        image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
      }

      if (image.currentY < image.minY) {
        image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
      }

      if (image.currentY > image.maxY) {
        image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
      } // Velocity


      if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
      if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
      if (!velocity.prevTime) velocity.prevTime = Date.now();
      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();
      gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
    }

    function onTouchEnd() {
      const zoom = swiper.zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }

      image.isTouched = false;
      image.isMoved = false;
      let momentumDurationX = 300;
      let momentumDurationY = 300;
      const momentumDistanceX = velocity.x * momentumDurationX;
      const newPositionX = image.currentX + momentumDistanceX;
      const momentumDistanceY = velocity.y * momentumDurationY;
      const newPositionY = image.currentY + momentumDistanceY; // Fix duration

      if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
      image.currentX = newPositionX;
      image.currentY = newPositionY; // Define if we need image drag

      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
      gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
    }

    function onTransitionEnd() {
      const zoom = swiper.zoom;

      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
        if (gesture.$imageEl) {
          gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
        }

        if (gesture.$imageWrapEl) {
          gesture.$imageWrapEl.transform('translate3d(0,0,0)');
        }

        zoom.scale = 1;
        currentScale = 1;
        gesture.$slideEl = undefined;
        gesture.$imageEl = undefined;
        gesture.$imageWrapEl = undefined;
      }
    }

    function zoomIn(e) {
      const zoom = swiper.zoom;
      const params = swiper.params.zoom;

      if (!gesture.$slideEl) {
        if (e && e.target) {
          gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
        }

        if (!gesture.$slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
          } else {
            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          }
        }

        gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

      if (swiper.params.cssMode) {
        swiper.wrapperEl.style.overflow = 'hidden';
        swiper.wrapperEl.style.touchAction = 'none';
      }

      gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
      let touchX;
      let touchY;
      let offsetX;
      let offsetY;
      let diffX;
      let diffY;
      let translateX;
      let translateY;
      let imageWidth;
      let imageHeight;
      let scaledWidth;
      let scaledHeight;
      let translateMinX;
      let translateMinY;
      let translateMaxX;
      let translateMaxY;
      let slideWidth;
      let slideHeight;

      if (typeof image.touchesStart.x === 'undefined' && e) {
        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }

      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (e) {
        slideWidth = gesture.$slideEl[0].offsetWidth;
        slideHeight = gesture.$slideEl[0].offsetHeight;
        offsetX = gesture.$slideEl.offset().left + window.scrollX;
        offsetY = gesture.$slideEl.offset().top + window.scrollY;
        diffX = offsetX + slideWidth / 2 - touchX;
        diffY = offsetY + slideHeight / 2 - touchY;
        imageWidth = gesture.$imageEl[0].offsetWidth;
        imageHeight = gesture.$imageEl[0].offsetHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;
        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;
        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;

        if (translateX < translateMinX) {
          translateX = translateMinX;
        }

        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }

        if (translateY < translateMinY) {
          translateY = translateMinY;
        }

        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }

      gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
      gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    }

    function zoomOut() {
      const zoom = swiper.zoom;
      const params = swiper.params.zoom;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

      if (swiper.params.cssMode) {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.style.touchAction = '';
      }

      zoom.scale = 1;
      currentScale = 1;
      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
      gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
      gesture.$slideEl = undefined;
    } // Toggle Zoom


    function zoomToggle(e) {
      const zoom = swiper.zoom;

      if (zoom.scale && zoom.scale !== 1) {
        // Zoom Out
        zoomOut();
      } else {
        // Zoom In
        zoomIn(e);
      }
    }

    function getListeners() {
      const support = swiper.support;
      const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      const activeListenerWithCapture = support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      return {
        passiveListener,
        activeListenerWithCapture
      };
    }

    function getSlideSelector() {
      return `.${swiper.params.slideClass}`;
    }

    function toggleGestures(method) {
      const {
        passiveListener
      } = getListeners();
      const slideSelector = getSlideSelector();
      swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
      swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
    }

    function enableGestures() {
      if (gesturesEnabled) return;
      gesturesEnabled = true;
      toggleGestures('on');
    }

    function disableGestures() {
      if (!gesturesEnabled) return;
      gesturesEnabled = false;
      toggleGestures('off');
    } // Attach/Detach Events


    function enable() {
      const zoom = swiper.zoom;
      if (zoom.enabled) return;
      zoom.enabled = true;
      const support = swiper.support;
      const {
        passiveListener,
        activeListenerWithCapture
      } = getListeners();
      const slideSelector = getSlideSelector(); // Scale image

      if (support.gestures) {
        swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
        }
      } // Move image


      swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
    }

    function disable() {
      const zoom = swiper.zoom;
      if (!zoom.enabled) return;
      const support = swiper.support;
      zoom.enabled = false;
      const {
        passiveListener,
        activeListenerWithCapture
      } = getListeners();
      const slideSelector = getSlideSelector(); // Scale image

      if (support.gestures) {
        swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
        }
      } // Move image


      swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
    }

    on('init', () => {
      if (swiper.params.zoom.enabled) {
        enable();
      }
    });
    on('destroy', () => {
      disable();
    });
    on('touchStart', (_s, e) => {
      if (!swiper.zoom.enabled) return;
      onTouchStart(e);
    });
    on('touchEnd', (_s, e) => {
      if (!swiper.zoom.enabled) return;
      onTouchEnd();
    });
    on('doubleTap', (_s, e) => {
      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        zoomToggle(e);
      }
    });
    on('transitionEnd', () => {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        onTransitionEnd();
      }
    });
    on('slideChange', () => {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        onTransitionEnd();
      }
    });
    Object.assign(swiper.zoom, {
      enable,
      disable,
      in: zoomIn,
      out: zoomOut,
      toggle: zoomToggle
    });
  }

  function Lazy({
    swiper,
    extendParams,
    on,
    emit
  }) {
    extendParams({
      lazy: {
        checkInView: false,
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,
        scrollingElement: '',
        elementClass: 'swiper-lazy',
        loadingClass: 'swiper-lazy-loading',
        loadedClass: 'swiper-lazy-loaded',
        preloaderClass: 'swiper-lazy-preloader'
      }
    });
    swiper.lazy = {};
    let scrollHandlerAttached = false;
    let initialImageLoaded = false;

    function loadInSlide(index, loadInDuplicate = true) {
      const params = swiper.params.lazy;
      if (typeof index === 'undefined') return;
      if (swiper.slides.length === 0) return;
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
      const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);

      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images.push($slideEl[0]);
      }

      if ($images.length === 0) return;
      $images.each(imageEl => {
        const $imageEl = $(imageEl);
        $imageEl.addClass(params.loadingClass);
        const background = $imageEl.attr('data-background');
        const src = $imageEl.attr('data-src');
        const srcset = $imageEl.attr('data-srcset');
        const sizes = $imageEl.attr('data-sizes');
        const $pictureEl = $imageEl.parent('picture');
        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
          if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

          if (background) {
            $imageEl.css('background-image', `url("${background}")`);
            $imageEl.removeAttr('data-background');
          } else {
            if (srcset) {
              $imageEl.attr('srcset', srcset);
              $imageEl.removeAttr('data-srcset');
            }

            if (sizes) {
              $imageEl.attr('sizes', sizes);
              $imageEl.removeAttr('data-sizes');
            }

            if ($pictureEl.length) {
              $pictureEl.children('source').each(sourceEl => {
                const $source = $(sourceEl);

                if ($source.attr('data-srcset')) {
                  $source.attr('srcset', $source.attr('data-srcset'));
                  $source.removeAttr('data-srcset');
                }
              });
            }

            if (src) {
              $imageEl.attr('src', src);
              $imageEl.removeAttr('data-src');
            }
          }

          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find(`.${params.preloaderClass}`).remove();

          if (swiper.params.loop && loadInDuplicate) {
            const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
              const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
              loadInSlide(originalSlide.index(), false);
            } else {
              const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
              loadInSlide(duplicatedSlide.index(), false);
            }
          }

          emit('lazyImageReady', $slideEl[0], $imageEl[0]);

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        });
        emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
      });
    }

    function load() {
      const {
        $wrapperEl,
        params: swiperParams,
        slides,
        activeIndex
      } = swiper;
      const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
      const params = swiperParams.lazy;
      let slidesPerView = swiperParams.slidesPerView;

      if (slidesPerView === 'auto') {
        slidesPerView = 0;
      }

      function slideExist(index) {
        if (isVirtual) {
          if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
            return true;
          }
        } else if (slides[index]) return true;

        return false;
      }

      function slideIndex(slideEl) {
        if (isVirtual) {
          return $(slideEl).attr('data-swiper-slide-index');
        }

        return $(slideEl).index();
      }

      if (!initialImageLoaded) initialImageLoaded = true;

      if (swiper.params.watchSlidesProgress) {
        $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
          const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
          loadInSlide(index);
        });
      } else if (slidesPerView > 1) {
        for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
          if (slideExist(i)) loadInSlide(i);
        }
      } else {
        loadInSlide(activeIndex);
      }

      if (params.loadPrevNext) {
        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
          const amount = params.loadPrevNextAmount;
          const spv = slidesPerView;
          const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

          for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
            if (slideExist(i)) loadInSlide(i);
          } // Prev Slides


          for (let i = minIndex; i < activeIndex; i += 1) {
            if (slideExist(i)) loadInSlide(i);
          }
        } else {
          const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
          if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
          const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
          if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
        }
      }
    }

    function checkInViewOnLoad() {
      const window = getWindow();
      if (!swiper || swiper.destroyed) return;
      const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
      const isWindow = $scrollElement[0] === window;
      const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
      const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
      const swiperOffset = swiper.$el.offset();
      const {
        rtlTranslate: rtl
      } = swiper;
      let inView = false;
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];

        if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

          inView = true;
        }
      }

      const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (inView) {
        load();
        $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
      } else if (!scrollHandlerAttached) {
        scrollHandlerAttached = true;
        $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
      }
    }

    on('beforeInit', () => {
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    });
    on('init', () => {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on('scroll', () => {
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
        load();
      }
    });
    on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on('transitionStart', () => {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      }
    });
    on('transitionEnd', () => {
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on('slideChange', () => {
      const {
        lazy,
        cssMode,
        watchSlidesProgress,
        touchReleaseOnEdges,
        resistanceRatio
      } = swiper.params;

      if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
        load();
      }
    });
    Object.assign(swiper.lazy, {
      load,
      loadInSlide
    });
  }
  /* eslint no-bitwise: ["error", { "allow": [">>"] }] */


  function Controller({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      controller: {
        control: undefined,
        inverse: false,
        by: 'slide' // or 'container'

      }
    });
    swiper.controller = {
      control: undefined
    };

    function LinearSpline(x, y) {
      const binarySearch = function search() {
        let maxIndex;
        let minIndex;
        let guess;
        return (array, val) => {
          minIndex = -1;
          maxIndex = array.length;

          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;

            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }

          return maxIndex;
        };
      }();

      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
      // (x1,y1) is the known point before given value,
      // (x3,y3) is the known point after given value.

      let i1;
      let i3;

      this.interpolate = function interpolate(x2) {
        if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
      };

      return this;
    } // xxx: for now i will just save one spline function to to


    function getInterpolateFunction(c) {
      if (!swiper.controller.spline) {
        swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
      }
    }

    function setTranslate(_t, byController) {
      const controlled = swiper.controller.control;
      let multiplier;
      let controlledTranslate;
      const Swiper = swiper.constructor;

      function setControlledTranslate(c) {
        // this will create an Interpolate function based on the snapGrids
        // x is the Grid of the scrolled scroller and y will be the controlled scroller
        // it makes sense to create this only once and recall it for the interpolation
        // the function does a lot of value caching for performance
        const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

        if (swiper.params.controller.by === 'slide') {
          getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
          // but it did not work out

          controlledTranslate = -swiper.controller.spline.interpolate(-translate);
        }

        if (!controlledTranslate || swiper.params.controller.by === 'container') {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
        }

        if (swiper.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }

        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }

      if (Array.isArray(controlled)) {
        for (let i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    }

    function setTransition(duration, byController) {
      const Swiper = swiper.constructor;
      const controlled = swiper.controller.control;
      let i;

      function setControlledTransition(c) {
        c.setTransition(duration, swiper);

        if (duration !== 0) {
          c.transitionStart();

          if (c.params.autoHeight) {
            nextTick(() => {
              c.updateAutoHeight();
            });
          }

          c.$wrapperEl.transitionEnd(() => {
            if (!controlled) return;

            if (c.params.loop && swiper.params.controller.by === 'slide') {
              c.loopFix();
            }

            c.transitionEnd();
          });
        }
      }

      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTransition(controlled);
      }
    }

    function removeSpline() {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    }

    on('beforeInit', () => {
      swiper.controller.control = swiper.params.controller.control;
    });
    on('update', () => {
      removeSpline();
    });
    on('resize', () => {
      removeSpline();
    });
    on('observerUpdate', () => {
      removeSpline();
    });
    on('setTranslate', (_s, translate, byController) => {
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    });
    on('setTransition', (_s, duration, byController) => {
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    });
    Object.assign(swiper.controller, {
      setTranslate,
      setTransition
    });
  }

  function A11y({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      a11y: {
        enabled: true,
        notificationClass: 'swiper-notification',
        prevSlideMessage: 'Previous slide',
        nextSlideMessage: 'Next slide',
        firstSlideMessage: 'This is the first slide',
        lastSlideMessage: 'This is the last slide',
        paginationBulletMessage: 'Go to slide {{index}}',
        slideLabelMessage: '{{index}} / {{slidesLength}}',
        containerMessage: null,
        containerRoleDescriptionMessage: null,
        itemRoleDescriptionMessage: null,
        slideRole: 'group'
      }
    });
    let liveRegion = null;

    function notify(message) {
      const notification = liveRegion;
      if (notification.length === 0) return;
      notification.html('');
      notification.html(message);
    }

    function getRandomNumber(size = 16) {
      const randomChar = () => Math.round(16 * Math.random()).toString(16);

      return 'x'.repeat(size).replace(/x/g, randomChar);
    }

    function makeElFocusable($el) {
      $el.attr('tabIndex', '0');
    }

    function makeElNotFocusable($el) {
      $el.attr('tabIndex', '-1');
    }

    function addElRole($el, role) {
      $el.attr('role', role);
    }

    function addElRoleDescription($el, description) {
      $el.attr('aria-roledescription', description);
    }

    function addElControls($el, controls) {
      $el.attr('aria-controls', controls);
    }

    function addElLabel($el, label) {
      $el.attr('aria-label', label);
    }

    function addElId($el, id) {
      $el.attr('id', id);
    }

    function addElLive($el, live) {
      $el.attr('aria-live', live);
    }

    function disableEl($el) {
      $el.attr('aria-disabled', true);
    }

    function enableEl($el) {
      $el.attr('aria-disabled', false);
    }

    function onEnterOrSpaceKey(e) {
      if (e.keyCode !== 13 && e.keyCode !== 32) return;
      const params = swiper.params.a11y;
      const $targetEl = $(e.target);

      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }

        if (swiper.isEnd) {
          notify(params.lastSlideMessage);
        } else {
          notify(params.nextSlideMessage);
        }
      }

      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }

        if (swiper.isBeginning) {
          notify(params.firstSlideMessage);
        } else {
          notify(params.prevSlideMessage);
        }
      }

      if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
        $targetEl[0].click();
      }
    }

    function updateNavigation() {
      if (swiper.params.loop || !swiper.navigation) return;
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          disableEl($prevEl);
          makeElNotFocusable($prevEl);
        } else {
          enableEl($prevEl);
          makeElFocusable($prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          disableEl($nextEl);
          makeElNotFocusable($nextEl);
        } else {
          enableEl($nextEl);
          makeElFocusable($nextEl);
        }
      }
    }

    function hasPagination() {
      return swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length;
    }

    function updatePagination() {
      const params = swiper.params.a11y;

      if (hasPagination()) {
        swiper.pagination.bullets.each(bulletEl => {
          const $bulletEl = $(bulletEl);
          makeElFocusable($bulletEl);

          if (!swiper.params.pagination.renderBullet) {
            addElRole($bulletEl, 'button');
            addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
          }
        });
      }
    }

    const initNavEl = ($el, wrapperId, message) => {
      makeElFocusable($el);

      if ($el[0].tagName !== 'BUTTON') {
        addElRole($el, 'button');
        $el.on('keydown', onEnterOrSpaceKey);
      }

      addElLabel($el, message);
      addElControls($el, wrapperId);
    };

    function init() {
      const params = swiper.params.a11y;
      swiper.$el.append(liveRegion); // Container

      const $containerEl = swiper.$el;

      if (params.containerRoleDescriptionMessage) {
        addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
      }

      if (params.containerMessage) {
        addElLabel($containerEl, params.containerMessage);
      } // Wrapper


      const $wrapperEl = swiper.$wrapperEl;
      const wrapperId = $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
      const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
      addElId($wrapperEl, wrapperId);
      addElLive($wrapperEl, live); // Slide

      if (params.itemRoleDescriptionMessage) {
        addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
      }

      addElRole($(swiper.slides), params.slideRole);
      const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
      swiper.slides.each((slideEl, index) => {
        const $slideEl = $(slideEl);
        const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel($slideEl, ariaLabelMessage);
      }); // Navigation

      let $nextEl;
      let $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl && $nextEl.length) {
        initNavEl($nextEl, wrapperId, params.nextSlideMessage);
      }

      if ($prevEl && $prevEl.length) {
        initNavEl($prevEl, wrapperId, params.prevSlideMessage);
      } // Pagination


      if (hasPagination()) {
        swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
      }
    }

    function destroy() {
      if (liveRegion && liveRegion.length > 0) liveRegion.remove();
      let $nextEl;
      let $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        $nextEl.off('keydown', onEnterOrSpaceKey);
      }

      if ($prevEl) {
        $prevEl.off('keydown', onEnterOrSpaceKey);
      } // Pagination


      if (hasPagination()) {
        swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
      }
    }

    on('beforeInit', () => {
      liveRegion = $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
    });
    on('afterInit', () => {
      if (!swiper.params.a11y.enabled) return;
      init();
      updateNavigation();
    });
    on('toEdge', () => {
      if (!swiper.params.a11y.enabled) return;
      updateNavigation();
    });
    on('fromEdge', () => {
      if (!swiper.params.a11y.enabled) return;
      updateNavigation();
    });
    on('paginationUpdate', () => {
      if (!swiper.params.a11y.enabled) return;
      updatePagination();
    });
    on('destroy', () => {
      if (!swiper.params.a11y.enabled) return;
      destroy();
    });
  }

  function History({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      history: {
        enabled: false,
        root: '',
        replaceState: false,
        key: 'slides'
      }
    });
    let initialized = false;
    let paths = {};

    const slugify = text => {
      return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    };

    const getPathValues = urlOverride => {
      const window = getWindow();
      let location;

      if (urlOverride) {
        location = new URL(urlOverride);
      } else {
        location = window.location;
      }

      const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
      const total = pathArray.length;
      const key = pathArray[total - 2];
      const value = pathArray[total - 1];
      return {
        key,
        value
      };
    };

    const setHistory = (key, index) => {
      const window = getWindow();
      if (!initialized || !swiper.params.history.enabled) return;
      let location;

      if (swiper.params.url) {
        location = new URL(swiper.params.url);
      } else {
        location = window.location;
      }

      const slide = swiper.slides.eq(index);
      let value = slugify(slide.attr('data-history'));

      if (swiper.params.history.root.length > 0) {
        let root = swiper.params.history.root;
        if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
        value = `${root}/${key}/${value}`;
      } else if (!location.pathname.includes(key)) {
        value = `${key}/${value}`;
      }

      const currentState = window.history.state;

      if (currentState && currentState.value === value) {
        return;
      }

      if (swiper.params.history.replaceState) {
        window.history.replaceState({
          value
        }, null, value);
      } else {
        window.history.pushState({
          value
        }, null, value);
      }
    };

    const scrollToSlide = (speed, value, runCallbacks) => {
      if (value) {
        for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
          const slide = swiper.slides.eq(i);
          const slideHistory = slugify(slide.attr('data-history'));

          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            const index = slide.index();
            swiper.slideTo(index, speed, runCallbacks);
          }
        }
      } else {
        swiper.slideTo(0, speed, runCallbacks);
      }
    };

    const setHistoryPopState = () => {
      paths = getPathValues(swiper.params.url);
      scrollToSlide(swiper.params.speed, swiper.paths.value, false);
    };

    const init = () => {
      const window = getWindow();
      if (!swiper.params.history) return;

      if (!window.history || !window.history.pushState) {
        swiper.params.history.enabled = false;
        swiper.params.hashNavigation.enabled = true;
        return;
      }

      initialized = true;
      paths = getPathValues(swiper.params.url);
      if (!paths.key && !paths.value) return;
      scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);

      if (!swiper.params.history.replaceState) {
        window.addEventListener('popstate', setHistoryPopState);
      }
    };

    const destroy = () => {
      const window = getWindow();

      if (!swiper.params.history.replaceState) {
        window.removeEventListener('popstate', setHistoryPopState);
      }
    };

    on('init', () => {
      if (swiper.params.history.enabled) {
        init();
      }
    });
    on('destroy', () => {
      if (swiper.params.history.enabled) {
        destroy();
      }
    });
    on('transitionEnd _freeModeNoMomentumRelease', () => {
      if (initialized) {
        setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    });
    on('slideChange', () => {
      if (initialized && swiper.params.cssMode) {
        setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    });
  }

  function HashNavigation({
    swiper,
    extendParams,
    emit,
    on
  }) {
    let initialized = false;
    const document = getDocument();
    const window = getWindow();
    extendParams({
      hashNavigation: {
        enabled: false,
        replaceState: false,
        watchState: false
      }
    });

    const onHashChange = () => {
      emit('hashChange');
      const newHash = document.location.hash.replace('#', '');
      const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

      if (newHash !== activeSlideHash) {
        const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
        if (typeof newIndex === 'undefined') return;
        swiper.slideTo(newIndex);
      }
    };

    const setHash = () => {
      if (!initialized || !swiper.params.hashNavigation.enabled) return;

      if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
        window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
        emit('hashSet');
      } else {
        const slide = swiper.slides.eq(swiper.activeIndex);
        const hash = slide.attr('data-hash') || slide.attr('data-history');
        document.location.hash = hash || '';
        emit('hashSet');
      }
    };

    const init = () => {
      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
      initialized = true;
      const hash = document.location.hash.replace('#', '');

      if (hash) {
        const speed = 0;

        for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
          const slide = swiper.slides.eq(i);
          const slideHash = slide.attr('data-hash') || slide.attr('data-history');

          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            const index = slide.index();
            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
          }
        }
      }

      if (swiper.params.hashNavigation.watchState) {
        $(window).on('hashchange', onHashChange);
      }
    };

    const destroy = () => {
      if (swiper.params.hashNavigation.watchState) {
        $(window).off('hashchange', onHashChange);
      }
    };

    on('init', () => {
      if (swiper.params.hashNavigation.enabled) {
        init();
      }
    });
    on('destroy', () => {
      if (swiper.params.hashNavigation.enabled) {
        destroy();
      }
    });
    on('transitionEnd _freeModeNoMomentumRelease', () => {
      if (initialized) {
        setHash();
      }
    });
    on('slideChange', () => {
      if (initialized && swiper.params.cssMode) {
        setHash();
      }
    });
  }
  /* eslint no-underscore-dangle: "off" */


  function Autoplay({
    swiper,
    extendParams,
    on,
    emit
  }) {
    let timeout;
    swiper.autoplay = {
      running: false,
      paused: false
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });

    function run() {
      const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
      let delay = swiper.params.autoplay.delay;

      if ($activeSlideEl.attr('data-swiper-autoplay')) {
        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
      }

      clearTimeout(timeout);
      timeout = nextTick(() => {
        let autoplayResult;

        if (swiper.params.autoplay.reverseDirection) {
          if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isBeginning) {
            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }
        } else if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.isEnd) {
          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
          emit('autoplay');
        } else {
          stop();
        }

        if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
          run();
        }
      }, delay);
    }

    function start() {
      if (typeof timeout !== 'undefined') return false;
      if (swiper.autoplay.running) return false;
      swiper.autoplay.running = true;
      emit('autoplayStart');
      run();
      return true;
    }

    function stop() {
      if (!swiper.autoplay.running) return false;
      if (typeof timeout === 'undefined') return false;

      if (timeout) {
        clearTimeout(timeout);
        timeout = undefined;
      }

      swiper.autoplay.running = false;
      emit('autoplayStop');
      return true;
    }

    function pause(speed) {
      if (!swiper.autoplay.running) return;
      if (swiper.autoplay.paused) return;
      if (timeout) clearTimeout(timeout);
      swiper.autoplay.paused = true;

      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
        swiper.autoplay.paused = false;
        run();
      } else {
        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
        });
      }
    }

    function onVisibilityChange() {
      const document = getDocument();

      if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
        pause();
      }

      if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
        run();
        swiper.autoplay.paused = false;
      }
    }

    function onTransitionEnd(e) {
      if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
      if (e.target !== swiper.$wrapperEl[0]) return;
      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
      });
      swiper.autoplay.paused = false;

      if (!swiper.autoplay.running) {
        stop();
      } else {
        run();
      }
    }

    function onMouseEnter() {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        pause();
      }

      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
      });
    }

    function onMouseLeave() {
      if (swiper.params.autoplay.disableOnInteraction) {
        return;
      }

      swiper.autoplay.paused = false;
      run();
    }

    function attachMouseEvents() {
      if (swiper.params.autoplay.pauseOnMouseEnter) {
        swiper.$el.on('mouseenter', onMouseEnter);
        swiper.$el.on('mouseleave', onMouseLeave);
      }
    }

    function detachMouseEvents() {
      swiper.$el.off('mouseenter', onMouseEnter);
      swiper.$el.off('mouseleave', onMouseLeave);
    }

    on('init', () => {
      if (swiper.params.autoplay.enabled) {
        start();
        const document = getDocument();
        document.addEventListener('visibilitychange', onVisibilityChange);
        attachMouseEvents();
      }
    });
    on('beforeTransitionStart', (_s, speed, internal) => {
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          stop();
        }
      }
    });
    on('sliderFirstMove', () => {
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          pause();
        }
      }
    });
    on('touchEnd', () => {
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        run();
      }
    });
    on('destroy', () => {
      detachMouseEvents();

      if (swiper.autoplay.running) {
        stop();
      }

      const document = getDocument();
      document.removeEventListener('visibilitychange', onVisibilityChange);
    });
    Object.assign(swiper.autoplay, {
      pause,
      run,
      start,
      stop
    });
  }

  function Thumb({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: true,
        autoScrollOffset: 0,
        slideThumbActiveClass: 'swiper-slide-thumb-active',
        thumbsContainerClass: 'swiper-thumbs'
      }
    });
    let initialized = false;
    let swiperCreated = false;
    swiper.thumbs = {
      swiper: null
    };

    function onThumbClick() {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      const clickedIndex = thumbsSwiper.clickedIndex;
      const clickedSlide = thumbsSwiper.clickedSlide;
      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
      if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
      let slideToIndex;

      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
      } else {
        slideToIndex = clickedIndex;
      }

      if (swiper.params.loop) {
        let currentIndex = swiper.activeIndex;

        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          currentIndex = swiper.activeIndex;
        }

        const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
      }

      swiper.slideTo(slideToIndex);
    }

    function init() {
      const {
        thumbs: thumbsParams
      } = swiper.params;
      if (initialized) return false;
      initialized = true;
      const SwiperClass = swiper.constructor;

      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper.thumbs.swiper = thumbsParams.swiper;
        Object.assign(swiper.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        Object.assign(swiper.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
      } else if (isObject(thumbsParams.swiper)) {
        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
        Object.assign(thumbsSwiperParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
        swiperCreated = true;
      }

      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
      swiper.thumbs.swiper.on('tap', onThumbClick);
      return true;
    }

    function update(initial) {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
      const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
        let currentThumbsIndex = thumbsSwiper.activeIndex;
        let newThumbsIndex;
        let direction;

        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix(); // eslint-disable-next-line

            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          } // Find actual thumbs index to slide to


          const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
          const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();

          if (typeof prevThumbsIndex === 'undefined') {
            newThumbsIndex = nextThumbsIndex;
          } else if (typeof nextThumbsIndex === 'undefined') {
            newThumbsIndex = prevThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = nextThumbsIndex;
          } else {
            newThumbsIndex = prevThumbsIndex;
          }

          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
        } else {
          newThumbsIndex = swiper.realIndex;
          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
        }

        if (useOffset) {
          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
        }

        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;

          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
        }
      } // Activate thumbs


      let thumbsToActivate = 1;
      const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
        thumbsToActivate = swiper.params.slidesPerView;
      }

      if (!swiper.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }

      thumbsToActivate = Math.floor(thumbsToActivate);
      thumbsSwiper.slides.removeClass(thumbActiveClass);

      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
        }
      } else {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
        }
      }
    }

    on('beforeInit', () => {
      const {
        thumbs
      } = swiper.params;
      if (!thumbs || !thumbs.swiper) return;
      init();
      update(true);
    });
    on('slideChange update resize observerUpdate', () => {
      if (!swiper.thumbs.swiper) return;
      update();
    });
    on('setTransition', (_s, duration) => {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    });
    on('beforeDestroy', () => {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;

      if (swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    });
    Object.assign(swiper.thumbs, {
      init,
      update
    });
  }

  function freeMode({
    swiper,
    extendParams,
    emit,
    once
  }) {
    extendParams({
      freeMode: {
        enabled: false,
        momentum: true,
        momentumRatio: 1,
        momentumBounce: true,
        momentumBounceRatio: 1,
        momentumVelocityRatio: 1,
        sticky: false,
        minimumVelocity: 0.02
      }
    });

    function onTouchMove() {
      const {
        touchEventsData: data,
        touches
      } = swiper; // Velocity

      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
          time: data.touchStartTime
        });
      }

      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
        time: now()
      });
    }

    function onTouchEnd({
      currentPos
    }) {
      const {
        params,
        $wrapperEl,
        rtlTranslate: rtl,
        snapGrid,
        touchEventsData: data
      } = swiper; // Time diff

      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime;

      if (currentPos < -swiper.minTranslate()) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (currentPos > -swiper.maxTranslate()) {
        if (swiper.slides.length < snapGrid.length) {
          swiper.slideTo(snapGrid.length - 1);
        } else {
          swiper.slideTo(swiper.slides.length - 1);
        }

        return;
      }

      if (params.freeMode.momentum) {
        if (data.velocities.length > 1) {
          const lastMoveEvent = data.velocities.pop();
          const velocityEvent = data.velocities.pop();
          const distance = lastMoveEvent.position - velocityEvent.position;
          const time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;

          if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
            swiper.velocity = 0;
          } // this implies that the user stopped moving a finger then released.
          // There would be no events with distance zero, so the last event is stale.


          if (time > 150 || now() - lastMoveEvent.time > 300) {
            swiper.velocity = 0;
          }
        } else {
          swiper.velocity = 0;
        }

        swiper.velocity *= params.freeMode.momentumVelocityRatio;
        data.velocities.length = 0;
        let momentumDuration = 1000 * params.freeMode.momentumRatio;
        const momentumDistance = swiper.velocity * momentumDuration;
        let newPosition = swiper.translate + momentumDistance;
        if (rtl) newPosition = -newPosition;
        let doBounce = false;
        let afterBouncePosition;
        const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
        let needsLoopFix;

        if (newPosition < swiper.maxTranslate()) {
          if (params.freeMode.momentumBounce) {
            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
              newPosition = swiper.maxTranslate() - bounceAmount;
            }

            afterBouncePosition = swiper.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.maxTranslate();
          }

          if (params.loop && params.centeredSlides) needsLoopFix = true;
        } else if (newPosition > swiper.minTranslate()) {
          if (params.freeMode.momentumBounce) {
            if (newPosition - swiper.minTranslate() > bounceAmount) {
              newPosition = swiper.minTranslate() + bounceAmount;
            }

            afterBouncePosition = swiper.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.minTranslate();
          }

          if (params.loop && params.centeredSlides) needsLoopFix = true;
        } else if (params.freeMode.sticky) {
          let nextSlide;

          for (let j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }

          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }

          newPosition = -newPosition;
        }

        if (needsLoopFix) {
          once('transitionEnd', () => {
            swiper.loopFix();
          });
        } // Fix duration


        if (swiper.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
          }

          if (params.freeMode.sticky) {
            // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
            // event, then durations can be 20+ seconds to slide one (or zero!) slides.
            // It's easy to see this when simulating touch with mouse events. To fix this,
            // limit single-slide swipes to the default slide duration. This also has the
            // nice side effect of matching slide speed if the user stopped moving before
            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
            // For faster swipes, also apply limits (albeit higher ones).
            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

            if (moveDistance < currentSlideSize) {
              momentumDuration = params.speed;
            } else if (moveDistance < 2 * currentSlideSize) {
              momentumDuration = params.speed * 1.5;
            } else {
              momentumDuration = params.speed * 2.5;
            }
          }
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        }

        if (params.freeMode.momentumBounce && doBounce) {
          swiper.updateProgress(afterBouncePosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
            emit('momentumBounce');
            swiper.setTransition(params.speed);
            setTimeout(() => {
              swiper.setTranslate(afterBouncePosition);
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }, 0);
          });
        } else if (swiper.velocity) {
          emit('_freeModeNoMomentumRelease');
          swiper.updateProgress(newPosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);

          if (!swiper.animating) {
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }
        } else {
          swiper.updateProgress(newPosition);
        }

        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      } else if (params.freeMode) {
        emit('_freeModeNoMomentumRelease');
      }

      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
    }

    Object.assign(swiper, {
      freeMode: {
        onTouchMove,
        onTouchEnd
      }
    });
  }

  function Grid({
    swiper,
    extendParams
  }) {
    extendParams({
      grid: {
        rows: 1,
        fill: 'column'
      }
    });
    let slidesNumberEvenToRows;
    let slidesPerRow;
    let numFullColumns;

    const initSlides = slidesLength => {
      const {
        slidesPerView
      } = swiper.params;
      const {
        rows,
        fill
      } = swiper.params.grid;
      slidesPerRow = slidesNumberEvenToRows / rows;
      numFullColumns = Math.floor(slidesLength / rows);

      if (Math.floor(slidesLength / rows) === slidesLength / rows) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
      }

      if (slidesPerView !== 'auto' && fill === 'row') {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
      }
    };

    const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
      const {
        slidesPerGroup,
        spaceBetween
      } = swiper.params;
      const {
        rows,
        fill
      } = swiper.params.grid; // Set slides order

      let newSlideOrderIndex;
      let column;
      let row;

      if (fill === 'row' && slidesPerGroup > 1) {
        const groupIndex = Math.floor(i / (slidesPerGroup * rows));
        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
        const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
        slide.css({
          '-webkit-order': newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (fill === 'column') {
        column = Math.floor(i / rows);
        row = i - column * rows;

        if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
          row += 1;

          if (row >= rows) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }

      slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
    };

    const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
      const {
        spaceBetween,
        centeredSlides,
        roundLengths
      } = swiper.params;
      const {
        rows
      } = swiper.params.grid;
      swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
      swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
      swiper.$wrapperEl.css({
        [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
      });

      if (centeredSlides) {
        snapGrid.splice(0, snapGrid.length);
        const newSlidesGrid = [];

        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
        }

        snapGrid.push(...newSlidesGrid);
      }
    };

    swiper.grid = {
      initSlides,
      updateSlide,
      updateWrapperSize
    };
  }

  function appendSlide(slides) {
    const swiper = this;
    const {
      $wrapperEl,
      params
    } = swiper;

    if (params.loop) {
      swiper.loopDestroy();
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.append(slides[i]);
      }
    } else {
      $wrapperEl.append(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!params.observer) {
      swiper.update();
    }
  }

  function prependSlide(slides) {
    const swiper = this;
    const {
      params,
      $wrapperEl,
      activeIndex
    } = swiper;

    if (params.loop) {
      swiper.loopDestroy();
    }

    let newActiveIndex = activeIndex + 1;

    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.prepend(slides[i]);
      }

      newActiveIndex = activeIndex + slides.length;
    } else {
      $wrapperEl.prepend(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!params.observer) {
      swiper.update();
    }

    swiper.slideTo(newActiveIndex, 0, false);
  }

  function addSlide(index, slides) {
    const swiper = this;
    const {
      $wrapperEl,
      params,
      activeIndex
    } = swiper;
    let activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
    }

    const baseLength = swiper.slides.length;

    if (index <= 0) {
      swiper.prependSlide(slides);
      return;
    }

    if (index >= baseLength) {
      swiper.appendSlide(slides);
      return;
    }

    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    const slidesBuffer = [];

    for (let i = baseLength - 1; i >= index; i -= 1) {
      const currentSlide = swiper.slides.eq(i);
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.append(slides[i]);
      }

      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      $wrapperEl.append(slides);
    }

    for (let i = 0; i < slidesBuffer.length; i += 1) {
      $wrapperEl.append(slidesBuffer[i]);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!params.observer) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeSlide(slidesIndexes) {
    const swiper = this;
    const {
      params,
      $wrapperEl,
      activeIndex
    } = swiper;
    let activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
    }

    let newActiveIndex = activeIndexBuffer;
    let indexToRemove;

    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
      for (let i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
      }

      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
      newActiveIndex = Math.max(newActiveIndex, 0);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!params.observer) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeAllSlides() {
    const swiper = this;
    const slidesIndexes = [];

    for (let i = 0; i < swiper.slides.length; i += 1) {
      slidesIndexes.push(i);
    }

    swiper.removeSlide(slidesIndexes);
  }

  function Manipulation({
    swiper
  }) {
    Object.assign(swiper, {
      appendSlide: appendSlide.bind(swiper),
      prependSlide: prependSlide.bind(swiper),
      addSlide: addSlide.bind(swiper),
      removeSlide: removeSlide.bind(swiper),
      removeAllSlides: removeAllSlides.bind(swiper)
    });
  }

  function effectInit(params) {
    const {
      effect,
      swiper,
      on,
      setTranslate,
      setTransition,
      overwriteParams,
      perspective
    } = params;
    on('beforeInit', () => {
      if (swiper.params.effect !== effect) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);

      if (perspective && perspective()) {
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      }

      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper.params, overwriteParamsResult);
      Object.assign(swiper.originalParams, overwriteParamsResult);
    });
    on('setTranslate', () => {
      if (swiper.params.effect !== effect) return;
      setTranslate();
    });
    on('setTransition', (_s, duration) => {
      if (swiper.params.effect !== effect) return;
      setTransition(duration);
    });
  }

  function effectTarget(effectParams, $slideEl) {
    if (effectParams.transformEl) {
      return $slideEl.find(effectParams.transformEl).css({
        'backface-visibility': 'hidden',
        '-webkit-backface-visibility': 'hidden'
      });
    }

    return $slideEl;
  }

  function effectVirtualTransitionEnd({
    swiper,
    duration,
    transformEl,
    allSlides
  }) {
    const {
      slides,
      activeIndex,
      $wrapperEl
    } = swiper;

    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let $transitionEndTarget;

      if (allSlides) {
        $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
      } else {
        $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
      }

      $transitionEndTarget.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }

  function EffectFade({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      fadeEffect: {
        crossFade: false,
        transformEl: null
      }
    });

    const setTranslate = () => {
      const {
        slides
      } = swiper;
      const params = swiper.params.fadeEffect;

      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = swiper.slides.eq(i);
        const offset = $slideEl[0].swiperSlideOffset;
        let tx = -offset;
        if (!swiper.params.virtualTranslate) tx -= swiper.translate;
        let ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }

        const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.css({
          opacity: slideOpacity
        }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
      }
    };

    const setTransition = duration => {
      const {
        transformEl
      } = swiper.params.fadeEffect;
      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
      $transitionElements.transition(duration);
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformEl,
        allSlides: true
      });
    };

    effectInit({
      effect: 'fade',
      swiper,
      on,
      setTranslate,
      setTransition,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  function EffectCube({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94
      }
    });

    const setTranslate = () => {
      const {
        $el,
        $wrapperEl,
        slides,
        width: swiperWidth,
        height: swiperHeight,
        rtlTranslate: rtl,
        size: swiperSize,
        browser
      } = swiper;
      const params = swiper.params.cubeEffect;
      const isHorizontal = swiper.isHorizontal();
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let wrapperRotate = 0;
      let $cubeShadowEl;

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $wrapperEl.append($cubeShadowEl);
          }

          $cubeShadowEl.css({
            height: `${swiperWidth}px`
          });
        } else {
          $cubeShadowEl = $el.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $el.append($cubeShadowEl);
          }
        }
      }

      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        let slideIndex = i;

        if (isVirtual) {
          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
        }

        let slideAngle = slideIndex * 90;
        let round = Math.floor(slideAngle / 360);

        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }

        const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        let tx = 0;
        let ty = 0;
        let tz = 0;

        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + round * 4 * swiperSize;
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = 3 * swiperSize + swiperSize * 4 * round;
        }

        if (rtl) {
          tx = -tx;
        }

        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }

        const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;

        if (progress <= 1 && progress > -1) {
          wrapperRotate = slideIndex * 90 + progress * 90;
          if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
        }

        $slideEl.transform(transform);

        if (params.slideShadows) {
          // Set shadows
          let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
          if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        }
      }

      $wrapperEl.css({
        '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
        'transform-origin': `50% 50% -${swiperSize / 2}px`
      });

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
        } else {
          const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
          const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
          const scale1 = params.shadowScale;
          const scale2 = params.shadowScale / multiplier;
          const offset = params.shadowOffset;
          $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
        }
      }

      const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
      $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
    };

    const setTransition = duration => {
      const {
        $el,
        slides
      } = swiper;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
        $el.find('.swiper-cube-shadow').transition(duration);
      }
    };

    effectInit({
      effect: 'cube',
      swiper,
      on,
      setTranslate,
      setTransition,
      perspective: () => true,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true
      })
    });
  }

  function createShadow(params, $slideEl, side) {
    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
    const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
    let $shadowEl = $shadowContainer.children(`.${shadowClass}`);

    if (!$shadowEl.length) {
      $shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
      $shadowContainer.append($shadowEl);
    }

    return $shadowEl;
  }

  function EffectFlip({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      flipEffect: {
        slideShadows: true,
        limitRotation: true,
        transformEl: null
      }
    });

    const setTranslate = () => {
      const {
        slides,
        rtlTranslate: rtl
      } = swiper;
      const params = swiper.params.flipEffect;

      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        let progress = $slideEl[0].progress;

        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        }

        const offset = $slideEl[0].swiperSlideOffset;
        const rotate = -180 * progress;
        let rotateY = rotate;
        let rotateX = 0;
        let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
        let ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }

        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

        if (params.slideShadows) {
          // Set shadows
          let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
          }

          if (shadowAfter.length === 0) {
            shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
          }

          if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
          if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        }

        const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(transform);
      }
    };

    const setTransition = duration => {
      const {
        transformEl
      } = swiper.params.flipEffect;
      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
      $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformEl
      });
    };

    effectInit({
      effect: 'flip',
      swiper,
      on,
      setTranslate,
      setTransition,
      perspective: () => true,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  function EffectCoverflow({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: true,
        transformEl: null
      }
    });

    const setTranslate = () => {
      const {
        width: swiperWidth,
        height: swiperHeight,
        slides,
        slidesSizesGrid
      } = swiper;
      const params = swiper.params.coverflowEffect;
      const isHorizontal = swiper.isHorizontal();
      const transform = swiper.translate;
      const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
      const rotate = isHorizontal ? params.rotate : -params.rotate;
      const translate = params.depth; // Each slide offset from center

      for (let i = 0, length = slides.length; i < length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideSize = slidesSizesGrid[i];
        const slideOffset = $slideEl[0].swiperSlideOffset;
        const offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

        let translateZ = -translate * Math.abs(offsetMultiplier);
        let stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
          stretch = parseFloat(params.stretch) / 100 * slideSize;
        }

        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

        if (Math.abs(translateX) < 0.001) translateX = 0;
        if (Math.abs(translateY) < 0.001) translateY = 0;
        if (Math.abs(translateZ) < 0.001) translateZ = 0;
        if (Math.abs(rotateY) < 0.001) rotateY = 0;
        if (Math.abs(rotateX) < 0.001) rotateX = 0;
        if (Math.abs(scale) < 0.001) scale = 0;
        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(slideTransform);
        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

        if (params.slideShadows) {
          // Set shadows
          let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if ($shadowBeforeEl.length === 0) {
            $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
          }

          if ($shadowAfterEl.length === 0) {
            $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
          }

          if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
        }
      }
    };

    const setTransition = duration => {
      const {
        transformEl
      } = swiper.params.coverflowEffect;
      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
      $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
    };

    effectInit({
      effect: 'coverflow',
      swiper,
      on,
      setTranslate,
      setTransition,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true
      })
    });
  }

  function EffectCreative({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      creativeEffect: {
        transformEl: null,
        limitProgress: 1,
        shadowPerProgress: false,
        progressMultiplier: 1,
        perspective: true,
        prev: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        },
        next: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        }
      }
    });

    const getTranslateValue = value => {
      if (typeof value === 'string') return value;
      return `${value}px`;
    };

    const setTranslate = () => {
      const {
        slides
      } = swiper;
      const params = swiper.params.creativeEffect;
      const {
        progressMultiplier: multiplier
      } = params;

      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideProgress = $slideEl[0].progress;
        const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
        const originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
        const offset = $slideEl[0].swiperSlideOffset;
        const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
        const r = [0, 0, 0];
        let custom = false;

        if (!swiper.isHorizontal()) {
          t[1] = t[0];
          t[0] = 0;
        }

        let data = {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          scale: 1,
          opacity: 1
        };

        if (progress < 0) {
          data = params.next;
          custom = true;
        } else if (progress > 0) {
          data = params.prev;
          custom = true;
        } // set translate


        t.forEach((value, index) => {
          t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
        }); // set rotates

        r.forEach((value, index) => {
          r[index] = data.rotate[index] * Math.abs(progress * multiplier);
        });
        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const translateString = t.join(', ');
        const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
        const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
        const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
        const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows

        if (custom && data.shadow || !custom) {
          let $shadowEl = $slideEl.children('.swiper-slide-shadow');

          if ($shadowEl.length === 0 && data.shadow) {
            $shadowEl = createShadow(params, $slideEl);
          }

          if ($shadowEl.length) {
            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
            $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
          }
        }

        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(transform).css({
          opacity: opacityString
        });

        if (data.origin) {
          $targetEl.css('transform-origin', data.origin);
        }
      }
    };

    const setTransition = duration => {
      const {
        transformEl
      } = swiper.params.creativeEffect;
      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
      $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformEl,
        allSlides: true
      });
    };

    effectInit({
      effect: 'creative',
      swiper,
      on,
      setTranslate,
      setTransition,
      perspective: () => swiper.params.creativeEffect.perspective,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  function EffectCards({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      cardsEffect: {
        slideShadows: true,
        transformEl: null
      }
    });

    const setTranslate = () => {
      const {
        slides,
        activeIndex
      } = swiper;
      const params = swiper.params.cardsEffect;
      const {
        startTranslate,
        isTouched
      } = swiper.touchEventsData;
      const currentTranslate = swiper.translate;

      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideProgress = $slideEl[0].progress;
        const progress = Math.min(Math.max(slideProgress, -4), 4);
        let offset = $slideEl[0].swiperSlideOffset;

        if (swiper.params.centeredSlides && !swiper.params.cssMode) {
          swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
        }

        if (swiper.params.centeredSlides && swiper.params.cssMode) {
          offset -= slides[0].swiperSlideOffset;
        }

        let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
        let tY = 0;
        const tZ = -100 * Math.abs(progress);
        let scale = 1;
        let rotate = -2 * progress;
        let tXAdd = 8 - Math.abs(progress) * 0.75;
        const isSwipeToNext = (i === activeIndex || i === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
        const isSwipeToPrev = (i === activeIndex || i === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;

        if (isSwipeToNext || isSwipeToPrev) {
          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
          rotate += -28 * progress * subProgress;
          scale += -0.5 * subProgress;
          tXAdd += 96 * subProgress;
          tY = `${-25 * subProgress * Math.abs(progress)}%`;
        }

        if (progress < 0) {
          // next
          tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
        } else if (progress > 0) {
          // prev
          tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
        } else {
          tX = `${tX}px`;
        }

        if (!swiper.isHorizontal()) {
          const prevY = tY;
          tY = tX;
          tX = prevY;
        }

        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
        const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${rotate}deg)
        scale(${scaleString})
      `;

        if (params.slideShadows) {
          // Set shadows
          let $shadowEl = $slideEl.find('.swiper-slide-shadow');

          if ($shadowEl.length === 0) {
            $shadowEl = createShadow(params, $slideEl);
          }

          if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
        }

        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(transform);
      }
    };

    const setTransition = duration => {
      const {
        transformEl
      } = swiper.params.cardsEffect;
      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
      $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformEl
      });
    };

    effectInit({
      effect: 'cards',
      swiper,
      on,
      setTranslate,
      setTransition,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  } // Swiper Class


  const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
  Swiper.use(modules);
  return Swiper;
});
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.AOS = t();
}(this, function () {
  "use strict";

  var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
      t = "Expected a function",
      n = NaN,
      o = "[object Symbol]",
      i = /^\s+|\s+$/g,
      a = /^[-+]0x[0-9a-f]+$/i,
      r = /^0b[01]+$/i,
      c = /^0o[0-7]+$/i,
      s = parseInt,
      u = "object" == typeof e && e && e.Object === Object && e,
      d = "object" == typeof self && self && self.Object === Object && self,
      l = u || d || Function("return this")(),
      f = Object.prototype.toString,
      m = Math.max,
      p = Math.min,
      b = function () {
    return l.Date.now();
  };

  function v(e, n, o) {
    var i,
        a,
        r,
        c,
        s,
        u,
        d = 0,
        l = !1,
        f = !1,
        v = !0;
    if ("function" != typeof e) throw new TypeError(t);

    function y(t) {
      var n = i,
          o = a;
      return i = a = void 0, d = t, c = e.apply(o, n);
    }

    function h(e) {
      var t = e - u;
      return void 0 === u || t >= n || t < 0 || f && e - d >= r;
    }

    function k() {
      var e = b();
      if (h(e)) return x(e);
      s = setTimeout(k, function (e) {
        var t = n - (e - u);
        return f ? p(t, r - (e - d)) : t;
      }(e));
    }

    function x(e) {
      return s = void 0, v && i ? y(e) : (i = a = void 0, c);
    }

    function O() {
      var e = b(),
          t = h(e);

      if (i = arguments, a = this, u = e, t) {
        if (void 0 === s) return function (e) {
          return d = e, s = setTimeout(k, n), l ? y(e) : c;
        }(u);
        if (f) return s = setTimeout(k, n), y(u);
      }

      return void 0 === s && (s = setTimeout(k, n)), c;
    }

    return n = w(n) || 0, g(o) && (l = !!o.leading, r = (f = "maxWait" in o) ? m(w(o.maxWait) || 0, n) : r, v = "trailing" in o ? !!o.trailing : v), O.cancel = function () {
      void 0 !== s && clearTimeout(s), d = 0, i = u = a = s = void 0;
    }, O.flush = function () {
      return void 0 === s ? c : x(b());
    }, O;
  }

  function g(e) {
    var t = typeof e;
    return !!e && ("object" == t || "function" == t);
  }

  function w(e) {
    if ("number" == typeof e) return e;
    if (function (e) {
      return "symbol" == typeof e || function (e) {
        return !!e && "object" == typeof e;
      }(e) && f.call(e) == o;
    }(e)) return n;

    if (g(e)) {
      var t = "function" == typeof e.valueOf ? e.valueOf() : e;
      e = g(t) ? t + "" : t;
    }

    if ("string" != typeof e) return 0 === e ? e : +e;
    e = e.replace(i, "");
    var u = r.test(e);
    return u || c.test(e) ? s(e.slice(2), u ? 2 : 8) : a.test(e) ? n : +e;
  }

  var y = function (e, n, o) {
    var i = !0,
        a = !0;
    if ("function" != typeof e) throw new TypeError(t);
    return g(o) && (i = "leading" in o ? !!o.leading : i, a = "trailing" in o ? !!o.trailing : a), v(e, n, {
      leading: i,
      maxWait: n,
      trailing: a
    });
  },
      h = "Expected a function",
      k = NaN,
      x = "[object Symbol]",
      O = /^\s+|\s+$/g,
      j = /^[-+]0x[0-9a-f]+$/i,
      E = /^0b[01]+$/i,
      N = /^0o[0-7]+$/i,
      z = parseInt,
      C = "object" == typeof e && e && e.Object === Object && e,
      A = "object" == typeof self && self && self.Object === Object && self,
      q = C || A || Function("return this")(),
      L = Object.prototype.toString,
      T = Math.max,
      M = Math.min,
      S = function () {
    return q.Date.now();
  };

  function D(e) {
    var t = typeof e;
    return !!e && ("object" == t || "function" == t);
  }

  function H(e) {
    if ("number" == typeof e) return e;
    if (function (e) {
      return "symbol" == typeof e || function (e) {
        return !!e && "object" == typeof e;
      }(e) && L.call(e) == x;
    }(e)) return k;

    if (D(e)) {
      var t = "function" == typeof e.valueOf ? e.valueOf() : e;
      e = D(t) ? t + "" : t;
    }

    if ("string" != typeof e) return 0 === e ? e : +e;
    e = e.replace(O, "");
    var n = E.test(e);
    return n || N.test(e) ? z(e.slice(2), n ? 2 : 8) : j.test(e) ? k : +e;
  }

  var $ = function (e, t, n) {
    var o,
        i,
        a,
        r,
        c,
        s,
        u = 0,
        d = !1,
        l = !1,
        f = !0;
    if ("function" != typeof e) throw new TypeError(h);

    function m(t) {
      var n = o,
          a = i;
      return o = i = void 0, u = t, r = e.apply(a, n);
    }

    function p(e) {
      var n = e - s;
      return void 0 === s || n >= t || n < 0 || l && e - u >= a;
    }

    function b() {
      var e = S();
      if (p(e)) return v(e);
      c = setTimeout(b, function (e) {
        var n = t - (e - s);
        return l ? M(n, a - (e - u)) : n;
      }(e));
    }

    function v(e) {
      return c = void 0, f && o ? m(e) : (o = i = void 0, r);
    }

    function g() {
      var e = S(),
          n = p(e);

      if (o = arguments, i = this, s = e, n) {
        if (void 0 === c) return function (e) {
          return u = e, c = setTimeout(b, t), d ? m(e) : r;
        }(s);
        if (l) return c = setTimeout(b, t), m(s);
      }

      return void 0 === c && (c = setTimeout(b, t)), r;
    }

    return t = H(t) || 0, D(n) && (d = !!n.leading, a = (l = "maxWait" in n) ? T(H(n.maxWait) || 0, t) : a, f = "trailing" in n ? !!n.trailing : f), g.cancel = function () {
      void 0 !== c && clearTimeout(c), u = 0, o = s = i = c = void 0;
    }, g.flush = function () {
      return void 0 === c ? r : v(S());
    }, g;
  },
      W = function () {};

  function P(e) {
    e && e.forEach(function (e) {
      var t = Array.prototype.slice.call(e.addedNodes),
          n = Array.prototype.slice.call(e.removedNodes);
      if (function e(t) {
        var n = void 0,
            o = void 0;

        for (n = 0; n < t.length; n += 1) {
          if ((o = t[n]).dataset && o.dataset.aos) return !0;
          if (o.children && e(o.children)) return !0;
        }

        return !1;
      }(t.concat(n))) return W();
    });
  }

  function Y() {
    return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
  }

  var _ = {
    isSupported: function () {
      return !!Y();
    },
    ready: function (e, t) {
      var n = window.document,
          o = new (Y())(P);
      W = t, o.observe(n.documentElement, {
        childList: !0,
        subtree: !0,
        removedNodes: !0
      });
    }
  },
      B = function (e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  },
      F = function () {
    function e(e, t) {
      for (var n = 0; n < t.length; n++) {
        var o = t[n];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
      }
    }

    return function (t, n, o) {
      return n && e(t.prototype, n), o && e(t, o), t;
    };
  }(),
      I = Object.assign || function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];

      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }

    return e;
  },
      K = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
      G = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
      J = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,
      Q = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;

  function R() {
    return navigator.userAgent || navigator.vendor || window.opera || "";
  }

  var U = new (function () {
    function e() {
      B(this, e);
    }

    return F(e, [{
      key: "phone",
      value: function () {
        var e = R();
        return !(!K.test(e) && !G.test(e.substr(0, 4)));
      }
    }, {
      key: "mobile",
      value: function () {
        var e = R();
        return !(!J.test(e) && !Q.test(e.substr(0, 4)));
      }
    }, {
      key: "tablet",
      value: function () {
        return this.mobile() && !this.phone();
      }
    }, {
      key: "ie11",
      value: function () {
        return "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;
      }
    }]), e;
  }())(),
      V = function (e, t) {
    var n = void 0;
    return U.ie11() ? (n = document.createEvent("CustomEvent")).initCustomEvent(e, !0, !0, {
      detail: t
    }) : n = new CustomEvent(e, {
      detail: t
    }), document.dispatchEvent(n);
  },
      X = function (e) {
    return e.forEach(function (e, t) {
      return function (e, t) {
        var n = e.options,
            o = e.position,
            i = e.node,
            a = (e.data, function () {
          e.animated && (function (e, t) {
            t && t.forEach(function (t) {
              return e.classList.remove(t);
            });
          }(i, n.animatedClassNames), V("aos:out", i), e.options.id && V("aos:in:" + e.options.id, i), e.animated = !1);
        });
        n.mirror && t >= o.out && !n.once ? a() : t >= o.in ? e.animated || (function (e, t) {
          t && t.forEach(function (t) {
            return e.classList.add(t);
          });
        }(i, n.animatedClassNames), V("aos:in", i), e.options.id && V("aos:in:" + e.options.id, i), e.animated = !0) : e.animated && !n.once && a();
      }(e, window.pageYOffset);
    });
  },
      Z = function (e) {
    for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);) t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent;

    return {
      top: n,
      left: t
    };
  },
      ee = function (e, t, n) {
    var o = e.getAttribute("data-aos-" + t);

    if (void 0 !== o) {
      if ("true" === o) return !0;
      if ("false" === o) return !1;
    }

    return o || n;
  },
      te = function (e, t) {
    return e.forEach(function (e, n) {
      var o = ee(e.node, "mirror", t.mirror),
          i = ee(e.node, "once", t.once),
          a = ee(e.node, "id"),
          r = t.useClassNames && e.node.getAttribute("data-aos"),
          c = [t.animatedClassName].concat(r ? r.split(" ") : []).filter(function (e) {
        return "string" == typeof e;
      });
      t.initClassName && e.node.classList.add(t.initClassName), e.position = {
        in: function (e, t, n) {
          var o = window.innerHeight,
              i = ee(e, "anchor"),
              a = ee(e, "anchor-placement"),
              r = Number(ee(e, "offset", a ? 0 : t)),
              c = a || n,
              s = e;
          i && document.querySelectorAll(i) && (s = document.querySelectorAll(i)[0]);
          var u = Z(s).top - o;

          switch (c) {
            case "top-bottom":
              break;

            case "center-bottom":
              u += s.offsetHeight / 2;
              break;

            case "bottom-bottom":
              u += s.offsetHeight;
              break;

            case "top-center":
              u += o / 2;
              break;

            case "center-center":
              u += o / 2 + s.offsetHeight / 2;
              break;

            case "bottom-center":
              u += o / 2 + s.offsetHeight;
              break;

            case "top-top":
              u += o;
              break;

            case "bottom-top":
              u += o + s.offsetHeight;
              break;

            case "center-top":
              u += o + s.offsetHeight / 2;
          }

          return u + r;
        }(e.node, t.offset, t.anchorPlacement),
        out: o && function (e, t) {
          window.innerHeight;
          var n = ee(e, "anchor"),
              o = ee(e, "offset", t),
              i = e;
          return n && document.querySelectorAll(n) && (i = document.querySelectorAll(n)[0]), Z(i).top + i.offsetHeight - o;
        }(e.node, t.offset)
      }, e.options = {
        once: i,
        mirror: o,
        animatedClassNames: c,
        id: a
      };
    }), e;
  },
      ne = function () {
    var e = document.querySelectorAll("[data-aos]");
    return Array.prototype.map.call(e, function (e) {
      return {
        node: e
      };
    });
  },
      oe = [],
      ie = !1,
      ae = {
    offset: 120,
    delay: 0,
    easing: "ease",
    duration: 400,
    disable: !1,
    once: !1,
    mirror: !1,
    anchorPlacement: "top-bottom",
    startEvent: "DOMContentLoaded",
    animatedClassName: "aos-animate",
    initClassName: "aos-init",
    useClassNames: !1,
    disableMutationObserver: !1,
    throttleDelay: 99,
    debounceDelay: 50
  },
      re = function () {
    return document.all && !window.atob;
  },
      ce = function () {
    arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (ie = !0), ie && (oe = te(oe, ae), X(oe), window.addEventListener("scroll", y(function () {
      X(oe, ae.once);
    }, ae.throttleDelay)));
  },
      se = function () {
    if (oe = ne(), de(ae.disable) || re()) return ue();
    ce();
  },
      ue = function () {
    oe.forEach(function (e, t) {
      e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay"), ae.initClassName && e.node.classList.remove(ae.initClassName), ae.animatedClassName && e.node.classList.remove(ae.animatedClassName);
    });
  },
      de = function (e) {
    return !0 === e || "mobile" === e && U.mobile() || "phone" === e && U.phone() || "tablet" === e && U.tablet() || "function" == typeof e && !0 === e();
  };

  return {
    init: function (e) {
      return ae = I(ae, e), oe = ne(), ae.disableMutationObserver || _.isSupported() || (console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '), ae.disableMutationObserver = !0), ae.disableMutationObserver || _.ready("[data-aos]", se), de(ae.disable) || re() ? ue() : (document.querySelector("body").setAttribute("data-aos-easing", ae.easing), document.querySelector("body").setAttribute("data-aos-duration", ae.duration), document.querySelector("body").setAttribute("data-aos-delay", ae.delay), -1 === ["DOMContentLoaded", "load"].indexOf(ae.startEvent) ? document.addEventListener(ae.startEvent, function () {
        ce(!0);
      }) : window.addEventListener("load", function () {
        ce(!0);
      }), "DOMContentLoaded" === ae.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 && ce(!0), window.addEventListener("resize", $(ce, ae.debounceDelay, !0)), window.addEventListener("orientationchange", $(ce, ae.debounceDelay, !0)), oe);
    },
    refresh: ce,
    refreshHard: se
  };
});
// @codekit-prepend 'jquery/dist/jquery.js'
// @codekit-prepend 'foundation-sites/dist/js/foundation.min.js'
// ======================================================================
// ███████  ██████  ██    ██ ███    ██ ██████   █████  ████████ ██  ██████  ███    ██
// ██      ██    ██ ██    ██ ████   ██ ██   ██ ██   ██    ██    ██ ██    ██ ████   ██
// █████   ██    ██ ██    ██ ██ ██  ██ ██   ██ ███████    ██    ██ ██    ██ ██ ██  ██
// ██      ██    ██ ██    ██ ██  ██ ██ ██   ██ ██   ██    ██    ██ ██    ██ ██  ██ ██
// ██       ██████   ██████  ██   ████ ██████  ██   ██    ██    ██  ██████  ██   ████
// ███████  ██████ ██████  ██ ██████  ████████ ███████
// ██      ██      ██   ██ ██ ██   ██    ██    ██
// ███████ ██      ██████  ██ ██████     ██    ███████
//      ██ ██      ██   ██ ██ ██         ██         ██
// ███████  ██████ ██   ██ ██ ██         ██    ███████
// ======================================================================
// ======================================================================
// FOUNDATION UTILITY SCRIPTS
// ======================================================================
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.core.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.mediaQuery.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.motion.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.box.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.keyboard.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.nest.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.imageLoader.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.timer.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.touch.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.util.triggers.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.smoothScroll.min.js'
// ======================================================================
// FOUNDATION PLUGINS
// ======================================================================
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.abide.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.accordion.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.accordionMenu.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.drilldown.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.dropdown.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.dropdownMenu.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.equalizer.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.interchange.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.magellan.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.offcanvas.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.responsiveMenu.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.responsiveToggle.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.reveal.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.sticky.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.tabs.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.toggler.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.tooltip.min.js'
// @codekit-prepend 'foundation-sites/dist/js/plugins/foundation.responsiveAccordionTabs.min.js'
// @codekit-prepend 'motion-ui/dist/motion-ui.js'
// ======================================================================
// ██████  ██      ██    ██  ██████  ██ ███    ██ ███████
// ██   ██ ██      ██    ██ ██       ██ ████   ██ ██
// ██████  ██      ██    ██ ██   ███ ██ ██ ██  ██ ███████
// ██      ██      ██    ██ ██    ██ ██ ██  ██ ██      ██
// ██      ███████  ██████   ██████  ██ ██   ████ ███████
// ======================================================================
// @codekit-prepend 'lazysizes/lazysizes.js'
// @codekit-prepend 'lazysizes/plugins/unveilhooks/ls.unveilhooks.js'
// @codekit-prepend "swiper/swiper-bundle.js"
// @codekit-prepend 'aos/dist/aos.js'
$(document).foundation(); // LOADER
// $(window).load(function() {
//     $("body").addClass('all-loaded');
// });
// ======================================================================
//  ██████  ██████  ███    ███ ██████   ██████  ███    ██ ███████ ███    ██ ████████ ███████
// ██      ██    ██ ████  ████ ██   ██ ██    ██ ████   ██ ██      ████   ██    ██    ██
// ██      ██    ██ ██ ████ ██ ██████  ██    ██ ██ ██  ██ █████   ██ ██  ██    ██    ███████
// ██      ██    ██ ██  ██  ██ ██      ██    ██ ██  ██ ██ ██      ██  ██ ██    ██         ██
//  ██████  ██████  ██      ██ ██       ██████  ██   ████ ███████ ██   ████    ██    ███████
// ======================================================================
// @codekit-append 'accordions.js'
// @codekit-append 'gradient-background-steps.js'
// @codekit-append 'gradient-steps-tabs.js'

Foundation.Abide.defaults.patterns["dashes_only"] = /^[0-9-+]*$/;
$("[data-off-canvas]").on("opened.zf.offcanvas", function () {
  fixScroll();
  $(window).on("scroll", fixScroll);
});
$("[data-off-canvas]").on("closed.zf.offcanvas", function () {
  $(window).off("scroll", fixScroll);
  $sticky.css("transform", "translateY(0)");
}); // ======================================================================
// LAZY LOADING
// ======================================================================
// window.lazySizesConfig = window.lazySizesConfig || {};
// lazySizesConfig.loadMode = 3;
// lazySizesConfig.expFactor = 4;
// lazySizesConfig.expand = 500;
//add simple support for background images:

document.addEventListener("lazybeforeunveil", function (e) {
  var bg = e.target.getAttribute("data-bg");

  if (bg) {
    e.target.style.backgroundImage = "url(" + bg + ")";
  }
}); // -----  End of LAZY LOADING  ----------
// ======================================================================
// =            SCROLLUP            =
// ======================================================================

if ($("#scrollUp").length) {
  var scrollTrigger = 300,
      // px
  backToTop = function () {
    var scrollTop = $(window).scrollTop();

    if (scrollTop > scrollTrigger) {
      $("#scrollUp").addClass("scrollup--show");
    } else {
      $("#scrollUp").removeClass("scrollup--show");
    }
  };

  backToTop();
  $(window).on("scroll", function () {
    backToTop();
  });
  $("#scrollUp").on("click", function (e) {
    e.preventDefault();
    $("html,body").animate({
      scrollTop: 0
    }, 750);
  });
} // -----  End of SCROLLUP  -------------------------
// ======================================================================
// HAMBURGER ICON ANIMATION
// ======================================================================


$(document).ready(function () {
  $(".hamburger").click(function () {
    $(this).toggleClass("is-active");
  });
  $(".js-off-canvas-overlay").click(function () {
    $(".hamburger").removeClass("is-active");
  });
}); // -----  End of HAMBURGER ICON ANIMATION  ----------
// ======================================================================
//  █████   ██████  ███████
// ██   ██ ██    ██ ██
// ███████ ██    ██ ███████
// ██   ██ ██    ██      ██
// ██   ██  ██████  ███████
// ======================================================================

$(document).ready(function () {
  AOS.init({
    // duration: 750,
    // mirror: false,
    startEvent: "load" // offset: "150"

  });
}); // -----  End of AOS- ANIMATE ON SCROLL  ----------
// ======================================================================
// ███████ ██     ██ ██ ██████  ███████ ██████
// ██      ██     ██ ██ ██   ██ ██      ██   ██
// ███████ ██  █  ██ ██ ██████  █████   ██████
//      ██ ██ ███ ██ ██ ██      ██      ██   ██
// ███████  ███ ███  ██ ██      ███████ ██   ██
// ======================================================================

window.onload = function () {
  const swiper = new Swiper(".swiper", {
    loop: true,
    autoHeight: true,
    centeredSlides: true,
    grabCursor: true,
    preloadImages: false,
    lazy: {
      loadPrevNext: true,
      loadPrevNextAmount: 5
    },
    loadOnTransitionStart: true,
    keyboard: {
      enabled: true
    },
    pagination: {
      el: ".swiper-pagination",
      type: "bullets",
      clickable: true
    },
    navigation: {
      nextEl: ".swiper-button-next",
      prevEl: ".swiper-button-prev"
    } // observer: true,
    // observeParents: true

  });
}; // -----  End of SWIPER  -----------------------------------
var $sticky = $(".sticky");

function fixScroll() {
  var topOffset = $(window).scrollTop();
  $sticky.css("transform", "translate3d(0, " + topOffset + "px, 0)");
} // ===========================================================================
// =            ACCORDION BACKGROUND COLORS            =
// ===========================================================================


$(".accordion-gradient").each(function () {
  var length = $(this).children().length;
  $(this).find(".accordion-item").each(function (index) {
    var colorClass = "accordion-gradient-" + Math.round(index / (length - 1) * 100);
    $(this).addClass(colorClass);
  });
});
$(".accordion-gradient-theme-2").each(function () {
  var length = $(this).children().length;
  $(this).find(".accordion-item").each(function (index) {
    var colorClass = "accordion-gradient-theme-2-" + Math.round(index / (length - 1) * 100);
    $(this).addClass(colorClass);
  });
});
$(".accordion-gradient-theme-3").each(function () {
  var length = $(this).children().length;
  $(this).find(".accordion-item").each(function (index) {
    var colorClass = "accordion-gradient-theme-3-" + Math.round(index / (length - 1) * 100);
    $(this).addClass(colorClass);
  });
}); // -----  End of ACCORDION BACKGROUND COLORS  --------------------------------
// ===========================================================================
// =            ACCORDION SCROLL TO TOP            =
// ===========================================================================

$(".accordion-title").click(function () {
  setTimeout(function () {
    $("html,body").animate({// scrollTop: $(".is-active").offset().top - 84
    });
  }, 300);
});
$("ul.accordion li a.accordion-title").on("click", function () {
  var n = "";
  IsBlueVisible = $("#navBarInPage").css("display");

  if (IsBlueVisible == "block") {
    n = $.trim($("#navSubBar .sticky").height() + $("#navBarInPage").outerHeight());
  } else {
    if ($(".microsite-sticky-header").length > 0) {
      n = $.trim($("#navSubBar").height() + $("#navBarInPage").height() + $(".sticky").outerHeight());
    } else {
      if ($(".micro-sub-page-header").length > 0) {
        n = $.trim($("#navSubBar").height());
      } else {
        if ($(".bg-white .sticky").length > 0) {
          n = $.trim($(".bg-white .sticky").height());
        } else {
          n = $.trim($("#navSubBar .sticky").outerHeight());
        }
      }
    }
  }

  $(this).parent("li").siblings(".accordion-item").find(".accordion-content").hide();
  $("html,body").animate({
    scrollTop: $(this).parent("li").offset().top - n
  }, 1000);
}); // -----  End of ACCORDION SCROLL TO TOP  -------------------------
// ======================================================================
// MAGELLAN AND ACCORDION RESET
// ======================================================================

$(".accordion").on("mutateme.zf.trigger", function () {
  $("#magellan").foundation("calcPoints");
}); // -----  End of MAGELLAN AND ACCORDION RESET  ----------
// ======================================================================
// GRADIENT STEPS BACKGROUND
// ======================================================================
$(".bg-steps").each(function () {
  var length = $(this).children().length;
  $(this).children("div").each(function (index) {
    var colorClass = "bg-steps-" + Math.round(index / (length - 1) * 100);
    $(this).addClass(colorClass);
  });
}); // $(".bg-steps-green").each(function() {
//     var length = $(this).children().length;
//     $(this).find(".accordion-item").each(function(index) {
//         var colorClass = "bg-steps-green-" + Math.round((index / (length - 1)) * 100);
//         $(this).addClass(colorClass);
//     });
// });
// -----  End of GRADIENT STEPS BACKGROUND  ----------
// ======================================================================
// TABS GRADIENT STEPS
// ======================================================================
// $(".tabs.bg-steps-blue-green").each(function() {
//     var length = $(this).children().length;
//     $(this).find(".tabs-title").each(function(index) {
//         var colorClass = "bg-steps-blue-green-" + Math.round((index / (length - 1)) * 100);
//         $(this).addClass(colorClass);
//     });
// });
$(".tabs.bg-steps-primary").each(function () {
  var length = $(this).children().length;
  $(this).find(".tabs-title").each(function (index) {
    var colorClass = "bg-steps-primary-" + Math.round(index / (length - 1) * 100);
    $(this).addClass(colorClass);
  });
}); // $(".tabs.bg-steps-green").each(function() {
//     var length = $(this).children().length;
//     $(this).find(".tabs-title").each(function(index) {
//         var colorClass = "bg-steps-green-" + Math.round((index / (length - 1)) * 100);
//         $(this).addClass(colorClass);
//     });
// });
// -----  End of TABS GRADIENT STEPS  ----------
// @codekit-prepend "js/cognizant-framework-2021.js"
// var rellax = new Rellax('.rellax');
// Set wrapper to .custom-element instead of the body
// var rellax = new Rellax('.rellax', {
//   wrapper: '.bg-parallax'
// });
// =============================================================================================
// AOS- ANIMATE ON SCROLL
// =============================================================================================
// $(document).ready(function() {
//   AOS.init({
//       // startEvent: 'load'
//   });
// });
// -----  End of AOS- ANIMATE ON SCROLL  ---------------------------------------------
// function removeAOS() {
//     $('#pardotModal .column').removeClass('aos-animate');
// }
$("[data-reveal]").on("closeme.zf.reveal", function () {
  $("#pardotModal *").removeClass("aos-animate");
}); // $('[data-reveal]').on('closeme.zf.reveal', function() {
//      setTimeout(function() {
//          $('#pardotModal *').removeClass('aos-animate');
//      }, 100);
// });
// $('[data-reveal]').on('closeme.zf.reveal', function() {
//     var modal = $(this);
//     console.log(modal);
//     setTimeout(function() {
//         console.log('aos refresh')
//         // AOS.refreshHard({});
//     }, 600);
// });
// AOS.init({
// });
// document.addEventListener("aos:in:super-duper", ({ detail }) => {
//     console.log("animated in", detail);
// });
//
// document.addEventListener("aos:out:super-duper", ({ detail }) => {
//     console.log("animated out", detail);
// });

var swiperAston = new Swiper(".swiper-container-aston", {
  // allowSlideNext: false,
  // allowSlidePrev: false
  autoHeight: true,
  pagination: {
    el: ".swiper-pagination",
    type: "bullets",
    clickable: true
  }
}); // ======================================================================
// MODAL OPEN ON PAGE LOAD
// ======================================================================

$(document).ready(function () {
  $("#video-modal-ie").foundation("open");
}); // -----  End of MODAL OPEN ON PAGE LOAD  ----------
// ======================================================================
// YOUTUBE AUTO PLAY
// ======================================================================
// $('.open-button-trigger').click(function(){
//   $('#youtube-video').attr('src', 'https://www.youtube.com/embed/496vDXsr9fw?enablejsapi=1&showinfo=0&modestbranding=1&wmode=transparent&controls=1&autohide=1&rel=0&autoplay=1&autoplay=1')
// });
//
// $('.close-button-trigger').click(function(){
//   $('#youtube-video').attr('src', 'https://www.youtube.com/embed/496vDXsr9fw?enablejsapi=1&showinfo=0&modestbranding=1&wmode=transparent&controls=1&autohide=1&rel=0')
// });
// -----  End of YOUTUBE AUTO PLAY  ----------

//# sourceMappingURL=app-min.js.map
